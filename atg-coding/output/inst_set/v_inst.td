class VWADDU_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWADDU_VV_AUX: VWADDU_VV_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VMADC_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010001;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMADC_VI_AUX: VMADC_VI_FM2, TSFlagTemplate<InstFormatR>;
class VWADDU_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWADDU_VX_AUX: VWADDU_VX_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VWADDU_WX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWADDU_WX_AUX: VWADDU_WX_FM2, TSFlagTemplate<InstFormatR, WidenW>;
class VWADDU_WV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWADDU_WV_AUX: VWADDU_WV_FM2, TSFlagTemplate<InstFormatR, WidenW>;
class VSADD_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSADD_VV_AUX: VSADD_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSADD_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSADD_VX_AUX: VSADD_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSADD_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSADD_VI_AUX: VSADD_VI_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSADDU_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSADDU_VV_AUX: VSADDU_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VAADDU_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VAADDU_VV_AUX: VAADDU_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSADDU_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSADDU_VX_AUX: VSADDU_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VAADDU_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VAADDU_VX_AUX: VAADDU_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSADDU_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSADDU_VI_AUX: VSADDU_VI_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VADD_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VADD_VV_AUX: VADD_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VADD_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VADD_VX_AUX: VADD_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VWADD_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWADD_VV_AUX: VWADD_VV_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VWADD_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWADD_VX_AUX: VWADD_VX_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VWADD_WV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWADD_WV_AUX: VWADD_WV_FM2, TSFlagTemplate<InstFormatR, WidenW>;
class VWADD_WX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWADD_WX_AUX: VWADD_WX_FM2, TSFlagTemplate<InstFormatR, WidenW>;
class VADC_VVM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010000;
	bits<1> vm = 0b0;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VADC_VVM_AUX: VADC_VVM_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VADC_VXM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010000;
	bits<1> vm = 0b0;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VADC_VXM_AUX: VADC_VXM_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VADC_VIM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010000;
	bits<1> vm = 0b0;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VADC_VIM_AUX: VADC_VIM_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VAADD_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VAADD_VV_AUX: VAADD_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VAADD_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VAADD_VX_AUX: VAADD_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VADD_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VADD_VI_AUX: VADD_VI_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VAND_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VAND_VV_AUX: VAND_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VAND_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VAND_VX_AUX: VAND_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VREDAND_VS_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VREDAND_VS_AUX: VREDAND_VS_FM2, TSFlagTemplate<InstFormatR>;
class VMAND_MM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011001;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMAND_MM_AUX: VMAND_MM_FM2, TSFlagTemplate<InstFormatR>;
class VMNAND_MM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011101;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMNAND_MM_AUX: VMNAND_MM_FM2, TSFlagTemplate<InstFormatR>;
class VMANDNOT_MM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011000;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMANDNOT_MM_AUX: VMANDNOT_MM_FM2, TSFlagTemplate<InstFormatR>;
class VID_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010100;
	bits<1> vm;
	bits<5> vs2 = 0b00000;
	bits<5> vs1 = 0b10001;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VID_V_AUX: VID_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VAND_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VAND_VI_AUX: VAND_VI_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VRSUB_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VRSUB_VX_AUX: VRSUB_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMSBC_VVM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010011;
	bits<1> vm = 0b0;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSBC_VVM_AUX: VMSBC_VVM_FM2, TSFlagTemplate<InstFormatR>;
class VSBC_VVM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm = 0b0;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSBC_VVM_AUX: VSBC_VVM_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSBC_VXM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm = 0b0;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSBC_VXM_AUX: VSBC_VXM_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VWMACCUS_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWMACCUS_VX_AUX: VWMACCUS_VX_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VASUB_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VASUB_VV_AUX: VASUB_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VASUB_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VASUB_VX_AUX: VASUB_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VWSUBU_WV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWSUBU_WV_AUX: VWSUBU_WV_FM2, TSFlagTemplate<InstFormatR, WidenW>;
class VMSBC_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010011;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSBC_VX_AUX: VMSBC_VX_FM2, TSFlagTemplate<InstFormatR>;
class VMSBC_VXM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010011;
	bits<1> vm = 0b0;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSBC_VXM_AUX: VMSBC_VXM_FM2, TSFlagTemplate<InstFormatR>;
class VMSBC_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010011;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSBC_VV_AUX: VMSBC_VV_FM2, TSFlagTemplate<InstFormatR>;
class VASUBU_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VASUBU_VV_AUX: VASUBU_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VASUBU_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VASUBU_VX_AUX: VASUBU_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VRGATHER_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VRGATHER_VV_AUX: VRGATHER_VV_FM2, TSFlagTemplate<InstFormatR, Vrgather>;
class VRGATHEREI16_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VRGATHEREI16_VV_AUX: VRGATHEREI16_VV_FM2, TSFlagTemplate<InstFormatR, Vrgather>;
class VRGATHER_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VRGATHER_VI_AUX: VRGATHER_VI_FM2, TSFlagTemplate<InstFormatR, Vrgather>;
class VMSBF_M_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b00001;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSBF_M_AUX: VMSBF_M_FM2, TSFlagTemplate<InstFormatR, Iota>;
class VMSIF_M_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b00011;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSIF_M_AUX: VMSIF_M_FM2, TSFlagTemplate<InstFormatR, Iota>;
class VRGATHER_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VRGATHER_VX_AUX: VRGATHER_VX_FM2, TSFlagTemplate<InstFormatR, Vrgather>;
class VSETVL_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> rd;
	bits<7> opcode = 0b1010111;
	let Inst{31-31} = 0b1;
	let Inst{30-25} = 0b000000;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = 0b111;
	let Inst{11-7} = rd;
	let Inst{6-0} = opcode;
}
class VSETVL_AUX: VSETVL_FM2, TSFlagTemplate<InstFormatR>;
class VSETVLI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<11> vtypei;
	bits<5> rs1;
	bits<5> rd;
	bits<7> opcode = 0b1010111;
	let Inst{31-31} = 0b0;
	let Inst{30-20} = vtypei;
	let Inst{19-15} = rs1;
	let Inst{14-12} = 0b111;
	let Inst{11-7} = rd;
	let Inst{6-0} = opcode;
}
class VSETVLI_AUX: VSETVLI_FM2, TSFlagTemplate<InstFormatR>;
class VFIRST_M_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b10001;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFIRST_M_AUX: VFIRST_M_FM2, TSFlagTemplate<InstFormatR>;
class VSETIVLI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<10> vtypei;
	bits<5> uimm;
	bits<5> rd;
	bits<7> opcode = 0b1010111;
	let Inst{31-31} = 0b1;
	let Inst{30-30} = 0b1;
	let Inst{29-20} = vtypei;
	let Inst{19-15} = uimm;
	let Inst{14-12} = 0b111;
	let Inst{11-7} = rd;
	let Inst{6-0} = opcode;
}
class VSETIVLI_AUX: VSETIVLI_FM2, TSFlagTemplate<InstFormatR>;
class VMSEQ_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSEQ_VV_AUX: VMSEQ_VV_FM2, TSFlagTemplate<InstFormatR>;
class VMSNE_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSNE_VX_AUX: VMSNE_VX_FM2, TSFlagTemplate<InstFormatR>;
class VMSEQ_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSEQ_VX_AUX: VMSEQ_VX_FM2, TSFlagTemplate<InstFormatR>;
class VMSNE_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSNE_VV_AUX: VMSNE_VV_FM2, TSFlagTemplate<InstFormatR>;
class VMSEQ_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSEQ_VI_AUX: VMSEQ_VI_FM2, TSFlagTemplate<InstFormatR>;
class VMSNE_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSNE_VI_AUX: VMSNE_VI_FM2, TSFlagTemplate<InstFormatR>;
class VMSLE_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSLE_VV_AUX: VMSLE_VV_FM2, TSFlagTemplate<InstFormatR>;
class VMSLE_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSLE_VX_AUX: VMSLE_VX_FM2, TSFlagTemplate<InstFormatR>;
class VMSLEU_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSLEU_VV_AUX: VMSLEU_VV_FM2, TSFlagTemplate<InstFormatR>;
class VMSLEU_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSLEU_VX_AUX: VMSLEU_VX_FM2, TSFlagTemplate<InstFormatR>;
class VMSLE_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSLE_VI_AUX: VMSLE_VI_FM2, TSFlagTemplate<InstFormatR>;
class VMSLEU_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSLEU_VI_AUX: VMSLEU_VI_FM2, TSFlagTemplate<InstFormatR>;
class VMSLT_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSLT_VV_AUX: VMSLT_VV_FM2, TSFlagTemplate<InstFormatR>;
class VMSLT_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSLT_VX_AUX: VMSLT_VX_FM2, TSFlagTemplate<InstFormatR>;
class VMSGT_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSGT_VX_AUX: VMSGT_VX_FM2, TSFlagTemplate<InstFormatR>;
class VMSLTU_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSLTU_VV_AUX: VMSLTU_VV_FM2, TSFlagTemplate<InstFormatR>;
class VMSLTU_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSLTU_VX_AUX: VMSLTU_VX_FM2, TSFlagTemplate<InstFormatR>;
class VMSGTU_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSGTU_VX_AUX: VMSGTU_VX_FM2, TSFlagTemplate<InstFormatR>;
class VMSGTU_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSGTU_VI_AUX: VMSGTU_VI_FM2, TSFlagTemplate<InstFormatR>;
class VMSGT_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSGT_VI_AUX: VMSGT_VI_FM2, TSFlagTemplate<InstFormatR>;
class VDIV_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VDIV_VV_AUX: VDIV_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VDIV_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VDIV_VX_AUX: VDIV_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VDIVU_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VDIVU_VV_AUX: VDIVU_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VDIVU_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VDIVU_VX_AUX: VDIVU_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFADD_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFADD_VF_AUX: VFADD_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFWADD_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWADD_VF_AUX: VFWADD_VF_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VFWADD_WF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWADD_WF_AUX: VFWADD_WF_FM2, TSFlagTemplate<InstFormatR, WidenW>;
class VFADD_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFADD_VV_AUX: VFADD_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFWADD_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWADD_VV_AUX: VFWADD_VV_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VFWADD_WV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWADD_WV_AUX: VFWADD_WV_FM2, TSFlagTemplate<InstFormatR, WidenW>;
class VMFEQ_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMFEQ_VF_AUX: VMFEQ_VF_FM2, TSFlagTemplate<InstFormatR>;
class VMFEQ_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMFEQ_VV_AUX: VMFEQ_VV_FM2, TSFlagTemplate<InstFormatR>;
class VFCLASS_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b10000;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFCLASS_V_AUX: VFCLASS_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMFLE_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMFLE_VF_AUX: VMFLE_VF_FM2, TSFlagTemplate<InstFormatR>;
class VMFGE_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMFGE_VF_AUX: VMFGE_VF_FM2, TSFlagTemplate<InstFormatR>;
class VMFLE_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMFLE_VV_AUX: VMFLE_VV_FM2, TSFlagTemplate<InstFormatR>;
class VMFLT_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMFLT_VF_AUX: VMFLT_VF_FM2, TSFlagTemplate<InstFormatR>;
class VMFGT_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMFGT_VF_AUX: VMFGT_VF_FM2, TSFlagTemplate<InstFormatR>;
class VMFLT_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMFLT_VV_AUX: VMFLT_VV_FM2, TSFlagTemplate<InstFormatR>;
class VMFNE_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMFNE_VF_AUX: VMFNE_VF_FM2, TSFlagTemplate<InstFormatR>;
class VMFNE_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMFNE_VV_AUX: VMFNE_VV_FM2, TSFlagTemplate<InstFormatR>;
class VFDIV_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFDIV_VF_AUX: VFDIV_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFRDIV_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFRDIV_VF_AUX: VFRDIV_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFDIV_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFDIV_VV_AUX: VFDIV_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFWCVT_F_X_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b01011;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWCVT_F_X_V_AUX: VFWCVT_F_X_V_FM2, TSFlagTemplate<InstFormatR, WidenCvt>;
class VFCVT_RTZ_XU_F_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b00110;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFCVT_RTZ_XU_F_V_AUX: VFCVT_RTZ_XU_F_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFCVT_RTZ_X_F_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b00111;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFCVT_RTZ_X_F_V_AUX: VFCVT_RTZ_X_F_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFCVT_F_X_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b00011;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFCVT_F_X_V_AUX: VFCVT_F_X_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFWCVT_RTZ_XU_F_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b01110;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWCVT_RTZ_XU_F_V_AUX: VFWCVT_RTZ_XU_F_V_FM2, TSFlagTemplate<InstFormatR, WidenCvt>;
class VFWCVT_RTZ_X_F_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b01111;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWCVT_RTZ_X_F_V_AUX: VFWCVT_RTZ_X_F_V_FM2, TSFlagTemplate<InstFormatR, WidenCvt>;
class VFWCVT_F_F_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b01100;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWCVT_F_F_V_AUX: VFWCVT_F_F_V_FM2, TSFlagTemplate<InstFormatR, WidenCvt>;
class VFNCVT_RTZ_XU_F_W_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b10110;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFNCVT_RTZ_XU_F_W_AUX: VFNCVT_RTZ_XU_F_W_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFNCVT_RTZ_X_F_W_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b10111;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFNCVT_RTZ_X_F_W_AUX: VFNCVT_RTZ_X_F_W_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFNCVT_F_X_W_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b10011;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFNCVT_F_X_W_AUX: VFNCVT_F_X_W_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFNCVT_ROD_F_F_W_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b10101;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFNCVT_ROD_F_F_W_AUX: VFNCVT_ROD_F_F_W_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFWCVT_F_XU_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b01010;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWCVT_F_XU_V_AUX: VFWCVT_F_XU_V_FM2, TSFlagTemplate<InstFormatR, WidenCvt>;
class VFCVT_F_XU_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b00010;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFCVT_F_XU_V_AUX: VFCVT_F_XU_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFNCVT_F_XU_W_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b10010;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFNCVT_F_XU_W_AUX: VFNCVT_F_XU_W_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFNCVT_F_F_W_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b10100;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFNCVT_F_F_W_AUX: VFNCVT_F_F_W_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFMACC_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFMACC_VF_AUX: VFMACC_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFNMACC_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFNMACC_VF_AUX: VFNMACC_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFMADD_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFMADD_VF_AUX: VFMADD_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFNMADD_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFNMADD_VF_AUX: VFNMADD_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFWMACC_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWMACC_VF_AUX: VFWMACC_VF_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VFWNMACC_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWNMACC_VF_AUX: VFWNMACC_VF_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VFMACC_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFMACC_VV_AUX: VFMACC_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFNMACC_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFNMACC_VV_AUX: VFNMACC_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFMADD_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFMADD_VV_AUX: VFMADD_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFNMADD_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFNMADD_VV_AUX: VFNMADD_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFWMACC_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWMACC_VV_AUX: VFWMACC_VV_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VFWNMACC_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWNMACC_VV_AUX: VFWNMACC_VV_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VFMAX_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFMAX_VF_AUX: VFMAX_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFMAX_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFMAX_VV_AUX: VFMAX_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFMIN_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFMIN_VF_AUX: VFMIN_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFMIN_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFMIN_VV_AUX: VFMIN_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFMSAC_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFMSAC_VF_AUX: VFMSAC_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFNMSAC_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFNMSAC_VF_AUX: VFNMSAC_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFMSUB_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFMSUB_VF_AUX: VFMSUB_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFNMSUB_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFNMSUB_VF_AUX: VFNMSUB_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFWMSAC_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWMSAC_VF_AUX: VFWMSAC_VF_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VFWNMSAC_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWNMSAC_VF_AUX: VFWNMSAC_VF_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VFMSAC_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFMSAC_VV_AUX: VFMSAC_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFNMSAC_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFNMSAC_VV_AUX: VFNMSAC_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFMSUB_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFMSUB_VV_AUX: VFMSUB_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFNMSUB_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFNMSUB_VV_AUX: VFNMSUB_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFWMSAC_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWMSAC_VV_AUX: VFWMSAC_VV_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VFWNMSAC_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWNMSAC_VV_AUX: VFWNMSAC_VV_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VFMUL_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFMUL_VF_AUX: VFMUL_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFWMUL_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWMUL_VF_AUX: VFWMUL_VF_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VFMUL_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFMUL_VV_AUX: VFMUL_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFWMUL_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWMUL_VV_AUX: VFWMUL_VV_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VFREC7_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b00101;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFREC7_V_AUX: VFREC7_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFRSQRT7_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b00100;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFRSQRT7_V_AUX: VFRSQRT7_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFSQRT_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b00000;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFSQRT_V_AUX: VFSQRT_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFSUB_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFSUB_VF_AUX: VFSUB_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFWSUB_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWSUB_VF_AUX: VFWSUB_VF_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VFWSUB_WF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWSUB_WF_AUX: VFWSUB_WF_FM2, TSFlagTemplate<InstFormatR, WidenW>;
class VFSUB_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFSUB_VV_AUX: VFSUB_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFRSUB_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFRSUB_VF_AUX: VFRSUB_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFWSUB_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWSUB_VV_AUX: VFWSUB_VV_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VFWSUB_WV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWSUB_WV_AUX: VFWSUB_WV_FM2, TSFlagTemplate<InstFormatR, WidenW>;
class VFWCVT_X_F_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b01001;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWCVT_X_F_V_AUX: VFWCVT_X_F_V_FM2, TSFlagTemplate<InstFormatR, WidenCvt>;
class VFCVT_X_F_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b00001;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFCVT_X_F_V_AUX: VFCVT_X_F_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFNCVT_X_F_W_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b10001;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFNCVT_X_F_W_AUX: VFNCVT_X_F_W_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFWCVT_XU_F_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b01000;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWCVT_XU_F_V_AUX: VFWCVT_XU_F_V_FM2, TSFlagTemplate<InstFormatR, WidenCvt>;
class VFCVT_XU_F_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b00000;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFCVT_XU_F_V_AUX: VFCVT_XU_F_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFNCVT_XU_F_W_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b10000;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFNCVT_XU_F_W_AUX: VFNCVT_XU_F_W_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VWSUBU_WX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWSUBU_WX_AUX: VWSUBU_WX_FM2, TSFlagTemplate<InstFormatR, WidenW>;
class VWSUBU_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWSUBU_VV_AUX: VWSUBU_VV_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VWSUBU_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWSUBU_VX_AUX: VWSUBU_VX_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VLE8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b000;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLE8_V_AUX: VLE8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLE1_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b000;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b01011;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLE1_V_AUX: VLE1_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSE8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b000;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSE8_V_AUX: VLSE8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXEI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b000;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXEI8_V_AUX: VLUXEI8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXEI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b000;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXEI8_V_AUX: VLOXEI8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLE8FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b000;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLE8FF_V_AUX: VLE8FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG2E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b001;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG2E8_V_AUX: VLSEG2E8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG3E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b010;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG3E8_V_AUX: VLSEG3E8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG4E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b011;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG4E8_V_AUX: VLSEG4E8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG5E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b100;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG5E8_V_AUX: VLSEG5E8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG6E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b101;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG6E8_V_AUX: VLSEG6E8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG7E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b110;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG7E8_V_AUX: VLSEG7E8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG8E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b111;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG8E8_V_AUX: VLSEG8E8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG2E8FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b001;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG2E8FF_V_AUX: VLSEG2E8FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG3E8FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b010;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG3E8FF_V_AUX: VLSEG3E8FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG4E8FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b011;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG4E8FF_V_AUX: VLSEG4E8FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG5E8FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b100;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG5E8FF_V_AUX: VLSEG5E8FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG6E8FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b101;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG6E8FF_V_AUX: VLSEG6E8FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG7E8FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b110;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG7E8FF_V_AUX: VLSEG7E8FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG8E8FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b111;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG8E8FF_V_AUX: VLSEG8E8FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG2E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b001;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG2E8_V_AUX: VLSSEG2E8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG3E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b010;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG3E8_V_AUX: VLSSEG3E8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG4E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b011;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG4E8_V_AUX: VLSSEG4E8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG5E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b100;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG5E8_V_AUX: VLSSEG5E8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG6E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b101;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG6E8_V_AUX: VLSSEG6E8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG7E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b110;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG7E8_V_AUX: VLSSEG7E8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG8E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b111;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG8E8_V_AUX: VLSSEG8E8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG2EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b001;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG2EI8_V_AUX: VLUXSEG2EI8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG3EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b010;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG3EI8_V_AUX: VLUXSEG3EI8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG4EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b011;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG4EI8_V_AUX: VLUXSEG4EI8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG5EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b100;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG5EI8_V_AUX: VLUXSEG5EI8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG6EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b101;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG6EI8_V_AUX: VLUXSEG6EI8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG7EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b110;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG7EI8_V_AUX: VLUXSEG7EI8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG8EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b111;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG8EI8_V_AUX: VLUXSEG8EI8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG2EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b001;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG2EI8_V_AUX: VLOXSEG2EI8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG3EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b010;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG3EI8_V_AUX: VLOXSEG3EI8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG4EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b011;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG4EI8_V_AUX: VLOXSEG4EI8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG5EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b100;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG5EI8_V_AUX: VLOXSEG5EI8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG6EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b101;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG6EI8_V_AUX: VLOXSEG6EI8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG7EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b110;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG7EI8_V_AUX: VLOXSEG7EI8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG8EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b111;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG8EI8_V_AUX: VLOXSEG8EI8_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VL1RE8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b000;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> lumop = 0b01000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VL1RE8_V_AUX: VL1RE8_V_FM2, TSFlagTemplate<InstFormatR>;
class VL2RE8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b001;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> lumop = 0b01000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VL2RE8_V_AUX: VL2RE8_V_FM2, TSFlagTemplate<InstFormatR>;
class VL4RE8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b011;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> lumop = 0b01000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VL4RE8_V_AUX: VL4RE8_V_FM2, TSFlagTemplate<InstFormatR>;
class VL8RE8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b111;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> lumop = 0b01000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VL8RE8_V_AUX: VL8RE8_V_FM2, TSFlagTemplate<InstFormatR>;
class VLE64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b000;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLE64_V_AUX: VLE64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSE64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b000;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSE64_V_AUX: VLSE64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXEI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b000;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXEI64_V_AUX: VLUXEI64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXEI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b000;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXEI64_V_AUX: VLOXEI64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLE64FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b000;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLE64FF_V_AUX: VLE64FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG2E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b001;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG2E64_V_AUX: VLSEG2E64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG3E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b010;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG3E64_V_AUX: VLSEG3E64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG4E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b011;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG4E64_V_AUX: VLSEG4E64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG5E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b100;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG5E64_V_AUX: VLSEG5E64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG6E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b101;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG6E64_V_AUX: VLSEG6E64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG7E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b110;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG7E64_V_AUX: VLSEG7E64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG8E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b111;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG8E64_V_AUX: VLSEG8E64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG2E64FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b001;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG2E64FF_V_AUX: VLSEG2E64FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG3E64FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b010;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG3E64FF_V_AUX: VLSEG3E64FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG4E64FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b011;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG4E64FF_V_AUX: VLSEG4E64FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG5E64FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b100;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG5E64FF_V_AUX: VLSEG5E64FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG6E64FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b101;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG6E64FF_V_AUX: VLSEG6E64FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG7E64FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b110;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG7E64FF_V_AUX: VLSEG7E64FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG8E64FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b111;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG8E64FF_V_AUX: VLSEG8E64FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG2E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b001;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG2E64_V_AUX: VLSSEG2E64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG3E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b010;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG3E64_V_AUX: VLSSEG3E64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG4E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b011;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG4E64_V_AUX: VLSSEG4E64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG5E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b100;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG5E64_V_AUX: VLSSEG5E64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG6E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b101;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG6E64_V_AUX: VLSSEG6E64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG7E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b110;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG7E64_V_AUX: VLSSEG7E64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG8E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b111;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG8E64_V_AUX: VLSSEG8E64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG2EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b001;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG2EI64_V_AUX: VLUXSEG2EI64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG3EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b010;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG3EI64_V_AUX: VLUXSEG3EI64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG4EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b011;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG4EI64_V_AUX: VLUXSEG4EI64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG5EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b100;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG5EI64_V_AUX: VLUXSEG5EI64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG6EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b101;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG6EI64_V_AUX: VLUXSEG6EI64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG7EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b110;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG7EI64_V_AUX: VLUXSEG7EI64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG8EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b111;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG8EI64_V_AUX: VLUXSEG8EI64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG2EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b001;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG2EI64_V_AUX: VLOXSEG2EI64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG3EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b010;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG3EI64_V_AUX: VLOXSEG3EI64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG4EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b011;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG4EI64_V_AUX: VLOXSEG4EI64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG5EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b100;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG5EI64_V_AUX: VLOXSEG5EI64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG6EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b101;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG6EI64_V_AUX: VLOXSEG6EI64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG7EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b110;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG7EI64_V_AUX: VLOXSEG7EI64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG8EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b111;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG8EI64_V_AUX: VLOXSEG8EI64_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VL1RE64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b000;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> lumop = 0b01000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VL1RE64_V_AUX: VL1RE64_V_FM2, TSFlagTemplate<InstFormatR>;
class VL2RE64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b001;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> lumop = 0b01000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VL2RE64_V_AUX: VL2RE64_V_FM2, TSFlagTemplate<InstFormatR>;
class VL4RE64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b011;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> lumop = 0b01000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VL4RE64_V_AUX: VL4RE64_V_FM2, TSFlagTemplate<InstFormatR>;
class VL8RE64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b111;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> lumop = 0b01000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VL8RE64_V_AUX: VL8RE64_V_FM2, TSFlagTemplate<InstFormatR>;
class VLE16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b000;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLE16_V_AUX: VLE16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSE16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b000;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSE16_V_AUX: VLSE16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXEI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b000;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXEI16_V_AUX: VLUXEI16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXEI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b000;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXEI16_V_AUX: VLOXEI16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLE16FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b000;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLE16FF_V_AUX: VLE16FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG2E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b001;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG2E16_V_AUX: VLSEG2E16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG3E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b010;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG3E16_V_AUX: VLSEG3E16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG4E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b011;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG4E16_V_AUX: VLSEG4E16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG5E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b100;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG5E16_V_AUX: VLSEG5E16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG6E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b101;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG6E16_V_AUX: VLSEG6E16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG7E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b110;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG7E16_V_AUX: VLSEG7E16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG8E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b111;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG8E16_V_AUX: VLSEG8E16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG2E16FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b001;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG2E16FF_V_AUX: VLSEG2E16FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG3E16FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b010;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG3E16FF_V_AUX: VLSEG3E16FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG4E16FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b011;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG4E16FF_V_AUX: VLSEG4E16FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG5E16FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b100;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG5E16FF_V_AUX: VLSEG5E16FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG6E16FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b101;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG6E16FF_V_AUX: VLSEG6E16FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG7E16FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b110;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG7E16FF_V_AUX: VLSEG7E16FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG8E16FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b111;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG8E16FF_V_AUX: VLSEG8E16FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG2E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b001;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG2E16_V_AUX: VLSSEG2E16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG3E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b010;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG3E16_V_AUX: VLSSEG3E16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG4E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b011;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG4E16_V_AUX: VLSSEG4E16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG5E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b100;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG5E16_V_AUX: VLSSEG5E16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG6E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b101;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG6E16_V_AUX: VLSSEG6E16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG7E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b110;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG7E16_V_AUX: VLSSEG7E16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG8E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b111;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG8E16_V_AUX: VLSSEG8E16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG2EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b001;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG2EI16_V_AUX: VLUXSEG2EI16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG3EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b010;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG3EI16_V_AUX: VLUXSEG3EI16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG4EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b011;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG4EI16_V_AUX: VLUXSEG4EI16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG5EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b100;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG5EI16_V_AUX: VLUXSEG5EI16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG6EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b101;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG6EI16_V_AUX: VLUXSEG6EI16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG7EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b110;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG7EI16_V_AUX: VLUXSEG7EI16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG8EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b111;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG8EI16_V_AUX: VLUXSEG8EI16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG2EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b001;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG2EI16_V_AUX: VLOXSEG2EI16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG3EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b010;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG3EI16_V_AUX: VLOXSEG3EI16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG4EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b011;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG4EI16_V_AUX: VLOXSEG4EI16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG5EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b100;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG5EI16_V_AUX: VLOXSEG5EI16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG6EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b101;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG6EI16_V_AUX: VLOXSEG6EI16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG7EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b110;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG7EI16_V_AUX: VLOXSEG7EI16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG8EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b111;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG8EI16_V_AUX: VLOXSEG8EI16_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VL1RE16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b000;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> lumop = 0b01000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VL1RE16_V_AUX: VL1RE16_V_FM2, TSFlagTemplate<InstFormatR>;
class VL2RE16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b001;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> lumop = 0b01000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VL2RE16_V_AUX: VL2RE16_V_FM2, TSFlagTemplate<InstFormatR>;
class VL4RE16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b011;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> lumop = 0b01000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VL4RE16_V_AUX: VL4RE16_V_FM2, TSFlagTemplate<InstFormatR>;
class VL8RE16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b111;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> lumop = 0b01000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VL8RE16_V_AUX: VL8RE16_V_FM2, TSFlagTemplate<InstFormatR>;
class VLE32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b000;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLE32_V_AUX: VLE32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSE32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b000;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSE32_V_AUX: VLSE32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXEI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b000;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXEI32_V_AUX: VLUXEI32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXEI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b000;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXEI32_V_AUX: VLOXEI32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLE32FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b000;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLE32FF_V_AUX: VLE32FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG2E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b001;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG2E32_V_AUX: VLSEG2E32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG3E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b010;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG3E32_V_AUX: VLSEG3E32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG4E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b011;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG4E32_V_AUX: VLSEG4E32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG5E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b100;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG5E32_V_AUX: VLSEG5E32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG6E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b101;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG6E32_V_AUX: VLSEG6E32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG7E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b110;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG7E32_V_AUX: VLSEG7E32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG8E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b111;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b00000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG8E32_V_AUX: VLSEG8E32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG2E32FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b001;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG2E32FF_V_AUX: VLSEG2E32FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG3E32FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b010;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG3E32FF_V_AUX: VLSEG3E32FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG4E32FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b011;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG4E32FF_V_AUX: VLSEG4E32FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG5E32FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b100;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG5E32FF_V_AUX: VLSEG5E32FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG6E32FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b101;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG6E32FF_V_AUX: VLSEG6E32FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG7E32FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b110;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG7E32FF_V_AUX: VLSEG7E32FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSEG8E32FF_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b111;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm;
	bits<5> lumop = 0b10000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSEG8E32FF_V_AUX: VLSEG8E32FF_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG2E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b001;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG2E32_V_AUX: VLSSEG2E32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG3E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b010;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG3E32_V_AUX: VLSSEG3E32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG4E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b011;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG4E32_V_AUX: VLSSEG4E32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG5E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b100;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG5E32_V_AUX: VLSSEG5E32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG6E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b101;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG6E32_V_AUX: VLSSEG6E32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG7E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b110;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG7E32_V_AUX: VLSSEG7E32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLSSEG8E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b111;
	bits<2> MOPLDStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLSSEG8E32_V_AUX: VLSSEG8E32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG2EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b001;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG2EI32_V_AUX: VLUXSEG2EI32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG3EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b010;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG3EI32_V_AUX: VLUXSEG3EI32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG4EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b011;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG4EI32_V_AUX: VLUXSEG4EI32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG5EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b100;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG5EI32_V_AUX: VLUXSEG5EI32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG6EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b101;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG6EI32_V_AUX: VLUXSEG6EI32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG7EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b110;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG7EI32_V_AUX: VLUXSEG7EI32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLUXSEG8EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b111;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLUXSEG8EI32_V_AUX: VLUXSEG8EI32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG2EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b001;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG2EI32_V_AUX: VLOXSEG2EI32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG3EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b010;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG3EI32_V_AUX: VLOXSEG3EI32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG4EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b011;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG4EI32_V_AUX: VLOXSEG4EI32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG5EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b100;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG5EI32_V_AUX: VLOXSEG5EI32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG6EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b101;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG6EI32_V_AUX: VLOXSEG6EI32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG7EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b110;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG7EI32_V_AUX: VLOXSEG7EI32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VLOXSEG8EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b111;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VLOXSEG8EI32_V_AUX: VLOXSEG8EI32_V_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VL1RE32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b000;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> lumop = 0b01000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VL1RE32_V_AUX: VL1RE32_V_FM2, TSFlagTemplate<InstFormatR>;
class VL2RE32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b001;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> lumop = 0b01000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VL2RE32_V_AUX: VL2RE32_V_FM2, TSFlagTemplate<InstFormatR>;
class VL4RE32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b011;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> lumop = 0b01000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VL4RE32_V_AUX: VL4RE32_V_FM2, TSFlagTemplate<InstFormatR>;
class VL8RE32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b111;
	bits<2> MOPLDUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> lumop = 0b01000;
	bits<5> rs1;
	bits<5> vd;
	bits<7> opcode = 0b0000111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPLDUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = lumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VL8RE32_V_AUX: VL8RE32_V_FM2, TSFlagTemplate<InstFormatR>;
class VMACC_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMACC_VV_AUX: VMACC_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VWMACCU_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWMACCU_VV_AUX: VWMACCU_VV_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VWMACC_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWMACC_VV_AUX: VWMACC_VV_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VWMACCSU_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWMACCSU_VV_AUX: VWMACCSU_VV_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VMADD_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMADD_VX_AUX: VMADD_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMACC_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMACC_VX_AUX: VMACC_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VWMACCU_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWMACCU_VX_AUX: VWMACCU_VX_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VWMACC_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWMACC_VX_AUX: VWMACC_VX_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VWMACCSU_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWMACCSU_VX_AUX: VWMACCSU_VX_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VMADC_VVM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010001;
	bits<1> vm = 0b0;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMADC_VVM_AUX: VMADC_VVM_FM2, TSFlagTemplate<InstFormatR>;
class VMADC_VXM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010001;
	bits<1> vm = 0b0;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMADC_VXM_AUX: VMADC_VXM_FM2, TSFlagTemplate<InstFormatR>;
class VMADC_VIM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010001;
	bits<1> vm = 0b0;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMADC_VIM_AUX: VMADC_VIM_FM2, TSFlagTemplate<InstFormatR>;
class VMADC_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010001;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMADC_VV_AUX: VMADC_VV_FM2, TSFlagTemplate<InstFormatR>;
class VMADC_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010001;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMADC_VX_AUX: VMADC_VX_FM2, TSFlagTemplate<InstFormatR>;
class VMADD_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMADD_VV_AUX: VMADD_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VREDMAXU_VS_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VREDMAXU_VS_AUX: VREDMAXU_VS_FM2, TSFlagTemplate<InstFormatR>;
class VREDMAX_VS_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VREDMAX_VS_AUX: VREDMAX_VS_FM2, TSFlagTemplate<InstFormatR>;
class VFREDMAX_VS_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFREDMAX_VS_AUX: VFREDMAX_VS_FM2, TSFlagTemplate<InstFormatR>;
class VMAX_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMAX_VV_AUX: VMAX_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMAX_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMAX_VX_AUX: VMAX_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMAXU_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMAXU_VV_AUX: VMAXU_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMAXU_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMAXU_VX_AUX: VMAXU_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VREDMINU_VS_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VREDMINU_VS_AUX: VREDMINU_VS_FM2, TSFlagTemplate<InstFormatR>;
class VREDMIN_VS_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VREDMIN_VS_AUX: VREDMIN_VS_FM2, TSFlagTemplate<InstFormatR>;
class VFREDMIN_VS_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFREDMIN_VS_AUX: VFREDMIN_VS_FM2, TSFlagTemplate<InstFormatR>;
class VMIN_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMIN_VV_AUX: VMIN_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMIN_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMIN_VX_AUX: VMIN_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMINU_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMINU_VV_AUX: VMINU_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMINU_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMINU_VX_AUX: VMINU_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VREM_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VREM_VV_AUX: VREM_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VREM_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VREM_VX_AUX: VREM_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VREMU_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VREMU_VV_AUX: VREMU_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VREMU_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VREMU_VX_AUX: VREMU_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMV_V_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010111;
	bits<1> vm = 0b1;
	bits<5> vs2 = 0b00000;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMV_V_V_AUX: VMV_V_V_FM2, TSFlagTemplate<InstFormatR>;
class VMV_V_X_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010111;
	bits<1> vm = 0b1;
	bits<5> vs2 = 0b00000;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMV_V_X_AUX: VMV_V_X_FM2, TSFlagTemplate<InstFormatR>;
class VMV_V_I_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010111;
	bits<1> vm = 0b1;
	bits<5> vs2 = 0b00000;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMV_V_I_AUX: VMV_V_I_FM2, TSFlagTemplate<InstFormatR>;
class VFMV_V_F_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010111;
	bits<1> vm = 0b1;
	bits<5> vs2 = 0b00000;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFMV_V_F_AUX: VFMV_V_F_FM2, TSFlagTemplate<InstFormatR>;
class VMV_X_S_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010000;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> vs1 = 0b00000;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMV_X_S_AUX: VMV_X_S_FM2, TSFlagTemplate<InstFormatR>;
class VMV_S_X_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010000;
	bits<1> vm = 0b1;
	bits<5> vs2 = 0b00000;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMV_S_X_AUX: VMV_S_X_FM2, TSFlagTemplate<InstFormatR>;
class VFMV_F_S_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010000;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> vs1 = 0b00000;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFMV_F_S_AUX: VFMV_F_S_FM2, TSFlagTemplate<InstFormatR>;
class VFMV_S_F_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010000;
	bits<1> vm = 0b1;
	bits<5> vs2 = 0b00000;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFMV_S_F_AUX: VFMV_S_F_FM2, TSFlagTemplate<InstFormatR>;
class VMV1R_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100111;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> vs1 = 0b00000;
	bits<3> opv = 0b011;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMV1R_V_AUX: VMV1R_V_FM2, TSFlagTemplate<InstFormatR>;
class VMV2R_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100111;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> vs1 = 0b00001;
	bits<3> opv = 0b011;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMV2R_V_AUX: VMV2R_V_FM2, TSFlagTemplate<InstFormatR>;
class VMV4R_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100111;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> vs1 = 0b00011;
	bits<3> opv = 0b011;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMV4R_V_AUX: VMV4R_V_FM2, TSFlagTemplate<InstFormatR>;
class VMV8R_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100111;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> vs1 = 0b00111;
	bits<3> opv = 0b011;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMV8R_V_AUX: VMV8R_V_FM2, TSFlagTemplate<InstFormatR>;
class VNMSAC_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VNMSAC_VV_AUX: VNMSAC_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VNMSUB_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VNMSUB_VX_AUX: VNMSUB_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VNMSAC_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VNMSAC_VX_AUX: VNMSAC_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VNMSUB_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VNMSUB_VV_AUX: VNMSUB_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMUL_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMUL_VV_AUX: VMUL_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMULHU_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMULHU_VV_AUX: VMULHU_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VWMUL_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWMUL_VV_AUX: VWMUL_VV_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VWMULU_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWMULU_VV_AUX: VWMULU_VV_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VWMULSU_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWMULSU_VV_AUX: VWMULSU_VV_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VSMUL_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSMUL_VV_AUX: VSMUL_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMULH_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMULH_VX_AUX: VMULH_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMULHSU_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMULHSU_VX_AUX: VMULHSU_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMUL_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMUL_VX_AUX: VMUL_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMULHU_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMULHU_VX_AUX: VMULHU_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VWMUL_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWMUL_VX_AUX: VWMUL_VX_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VWMULU_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWMULU_VX_AUX: VWMULU_VX_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VWMULSU_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b111010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWMULSU_VX_AUX: VWMULSU_VX_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VSMUL_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSMUL_VX_AUX: VSMUL_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMULH_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMULH_VV_AUX: VMULH_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMULHSU_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMULHSU_VV_AUX: VMULHSU_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMSOF_M_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b00010;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMSOF_M_AUX: VMSOF_M_FM2, TSFlagTemplate<InstFormatR, Iota>;
class VIOTA_M_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b10000;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VIOTA_M_AUX: VIOTA_M_FM2, TSFlagTemplate<InstFormatR, Iota>;
class VOR_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VOR_VV_AUX: VOR_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VOR_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VOR_VX_AUX: VOR_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VREDOR_VS_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VREDOR_VS_AUX: VREDOR_VS_FM2, TSFlagTemplate<InstFormatR>;
class VMOR_MM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011010;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMOR_MM_AUX: VMOR_MM_FM2, TSFlagTemplate<InstFormatR>;
class VMNOR_MM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011110;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMNOR_MM_AUX: VMNOR_MM_FM2, TSFlagTemplate<InstFormatR>;
class VMORNOT_MM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011100;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMORNOT_MM_AUX: VMORNOT_MM_FM2, TSFlagTemplate<InstFormatR>;
class VOR_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VOR_VI_AUX: VOR_VI_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VPOPC_M_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b10000;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VPOPC_M_AUX: VPOPC_M_FM2, TSFlagTemplate<InstFormatR>;
class VSLIDEUP_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSLIDEUP_VX_AUX: VSLIDEUP_VX_FM2, TSFlagTemplate<InstFormatR, SlideUp>;
class VSLIDEDOWN_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSLIDEDOWN_VX_AUX: VSLIDEDOWN_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSLIDEUP_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSLIDEUP_VI_AUX: VSLIDEUP_VI_FM2, TSFlagTemplate<InstFormatR, SlideUp>;
class VSLIDE1UP_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSLIDE1UP_VX_AUX: VSLIDE1UP_VX_FM2, TSFlagTemplate<InstFormatR, SlideUp>;
class VSLIDEDOWN_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSLIDEDOWN_VI_AUX: VSLIDEDOWN_VI_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFSLIDE1DOWN_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFSLIDE1DOWN_VF_AUX: VFSLIDE1DOWN_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSLIDE1DOWN_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSLIDE1DOWN_VX_AUX: VSLIDE1DOWN_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFSLIDE1UP_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFSLIDE1UP_VF_AUX: VFSLIDE1UP_VF_FM2, TSFlagTemplate<InstFormatR, SlideUp>;
class VSLL_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSLL_VV_AUX: VSLL_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSLL_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSLL_VX_AUX: VSLL_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSLL_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSLL_VI_AUX: VSLL_VI_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VZEXT_VF2_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b00110;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VZEXT_VF2_AUX: VZEXT_VF2_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSEXT_VF2_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b00111;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSEXT_VF2_AUX: VSEXT_VF2_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VZEXT_VF4_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b00100;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VZEXT_VF4_AUX: VZEXT_VF4_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSEXT_VF4_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b00101;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSEXT_VF4_AUX: VSEXT_VF4_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VZEXT_VF8_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b00010;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VZEXT_VF8_AUX: VZEXT_VF8_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSEXT_VF8_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1 = 0b00011;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSEXT_VF8_AUX: VSEXT_VF8_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSRA_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSRA_VV_AUX: VSRA_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VNSRA_WX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VNSRA_WX_AUX: VNSRA_WX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSRA_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSRA_VX_AUX: VSRA_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VNSRA_WV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VNSRA_WV_AUX: VNSRA_WV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSRA_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSRA_VI_AUX: VSRA_VI_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VNSRA_WI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101101;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VNSRA_WI_AUX: VNSRA_WI_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSSRA_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSSRA_VV_AUX: VSSRA_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSSRA_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSSRA_VX_AUX: VSSRA_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSSRA_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSSRA_VI_AUX: VSSRA_VI_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSRL_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSRL_VV_AUX: VSRL_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VNSRL_WX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VNSRL_WX_AUX: VNSRL_WX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSRL_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSRL_VX_AUX: VSRL_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VNSRL_WV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VNSRL_WV_AUX: VNSRL_WV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSRL_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSRL_VI_AUX: VSRL_VI_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VNSRL_WI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101100;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VNSRL_WI_AUX: VNSRL_WI_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSSRL_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSSRL_VV_AUX: VSSRL_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSSRL_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSSRL_VX_AUX: VSSRL_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSSRL_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSSRL_VI_AUX: VSSRL_VI_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSE8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b000;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSE8_V_AUX: VSE8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSE8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b000;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSE8_V_AUX: VSSE8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXEI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b000;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXEI8_V_AUX: VSUXEI8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXEI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b000;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXEI8_V_AUX: VSOXEI8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG2E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b001;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG2E8_V_AUX: VSSEG2E8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG3E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b010;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG3E8_V_AUX: VSSEG3E8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG4E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b011;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG4E8_V_AUX: VSSEG4E8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG5E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b100;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG5E8_V_AUX: VSSEG5E8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG6E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b101;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG6E8_V_AUX: VSSEG6E8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG7E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b110;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG7E8_V_AUX: VSSEG7E8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG8E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b111;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG8E8_V_AUX: VSSEG8E8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG2E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b001;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG2E8_V_AUX: VSSSEG2E8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG3E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b010;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG3E8_V_AUX: VSSSEG3E8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG4E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b011;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG4E8_V_AUX: VSSSEG4E8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG5E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b100;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG5E8_V_AUX: VSSSEG5E8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG6E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b101;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG6E8_V_AUX: VSSSEG6E8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG7E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b110;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG7E8_V_AUX: VSSSEG7E8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG8E8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b111;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG8E8_V_AUX: VSSSEG8E8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG2EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b001;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG2EI8_V_AUX: VSUXSEG2EI8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG3EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b010;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG3EI8_V_AUX: VSUXSEG3EI8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG4EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b011;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG4EI8_V_AUX: VSUXSEG4EI8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG5EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b100;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG5EI8_V_AUX: VSUXSEG5EI8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG6EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b101;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG6EI8_V_AUX: VSUXSEG6EI8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG7EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b110;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG7EI8_V_AUX: VSUXSEG7EI8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG8EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b111;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG8EI8_V_AUX: VSUXSEG8EI8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG2EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b001;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG2EI8_V_AUX: VSOXSEG2EI8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG3EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b010;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG3EI8_V_AUX: VSOXSEG3EI8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG4EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b011;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG4EI8_V_AUX: VSOXSEG4EI8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG5EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b100;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG5EI8_V_AUX: VSOXSEG5EI8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG6EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b101;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG6EI8_V_AUX: VSOXSEG6EI8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG7EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b110;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG7EI8_V_AUX: VSOXSEG7EI8_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG8EI8_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b111;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG8EI8_V_AUX: VSOXSEG8EI8_V_FM2, TSFlagTemplate<InstFormatR>;
class VS1R_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<3> nf = 0b000;
	bits<1> mew = 0b0;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> sumop = 0b01000;
	bits<5> rs1;
	bits<3> width = 0b000;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{31-29} = nf;
	let Inst{28-28} = mew;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{14-12} = width;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VS1R_V_AUX: VS1R_V_FM2, TSFlagTemplate<InstFormatR>;
class VSE1_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0000;
	bits<3> nf = 0b000;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b01011;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSE1_V_AUX: VSE1_V_FM2, TSFlagTemplate<InstFormatR>;
class VSE64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b000;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSE64_V_AUX: VSE64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSE64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b000;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSE64_V_AUX: VSSE64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXEI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b000;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXEI64_V_AUX: VSUXEI64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXEI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b000;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXEI64_V_AUX: VSOXEI64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG2E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b001;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG2E64_V_AUX: VSSEG2E64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG3E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b010;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG3E64_V_AUX: VSSEG3E64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG4E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b011;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG4E64_V_AUX: VSSEG4E64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG5E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b100;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG5E64_V_AUX: VSSEG5E64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG6E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b101;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG6E64_V_AUX: VSSEG6E64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG7E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b110;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG7E64_V_AUX: VSSEG7E64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG8E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b111;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG8E64_V_AUX: VSSEG8E64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG2E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b001;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG2E64_V_AUX: VSSSEG2E64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG3E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b010;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG3E64_V_AUX: VSSSEG3E64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG4E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b011;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG4E64_V_AUX: VSSSEG4E64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG5E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b100;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG5E64_V_AUX: VSSSEG5E64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG6E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b101;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG6E64_V_AUX: VSSSEG6E64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG7E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b110;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG7E64_V_AUX: VSSSEG7E64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG8E64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b111;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG8E64_V_AUX: VSSSEG8E64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG2EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b001;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG2EI64_V_AUX: VSUXSEG2EI64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG3EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b010;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG3EI64_V_AUX: VSUXSEG3EI64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG4EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b011;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG4EI64_V_AUX: VSUXSEG4EI64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG5EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b100;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG5EI64_V_AUX: VSUXSEG5EI64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG6EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b101;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG6EI64_V_AUX: VSUXSEG6EI64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG7EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b110;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG7EI64_V_AUX: VSUXSEG7EI64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG8EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b111;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG8EI64_V_AUX: VSUXSEG8EI64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG2EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b001;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG2EI64_V_AUX: VSOXSEG2EI64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG3EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b010;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG3EI64_V_AUX: VSOXSEG3EI64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG4EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b011;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG4EI64_V_AUX: VSOXSEG4EI64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG5EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b100;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG5EI64_V_AUX: VSOXSEG5EI64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG6EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b101;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG6EI64_V_AUX: VSOXSEG6EI64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG7EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b110;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG7EI64_V_AUX: VSOXSEG7EI64_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG8EI64_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0111;
	bits<3> nf = 0b111;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG8EI64_V_AUX: VSOXSEG8EI64_V_FM2, TSFlagTemplate<InstFormatR>;
class VS8R_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<3> nf = 0b111;
	bits<1> mew = 0b0;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> sumop = 0b01000;
	bits<5> rs1;
	bits<3> width = 0b000;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{31-29} = nf;
	let Inst{28-28} = mew;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{14-12} = width;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VS8R_V_AUX: VS8R_V_FM2, TSFlagTemplate<InstFormatR>;
class VSE16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b000;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSE16_V_AUX: VSE16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSE16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b000;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSE16_V_AUX: VSSE16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXEI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b000;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXEI16_V_AUX: VSUXEI16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXEI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b000;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXEI16_V_AUX: VSOXEI16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG2E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b001;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG2E16_V_AUX: VSSEG2E16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG3E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b010;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG3E16_V_AUX: VSSEG3E16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG4E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b011;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG4E16_V_AUX: VSSEG4E16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG5E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b100;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG5E16_V_AUX: VSSEG5E16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG6E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b101;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG6E16_V_AUX: VSSEG6E16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG7E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b110;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG7E16_V_AUX: VSSEG7E16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG8E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b111;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG8E16_V_AUX: VSSEG8E16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG2E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b001;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG2E16_V_AUX: VSSSEG2E16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG3E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b010;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG3E16_V_AUX: VSSSEG3E16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG4E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b011;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG4E16_V_AUX: VSSSEG4E16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG5E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b100;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG5E16_V_AUX: VSSSEG5E16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG6E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b101;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG6E16_V_AUX: VSSSEG6E16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG7E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b110;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG7E16_V_AUX: VSSSEG7E16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG8E16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b111;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG8E16_V_AUX: VSSSEG8E16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG2EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b001;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG2EI16_V_AUX: VSUXSEG2EI16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG3EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b010;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG3EI16_V_AUX: VSUXSEG3EI16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG4EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b011;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG4EI16_V_AUX: VSUXSEG4EI16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG5EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b100;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG5EI16_V_AUX: VSUXSEG5EI16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG6EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b101;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG6EI16_V_AUX: VSUXSEG6EI16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG7EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b110;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG7EI16_V_AUX: VSUXSEG7EI16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG8EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b111;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG8EI16_V_AUX: VSUXSEG8EI16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG2EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b001;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG2EI16_V_AUX: VSOXSEG2EI16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG3EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b010;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG3EI16_V_AUX: VSOXSEG3EI16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG4EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b011;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG4EI16_V_AUX: VSOXSEG4EI16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG5EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b100;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG5EI16_V_AUX: VSOXSEG5EI16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG6EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b101;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG6EI16_V_AUX: VSOXSEG6EI16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG7EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b110;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG7EI16_V_AUX: VSOXSEG7EI16_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG8EI16_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0101;
	bits<3> nf = 0b111;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG8EI16_V_AUX: VSOXSEG8EI16_V_FM2, TSFlagTemplate<InstFormatR>;
class VS2R_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<3> nf = 0b001;
	bits<1> mew = 0b0;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> sumop = 0b01000;
	bits<5> rs1;
	bits<3> width = 0b000;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{31-29} = nf;
	let Inst{28-28} = mew;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{14-12} = width;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VS2R_V_AUX: VS2R_V_FM2, TSFlagTemplate<InstFormatR>;
class VSE32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b000;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSE32_V_AUX: VSE32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSE32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b000;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSE32_V_AUX: VSSE32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXEI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b000;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXEI32_V_AUX: VSUXEI32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXEI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b000;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXEI32_V_AUX: VSOXEI32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG2E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b001;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG2E32_V_AUX: VSSEG2E32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG3E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b010;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG3E32_V_AUX: VSSEG3E32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG4E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b011;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG4E32_V_AUX: VSSEG4E32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG5E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b100;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG5E32_V_AUX: VSSEG5E32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG6E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b101;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG6E32_V_AUX: VSSEG6E32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG7E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b110;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG7E32_V_AUX: VSSEG7E32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSEG8E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b111;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm;
	bits<5> sumop = 0b00000;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSEG8E32_V_AUX: VSSEG8E32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG2E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b001;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG2E32_V_AUX: VSSSEG2E32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG3E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b010;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG3E32_V_AUX: VSSSEG3E32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG4E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b011;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG4E32_V_AUX: VSSSEG4E32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG5E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b100;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG5E32_V_AUX: VSSSEG5E32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG6E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b101;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG6E32_V_AUX: VSSSEG6E32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG7E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b110;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG7E32_V_AUX: VSSSEG7E32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSSEG8E32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b111;
	bits<2> MOPSTStrided = 0b10;
	bits<1> vm;
	bits<5> rs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = MOPSTStrided;
	let Inst{25-25} = vm;
	let Inst{24-20} = rs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSSSEG8E32_V_AUX: VSSSEG8E32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG2EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b001;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG2EI32_V_AUX: VSUXSEG2EI32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG3EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b010;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG3EI32_V_AUX: VSUXSEG3EI32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG4EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b011;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG4EI32_V_AUX: VSUXSEG4EI32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG5EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b100;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG5EI32_V_AUX: VSUXSEG5EI32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG6EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b101;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG6EI32_V_AUX: VSUXSEG6EI32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG7EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b110;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG7EI32_V_AUX: VSUXSEG7EI32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSUXSEG8EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b111;
	bits<2> mop = 0b01;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSUXSEG8EI32_V_AUX: VSUXSEG8EI32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG2EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b001;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG2EI32_V_AUX: VSOXSEG2EI32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG3EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b010;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG3EI32_V_AUX: VSOXSEG3EI32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG4EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b011;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG4EI32_V_AUX: VSOXSEG4EI32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG5EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b100;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG5EI32_V_AUX: VSOXSEG5EI32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG6EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b101;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG6EI32_V_AUX: VSOXSEG6EI32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG7EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b110;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG7EI32_V_AUX: VSOXSEG7EI32_V_FM2, TSFlagTemplate<InstFormatR>;
class VSOXSEG8EI32_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<4> width = 0b0110;
	bits<3> nf = 0b111;
	bits<2> mop = 0b11;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{28-28} = width{3-3};
	let Inst{14-12} = width{2-0};
	let Inst{31-29} = nf;
	let Inst{27-26} = mop;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VSOXSEG8EI32_V_AUX: VSOXSEG8EI32_V_FM2, TSFlagTemplate<InstFormatR>;
class VS4R_V_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<3> nf = 0b011;
	bits<1> mew = 0b0;
	bits<2> MOPSTUnitStride = 0b00;
	bits<1> vm = 0b1;
	bits<5> sumop = 0b01000;
	bits<5> rs1;
	bits<3> width = 0b000;
	bits<5> vs3;
	bits<7> opcode = 0b0100111;
	let Inst{31-29} = nf;
	let Inst{28-28} = mew;
	let Inst{27-26} = MOPSTUnitStride;
	let Inst{25-25} = vm;
	let Inst{24-20} = sumop;
	let Inst{19-15} = rs1;
	let Inst{14-12} = width;
	let Inst{11-7} = vs3;
	let Inst{6-0} = opcode;
}
class VS4R_V_AUX: VS4R_V_FM2, TSFlagTemplate<InstFormatR>;
class VSSUBU_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSSUBU_VV_AUX: VSSUBU_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSSUBU_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSSUBU_VX_AUX: VSSUBU_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSUB_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSUB_VV_AUX: VSUB_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VWSUB_WV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWSUB_WV_AUX: VWSUB_WV_FM2, TSFlagTemplate<InstFormatR, WidenW>;
class VWSUB_WX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWSUB_WX_AUX: VWSUB_WX_FM2, TSFlagTemplate<InstFormatR, WidenW>;
class VWSUB_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWSUB_VV_AUX: VWSUB_VV_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VSUB_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSUB_VX_AUX: VSUB_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VWSUB_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b110;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWSUB_VX_AUX: VWSUB_VX_FM2, TSFlagTemplate<InstFormatR, WidenV>;
class VSSUB_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSSUB_VV_AUX: VSSUB_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VSSUB_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b100011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VSSUB_VX_AUX: VSSUB_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VRSUB_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VRSUB_VI_AUX: VRSUB_VI_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VXOR_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VXOR_VV_AUX: VXOR_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VXOR_VX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VXOR_VX_AUX: VXOR_VX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VREDXOR_VS_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VREDXOR_VS_AUX: VREDXOR_VS_FM2, TSFlagTemplate<InstFormatR>;
class VMXOR_MM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011011;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMXOR_MM_AUX: VMXOR_MM_FM2, TSFlagTemplate<InstFormatR>;
class VMXNOR_MM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b011111;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMXNOR_MM_AUX: VMXNOR_MM_FM2, TSFlagTemplate<InstFormatR>;
class VXOR_VI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VXOR_VI_AUX: VXOR_VI_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMERGE_VVM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010111;
	bits<1> vm = 0b0;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMERGE_VVM_AUX: VMERGE_VVM_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMERGE_VXM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010111;
	bits<1> vm = 0b0;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMERGE_VXM_AUX: VMERGE_VXM_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VMERGE_VIM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010111;
	bits<1> vm = 0b0;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VMERGE_VIM_AUX: VMERGE_VIM_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VNCLIPU_WV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VNCLIPU_WV_AUX: VNCLIPU_WV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VNCLIPU_WX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VNCLIPU_WX_AUX: VNCLIPU_WX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VNCLIPU_WI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101110;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VNCLIPU_WI_AUX: VNCLIPU_WI_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VNCLIP_WV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VNCLIP_WV_AUX: VNCLIP_WV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VNCLIP_WX_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b100;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VNCLIP_WX_AUX: VNCLIP_WX_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VNCLIP_WI_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b101111;
	bits<1> vm;
	bits<5> vs2;
	bits<5> imm;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = imm;
	let Inst{14-12} = 0b011;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VNCLIP_WI_AUX: VNCLIP_WI_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFSGNJ_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFSGNJ_VV_AUX: VFSGNJ_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFSGNJ_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFSGNJ_VF_AUX: VFSGNJ_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFSGNJN_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFSGNJN_VV_AUX: VFSGNJN_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFSGNJN_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFSGNJN_VF_AUX: VFSGNJN_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFSGNJX_VV_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFSGNJX_VV_AUX: VFSGNJX_VV_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFSGNJX_VF_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b001010;
	bits<1> vm;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFSGNJX_VF_AUX: VFSGNJX_VF_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VFMERGE_VFM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010111;
	bits<1> vm = 0b0;
	bits<5> vs2;
	bits<5> rs1;
	bits<3> opv = 0b101;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = rs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFMERGE_VFM_AUX: VFMERGE_VFM_FM2, TSFlagTemplate<InstFormatR, VMConstraint>;
class VREDSUM_VS_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VREDSUM_VS_AUX: VREDSUM_VS_FM2, TSFlagTemplate<InstFormatR>;
class VWREDSUMU_VS_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110000;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWREDSUMU_VS_AUX: VWREDSUMU_VS_FM2, TSFlagTemplate<InstFormatR>;
class VWREDSUM_VS_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b000;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VWREDSUM_VS_AUX: VWREDSUM_VS_FM2, TSFlagTemplate<InstFormatR>;
class VFREDSUM_VS_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFREDSUM_VS_AUX: VFREDSUM_VS_FM2, TSFlagTemplate<InstFormatR>;
class VFWREDSUM_VS_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110001;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VFWREDSUM_VS_AUX: VFWREDSUM_VS_FM2, TSFlagTemplate<InstFormatR>;
class VCOMPRESS_VM_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b010111;
	bits<1> vm = 0b1;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b010;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
class VCOMPRESS_VM_AUX: VCOMPRESS_VM_FM2, TSFlagTemplate<InstFormatR, Vcompress>;
class VFREDOSUM_VS_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b000011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
def VFREDOSUM_VS: Instruction, VFREDOSUM_VS_FM2, TSFlagTemplate<InstFormatR>{
	let Size = 4;
	let AsmString = "vfredosum.vs	$vd, $vs2, $vs1$vm";
	let Namespace = "RISCV";
	let mayLoad = 0;
	let InOperandList = (ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	let OutOperandList = (outs VR:$vd);
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "";
	let Defs = [];
	let Uses = [VTYPE, VL];
	let DecoderNamespace = "";
	let Pattern = [];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class VFWREDOSUM_VS_FM2: ATGInst{
	bits<32> SoftFail=0;
	bits<32> Inst;
	bits<6> funct6 = 0b110011;
	bits<1> vm;
	bits<5> vs2;
	bits<5> vs1;
	bits<3> opv = 0b001;
	bits<5> vd;
	bits<7> opcode = 0b1010111;
	let Inst{31-26} = funct6;
	let Inst{25-25} = vm;
	let Inst{24-20} = vs2;
	let Inst{19-15} = vs1;
	let Inst{14-12} = opv;
	let Inst{11-7} = vd;
	let Inst{6-0} = opcode;
}
def VFWREDOSUM_VS: Instruction, VFWREDOSUM_VS_FM2, TSFlagTemplate<InstFormatR>{
	let Size = 4;
	let AsmString = "vfwredosum.vs	$vd, $vs2, $vs1$vm";
	let Namespace = "RISCV";
	let mayLoad = 0;
	let InOperandList = (ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	let OutOperandList = (outs VR:$vd);
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Defs = [];
	let Uses = [VTYPE, VL];
	let DecoderNamespace = "";
	let Pattern = [];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VWADDU_VV;
class MipsInst_VWADDU_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWADDU_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWADDU_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWADDU_VV : MipsInst_VWADDU_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWADDU_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VWADDU_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWADDU_VV ;
class MSA_3R_DESC_BASE_VWADDU_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vwaddu.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VWADDU_VV{
	bit  isCommutable=false;
}
class ADDV_D_ENC_VWADDU_VV : MSA_3R_FMT_VWADDU_VV <0b000, 0b11, 0b001110>;
class ADDV_D_DESC_VWADDU_VV : MSA_3R_DESC_BASE_VWADDU_VV <"addv.d", null_frag, ?>, IsCommutable_VWADDU_VV ;
def VWADDU_VV : ADDV_D_ENC_VWADDU_VV , ADDV_D_DESC_VWADDU_VV , VWADDU_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMADC_VI;
class MipsInst_VMADC_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMADC_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMADC_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMADC_VI : MipsInst_VMADC_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMADC_VI {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMADC_VI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, simm5:$imm);
	string  AsmString="vmadc.vi	$vd, $vs2, $imm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VMADC_VI<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMADC_VI ;
class ASUB_S_W_DESC_VMADC_VI : MSA_3R_DESC_BASE_VMADC_VI <"asub_s.w", null_frag, ?>;
class ASUB_S_W_ENC_VMADC_VI : MSA_3R_FMT_VMADC_VI <0b100, 0b10, 0b010001>;
def VMADC_VI : ASUB_S_W_ENC_VMADC_VI , ASUB_S_W_DESC_VMADC_VI , VMADC_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWADDU_VX;
class MipsInst_VWADDU_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWADDU_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWADDU_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWADDU_VX : MipsInst_VWADDU_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWADDU_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_4R_DESC_BASE_VWADDU_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vwaddu.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="@earlyclobber $vd";
}
class MSA_3R_FMT_VWADDU_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWADDU_VX ;
class MSUBV_D_DESC_VWADDU_VX : MSA_3R_4R_DESC_BASE_VWADDU_VX <"msubv.d", null_frag, ?>;
class MSUBV_D_ENC_VWADDU_VX : MSA_3R_FMT_VWADDU_VX <0b010, 0b11, 0b010010>;
def VWADDU_VX : MSUBV_D_ENC_VWADDU_VX , MSUBV_D_DESC_VWADDU_VX , VWADDU_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWADDU_WX;
class MipsInst_VWADDU_WX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWADDU_WX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWADDU_WX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWADDU_WX : MipsInst_VWADDU_WX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWADDU_WX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VWADDU_WX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWADDU_WX ;
class MSA_3R_4R_DESC_BASE_VWADDU_WX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vwaddu.wx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="@earlyclobber $vd";
}
class MADDV_D_ENC_VWADDU_WX : MSA_3R_FMT_VWADDU_WX <0b001, 0b11, 0b010010>;
class MADDV_D_DESC_VWADDU_WX : MSA_3R_4R_DESC_BASE_VWADDU_WX <"maddv.d", null_frag, ?>;
def VWADDU_WX : MADDV_D_ENC_VWADDU_WX , MADDV_D_DESC_VWADDU_WX , VWADDU_WX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWADDU_WV;
class MipsInst_VWADDU_WV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWADDU_WV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWADDU_WV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWADDU_WV : MipsInst_VWADDU_WV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWADDU_WV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VWADDU_WV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWADDU_WV ;
class MSA_3R_DESC_BASE_VWADDU_WV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vwaddu.wv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VWADDU_WV{
	bit  isCommutable=false;
}
class ADDV_D_ENC_VWADDU_WV : MSA_3R_FMT_VWADDU_WV <0b000, 0b11, 0b001110>;
class ADDV_D_DESC_VWADDU_WV : MSA_3R_DESC_BASE_VWADDU_WV <"addv.d", null_frag, ?>, IsCommutable_VWADDU_WV ;
def VWADDU_WV : ADDV_D_ENC_VWADDU_WV , ADDV_D_DESC_VWADDU_WV , VWADDU_WV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSADD_VV;
class MipsInst_VSADD_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSADD_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSADD_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSADD_VV : MipsInst_VSADD_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSADD_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VSADD_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vsadd.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VSADD_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSADD_VV ;
class ASUB_S_W_DESC_VSADD_VV : MSA_3R_DESC_BASE_VSADD_VV <"asub_s.w", null_frag, ?>;
class ASUB_S_W_ENC_VSADD_VV : MSA_3R_FMT_VSADD_VV <0b100, 0b10, 0b010001>;
def VSADD_VV : ASUB_S_W_ENC_VSADD_VV , ASUB_S_W_DESC_VSADD_VV , VSADD_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSADD_VX;
class MipsInst_VSADD_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSADD_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSADD_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSADD_VX : MipsInst_VSADD_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSADD_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VSADD_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsadd.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VSADD_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSADD_VX ;
class ASUB_S_W_DESC_VSADD_VX : MSA_3R_DESC_BASE_VSADD_VX <"asub_s.w", null_frag, ?>;
class ASUB_S_W_ENC_VSADD_VX : MSA_3R_FMT_VSADD_VX <0b100, 0b10, 0b010001>;
def VSADD_VX : ASUB_S_W_ENC_VSADD_VX , ASUB_S_W_DESC_VSADD_VX , VSADD_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSADD_VI;
class MipsInst_VSADD_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSADD_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSADD_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSADD_VI : MipsInst_VSADD_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSADD_VI {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VSADD_VI<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSADD_VI ;
class MSA_3R_DESC_BASE_VSADD_VI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, simm5:$imm, VMaskOp:$vm);
	string  AsmString="vsadd.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VSADD_VI{
	bit  isCommutable=false;
}
class AVER_U_W_ENC_VSADD_VI : MSA_3R_FMT_VSADD_VI <0b111, 0b10, 0b010000>;
class AVER_U_W_DESC_VSADD_VI : MSA_3R_DESC_BASE_VSADD_VI <"aver_u.w", null_frag, ?>, IsCommutable_VSADD_VI ;
def VSADD_VI : AVER_U_W_ENC_VSADD_VI , AVER_U_W_DESC_VSADD_VI , VSADD_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSADDU_VV;
class MipsInst_VSADDU_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSADDU_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSADDU_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSADDU_VV : MipsInst_VSADDU_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSADDU_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VSADDU_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vsaddu.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VSADDU_VV{
	bit  isCommutable=false;
}
class MSA_3R_FMT_VSADDU_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSADDU_VV ;
class DOTP_U_W_DESC_VSADDU_VV : MSA_3R_DESC_BASE_VSADDU_VV <"dotp_u.w", null_frag, ?, ?, ?>, IsCommutable_VSADDU_VV ;
class DOTP_U_W_ENC_VSADDU_VV : MSA_3R_FMT_VSADDU_VV <0b001, 0b10, 0b010011>;
def VSADDU_VV : DOTP_U_W_ENC_VSADDU_VV , DOTP_U_W_DESC_VSADDU_VV , VSADDU_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VAADDU_VV;
class MipsInst_VAADDU_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VAADDU_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VAADDU_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VAADDU_VV : MipsInst_VAADDU_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VAADDU_VV {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VAADDU_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vaaddu.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VAADDU_VV<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VAADDU_VV ;
class FSQRT_W_DESC_VAADDU_VV : MSA_2RF_DESC_BASE_VAADDU_VV <"fsqrt.w", null_frag, ?>;
class FSQRT_W_ENC_VAADDU_VV : MSA_2RF_FMT_VAADDU_VV <0b110010011, 0b0, 0b011110>;
def VAADDU_VV : FSQRT_W_ENC_VAADDU_VV , FSQRT_W_DESC_VAADDU_VV , VAADDU_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSADDU_VX;
class MipsInst_VSADDU_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSADDU_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSADDU_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSADDU_VX : MipsInst_VSADDU_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSADDU_VX {
	let  EncodingPredicates=[];
}
class MSA_BIT_X_DESC_BASE_VSADDU_VX<string  instr_asm, SDPatternOperator  OpNode, Operand  ImmOp, ImmLeaf  Imm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsaddu.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_BIT_W_FMT_VSADDU_VX<bits<3>  major, bits<6>  minor> : MSAInst_VSADDU_VX ;
class SAT_S_W_DESC_VSADDU_VX : MSA_BIT_X_DESC_BASE_VSADDU_VX <"sat_s.w", null_frag, ?, ?, ?>;
class SAT_S_W_ENC_VSADDU_VX : MSA_BIT_W_FMT_VSADDU_VX <0b000, 0b001010>;
def VSADDU_VX : SAT_S_W_ENC_VSADDU_VX , SAT_S_W_DESC_VSADDU_VX , VSADDU_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VAADDU_VX;
class MipsInst_VAADDU_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VAADDU_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VAADDU_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VAADDU_VX : MipsInst_VAADDU_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VAADDU_VX {
	let  EncodingPredicates=[];
}
class MSA_BIT_X_DESC_BASE_VAADDU_VX<string  instr_asm, SDPatternOperator  OpNode, Operand  ImmOp, ImmLeaf  Imm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vaaddu.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_BIT_W_FMT_VAADDU_VX<bits<3>  major, bits<6>  minor> : MSAInst_VAADDU_VX ;
class SAT_S_W_DESC_VAADDU_VX : MSA_BIT_X_DESC_BASE_VAADDU_VX <"sat_s.w", null_frag, ?, ?, ?>;
class SAT_S_W_ENC_VAADDU_VX : MSA_BIT_W_FMT_VAADDU_VX <0b000, 0b001010>;
def VAADDU_VX : SAT_S_W_ENC_VAADDU_VX , SAT_S_W_DESC_VAADDU_VX , VAADDU_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSADDU_VI;
class MipsInst_VSADDU_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSADDU_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSADDU_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VSADDU_VI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, simm5:$imm, VMaskOp:$vm);
	string  AsmString="vsaddu.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VSADDU_VI : MipsInst_VSADDU_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSADDU_VI {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VSADDU_VI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VSADDU_VI <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VSADDU_VI<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VSADDU_VI ;
class MULR_Q_W_DESC_VSADDU_VI : MSA_3RF_DESC_BASE_VSADDU_VI <"mulr_q.w", null_frag, ?>;
class MULR_Q_W_ENC_VSADDU_VI : MSA_3RF_FMT_VSADDU_VI <0b1100, 0b1, 0b011100>;
def VSADDU_VI : MULR_Q_W_ENC_VSADDU_VI , MULR_Q_W_DESC_VSADDU_VI , VSADDU_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VADD_VV;
class MipsInst_VADD_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VADD_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VADD_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VADD_VV : MipsInst_VADD_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VADD_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VADD_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VADD_VV ;
class MSA_3R_DESC_BASE_VADD_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vadd.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MOD_U_W_ENC_VADD_VV : MSA_3R_FMT_VADD_VV <0b111, 0b10, 0b010010>;
class MOD_U_W_DESC_VADD_VV : MSA_3R_DESC_BASE_VADD_VV <"mod_u.w", null_frag, ?>;
def VADD_VV : MOD_U_W_ENC_VADD_VV , MOD_U_W_DESC_VADD_VV , VADD_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VADD_VX;
class MipsInst_VADD_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VADD_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VADD_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VADD_VX : MipsInst_VADD_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VADD_VX {
	let  EncodingPredicates=[];
}
class MSA_BIT_X_DESC_BASE_VADD_VX<string  instr_asm, SDPatternOperator  OpNode, Operand  ImmOp, ImmLeaf  Imm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vadd.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_BIT_W_FMT_VADD_VX<bits<3>  major, bits<6>  minor> : MSAInst_VADD_VX ;
class SAT_S_W_DESC_VADD_VX : MSA_BIT_X_DESC_BASE_VADD_VX <"sat_s.w", null_frag, ?, ?, ?>;
class SAT_S_W_ENC_VADD_VX : MSA_BIT_W_FMT_VADD_VX <0b000, 0b001010>;
def VADD_VX : SAT_S_W_ENC_VADD_VX , SAT_S_W_DESC_VADD_VX , VADD_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWADD_VV;
class MipsInst_VWADD_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWADD_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWADD_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWADD_VV : MipsInst_VWADD_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWADD_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VWADD_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWADD_VV ;
class MSA_3R_4R_DESC_BASE_VWADD_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vwadd.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="@earlyclobber $vd";
}
class DPSUB_U_D_ENC_VWADD_VV : MSA_3R_FMT_VWADD_VV <0b101, 0b11, 0b010011>;
class DPSUB_U_D_DESC_VWADD_VV : MSA_3R_4R_DESC_BASE_VWADD_VV <"dpsub_u.d", null_frag, ?, ?, ?>;
def VWADD_VV : DPSUB_U_D_ENC_VWADD_VV , DPSUB_U_D_DESC_VWADD_VV , VWADD_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWADD_VX;
class MipsInst_VWADD_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWADD_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWADD_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWADD_VX : MipsInst_VWADD_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWADD_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VWADD_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWADD_VX ;
class MSA_3R_DESC_BASE_VWADD_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vwadd.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MULV_D_ENC_VWADD_VX : MSA_3R_FMT_VWADD_VX <0b000, 0b11, 0b010010>;
class MULV_D_DESC_VWADD_VX : MSA_3R_DESC_BASE_VWADD_VX <"mulv.d", null_frag, ?>;
def VWADD_VX : MULV_D_ENC_VWADD_VX , MULV_D_DESC_VWADD_VX , VWADD_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWADD_WV;
class MipsInst_VWADD_WV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWADD_WV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWADD_WV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWADD_WV : MipsInst_VWADD_WV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWADD_WV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VWADD_WV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWADD_WV ;
class MSA_3R_4R_DESC_BASE_VWADD_WV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vwadd.wv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="@earlyclobber $vd";
}
class DPSUB_U_D_ENC_VWADD_WV : MSA_3R_FMT_VWADD_WV <0b101, 0b11, 0b010011>;
class DPSUB_U_D_DESC_VWADD_WV : MSA_3R_4R_DESC_BASE_VWADD_WV <"dpsub_u.d", null_frag, ?, ?, ?>;
def VWADD_WV : DPSUB_U_D_ENC_VWADD_WV , DPSUB_U_D_DESC_VWADD_WV , VWADD_WV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWADD_WX;
class MipsInst_VWADD_WX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWADD_WX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWADD_WX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWADD_WX : MipsInst_VWADD_WX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWADD_WX {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VWADD_WX<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VWADD_WX ;
class MSA_2RF_DESC_BASE_VWADD_WX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vwadd.wx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FSQRT_D_ENC_VWADD_WX : MSA_2RF_FMT_VWADD_WX <0b110010011, 0b1, 0b011110>;
class FSQRT_D_DESC_VWADD_WX : MSA_2RF_DESC_BASE_VWADD_WX <"fsqrt.d", null_frag, ?>;
def VWADD_WX : FSQRT_D_ENC_VWADD_WX , FSQRT_D_DESC_VWADD_WX , VWADD_WX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VADC_VVM;
class MipsInst_VADC_VVM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VADC_VVM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VADC_VVM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_4R_DESC_BASE_VADC_VVM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMV0:$v0);
	string  AsmString="vadc.vvm	$vd, $vs2, $vs1, v0";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="";
}
class MSAInst_VADC_VVM : MipsInst_VADC_VVM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VADC_VVM {
	let  EncodingPredicates=[];
}
class MSA_3RF_4RF_DESC_BASE_VADC_VVM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_4R_DESC_BASE_VADC_VVM <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VADC_VVM<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VADC_VVM ;
class MSUB_Q_W_DESC_VADC_VVM : MSA_3RF_4RF_DESC_BASE_VADC_VVM <"msub_q.w", null_frag, ?>;
class MSUB_Q_W_ENC_VADC_VVM : MSA_3RF_FMT_VADC_VVM <0b0110, 0b1, 0b011100>;
def VADC_VVM : MSUB_Q_W_ENC_VADC_VVM , MSUB_Q_W_DESC_VADC_VVM , VADC_VVM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VADC_VXM;
class MipsInst_VADC_VXM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VADC_VXM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VADC_VXM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VADC_VXM : MipsInst_VADC_VXM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VADC_VXM {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VADC_VXM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMV0:$v0);
	string  AsmString="vadc.vxm	$vd, $vs2, $rs1, v0";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VADC_VXM<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VADC_VXM ;
class FSQRT_W_DESC_VADC_VXM : MSA_2RF_DESC_BASE_VADC_VXM <"fsqrt.w", null_frag, ?>;
class FSQRT_W_ENC_VADC_VXM : MSA_2RF_FMT_VADC_VXM <0b110010011, 0b0, 0b011110>;
def VADC_VXM : FSQRT_W_ENC_VADC_VXM , FSQRT_W_DESC_VADC_VXM , VADC_VXM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VADC_VIM;
class MipsInst_VADC_VIM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VADC_VIM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VADC_VIM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VADC_VIM : MipsInst_VADC_VIM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VADC_VIM {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VADC_VIM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, simm5:$imm, VMV0:$v0);
	string  AsmString="vadc.vim	$vd, $vs2, $imm, v0";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VADC_VIM<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VADC_VIM ;
class SUBSUU_S_W_DESC_VADC_VIM : MSA_3R_DESC_BASE_VADC_VIM <"subsuu_s.w", null_frag, ?>;
class SUBSUU_S_W_ENC_VADC_VIM : MSA_3R_FMT_VADC_VIM <0b011, 0b10, 0b010001>;
def VADC_VIM : SUBSUU_S_W_ENC_VADC_VIM , SUBSUU_S_W_DESC_VADC_VIM , VADC_VIM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VAADD_VV;
class MipsInst_VAADD_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VAADD_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VAADD_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VAADD_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vaadd.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VAADD_VV : MipsInst_VAADD_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VAADD_VV {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VAADD_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VAADD_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VAADD_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VAADD_VV ;
class MULR_Q_W_DESC_VAADD_VV : MSA_3RF_DESC_BASE_VAADD_VV <"mulr_q.w", null_frag, ?>;
class MULR_Q_W_ENC_VAADD_VV : MSA_3RF_FMT_VAADD_VV <0b1100, 0b1, 0b011100>;
def VAADD_VV : MULR_Q_W_ENC_VAADD_VV , MULR_Q_W_DESC_VAADD_VV , VAADD_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VAADD_VX;
class MipsInst_VAADD_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VAADD_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VAADD_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VAADD_VX : MipsInst_VAADD_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VAADD_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VAADD_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VAADD_VX ;
class MSA_3R_DESC_BASE_VAADD_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vaadd.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VAADD_VX{
	bit  isCommutable=false;
}
class ADDV_W_ENC_VAADD_VX : MSA_3R_FMT_VAADD_VX <0b000, 0b10, 0b001110>;
class ADDV_W_DESC_VAADD_VX : MSA_3R_DESC_BASE_VAADD_VX <"addv.w", null_frag, ?>, IsCommutable_VAADD_VX ;
def VAADD_VX : ADDV_W_ENC_VAADD_VX , ADDV_W_DESC_VAADD_VX , VAADD_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VADD_VI;
class MipsInst_VADD_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VADD_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VADD_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VADD_VI : MipsInst_VADD_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VADD_VI {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VADD_VI<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VADD_VI ;
class MSA_3R_DESC_BASE_VADD_VI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, simm5:$imm, VMaskOp:$vm);
	string  AsmString="vadd.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VADD_VI{
	bit  isCommutable=false;
}
class ADDV_W_ENC_VADD_VI : MSA_3R_FMT_VADD_VI <0b000, 0b10, 0b001110>;
class ADDV_W_DESC_VADD_VI : MSA_3R_DESC_BASE_VADD_VI <"addv.w", null_frag, ?>, IsCommutable_VADD_VI ;
def VADD_VI : ADDV_W_ENC_VADD_VI , ADDV_W_DESC_VADD_VI , VADD_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VAND_VV;
class MipsInst_VAND_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VAND_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VAND_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VAND_VV : MipsInst_VAND_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VAND_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VAND_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vand.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VAND_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VAND_VV ;
class BSET_W_DESC_VAND_VV : MSA_3R_DESC_BASE_VAND_VV <"bset.w", null_frag, ?>;
class BSET_W_ENC_VAND_VV : MSA_3R_FMT_VAND_VV <0b100, 0b10, 0b001101>;
def VAND_VV : BSET_W_ENC_VAND_VV , BSET_W_DESC_VAND_VV , VAND_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VAND_VX;
class MipsInst_VAND_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VAND_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VAND_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VAND_VX : MipsInst_VAND_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VAND_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VAND_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vand.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VAND_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VAND_VX ;
class BSET_W_DESC_VAND_VX : MSA_3R_DESC_BASE_VAND_VX <"bset.w", null_frag, ?>;
class BSET_W_ENC_VAND_VX : MSA_3R_FMT_VAND_VX <0b100, 0b10, 0b001101>;
def VAND_VX : BSET_W_ENC_VAND_VX , BSET_W_DESC_VAND_VX , VAND_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VREDAND_VS;
class MipsInst_VREDAND_VS<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VREDAND_VS {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VREDAND_VS{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VREDAND_VS : MipsInst_VREDAND_VS <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VREDAND_VS {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VREDAND_VS<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vredand.vs	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VREDAND_VS<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VREDAND_VS ;
class LDI_W_DESC_VREDAND_VS : MSA_I10_LDI_DESC_BASE_VREDAND_VS <"ldi.w", ?>;
class LDI_W_ENC_VREDAND_VS : MSA_I10_FMT_VREDAND_VS <0b110, 0b10, 0b000111>;
def VREDAND_VS : LDI_W_ENC_VREDAND_VS , LDI_W_DESC_VREDAND_VS , VREDAND_VS_AUX {
	  	let mayLoad = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMAND_MM;
class MipsInst_VMAND_MM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMAND_MM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMAND_MM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMAND_MM : MipsInst_VMAND_MM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMAND_MM {
	let  EncodingPredicates=[];
}
class MSA_VEC_FMT_VMAND_MM<bits<5>  major, bits<6>  minor> : MSAInst_VMAND_MM ;
class BSEL_V_DESC_VMAND_MM{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1);
	string  AsmString="vmand.mm	$vd, $vs2, $vs1";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=NoItinerary;
	string  Constraints="";
}
class BSEL_V_ENC_VMAND_MM : MSA_VEC_FMT_VMAND_MM <0b00110, 0b011110>;
def VMAND_MM : BSEL_V_ENC_VMAND_MM , BSEL_V_DESC_VMAND_MM , VMAND_MM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMNAND_MM;
class MipsInst_VMNAND_MM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMNAND_MM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMNAND_MM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMNAND_MM : MipsInst_VMNAND_MM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMNAND_MM {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VMNAND_MM<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMNAND_MM ;
class MSA_3R_DESC_BASE_VMNAND_MM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1);
	string  AsmString="vmnand.mm	$vd, $vs2, $vs1";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class BCLR_W_ENC_VMNAND_MM : MSA_3R_FMT_VMNAND_MM <0b011, 0b10, 0b001101>;
class BCLR_W_DESC_VMNAND_MM : MSA_3R_DESC_BASE_VMNAND_MM <"bclr.w", null_frag, ?>;
def VMNAND_MM : BCLR_W_ENC_VMNAND_MM , BCLR_W_DESC_VMNAND_MM , VMNAND_MM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMANDNOT_MM;
class MipsInst_VMANDNOT_MM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMANDNOT_MM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMANDNOT_MM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMANDNOT_MM : MipsInst_VMANDNOT_MM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMANDNOT_MM {
	let  EncodingPredicates=[];
}
class MSA_I8_FMT_VMANDNOT_MM<bits<2>  major, bits<6>  minor> : MSAInst_VMANDNOT_MM ;
class BSELI_B_DESC_VMANDNOT_MM{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1);
	string  AsmString="vmandnot.mm	$vd, $vs2, $vs1";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=NoItinerary;
	string  Constraints="";
}
class BSELI_B_ENC_VMANDNOT_MM : MSA_I8_FMT_VMANDNOT_MM <0b10, 0b000001>;
def VMANDNOT_MM : BSELI_B_ENC_VMANDNOT_MM , BSELI_B_DESC_VMANDNOT_MM , VMANDNOT_MM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VID_V;
class MipsInst_VID_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VID_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VID_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VID_V : MipsInst_VID_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VID_V {
	let  EncodingPredicates=[];
}
class MSA_2R_FMT_VID_V<bits<8>  major, bits<2>  df, bits<6>  minor> : MSAInst_VID_V ;
class MSA_2R_DESC_BASE_VID_V<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VMaskOp:$vm);
	string  AsmString="vid.v	$vd$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class NLOC_W_ENC_VID_V : MSA_2R_FMT_VID_V <0b11000010, 0b10, 0b011110>;
class NLOC_W_DESC_VID_V : MSA_2R_DESC_BASE_VID_V <"nloc.w", null_frag, ?>;
def VID_V : NLOC_W_ENC_VID_V , NLOC_W_DESC_VID_V , VID_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VAND_VI;
class MipsInst_VAND_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VAND_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VAND_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VAND_VI : MipsInst_VAND_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VAND_VI {
	let  EncodingPredicates=[];
}
class MSA_I8_FMT_VAND_VI<bits<2>  major, bits<6>  minor> : MSAInst_VAND_VI ;
class BSELI_B_DESC_VAND_VI{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, simm5:$imm, VMaskOp:$vm);
	string  AsmString="vand.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=NoItinerary;
	string  Constraints="";
}
class BSELI_B_ENC_VAND_VI : MSA_I8_FMT_VAND_VI <0b10, 0b000001>;
def VAND_VI : BSELI_B_ENC_VAND_VI , BSELI_B_DESC_VAND_VI , VAND_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VRSUB_VX;
class MipsInst_VRSUB_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VRSUB_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VRSUB_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VRSUB_VX : MipsInst_VRSUB_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VRSUB_VX {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VRSUB_VX<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VRSUB_VX ;
class MSA_2RF_DESC_BASE_VRSUB_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vrsub.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FRCP_W_ENC_VRSUB_VX : MSA_2RF_FMT_VRSUB_VX <0b110010101, 0b0, 0b011110>;
class FRCP_W_DESC_VRSUB_VX : MSA_2RF_DESC_BASE_VRSUB_VX <"frcp.w", null_frag, ?>;
def VRSUB_VX : FRCP_W_ENC_VRSUB_VX , FRCP_W_DESC_VRSUB_VX , VRSUB_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSBC_VVM;
class MipsInst_VMSBC_VVM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSBC_VVM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSBC_VVM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSBC_VVM : MipsInst_VMSBC_VVM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSBC_VVM {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VMSBC_VVM<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMSBC_VVM ;
class MSA_3R_DESC_BASE_VMSBC_VVM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMV0:$v0);
	string  AsmString="vmsbc.vvm	$vd, $vs2, $vs1, v0";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class SUBSUS_U_W_ENC_VMSBC_VVM : MSA_3R_FMT_VMSBC_VVM <0b010, 0b10, 0b010001>;
class SUBSUS_U_W_DESC_VMSBC_VVM : MSA_3R_DESC_BASE_VMSBC_VVM <"subsus_u.w", null_frag, ?>;
def VMSBC_VVM : SUBSUS_U_W_ENC_VMSBC_VVM , SUBSUS_U_W_DESC_VMSBC_VVM , VMSBC_VVM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSBC_VVM;
class MipsInst_VSBC_VVM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSBC_VVM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSBC_VVM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSBC_VVM : MipsInst_VSBC_VVM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSBC_VVM {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VSBC_VVM<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSBC_VVM ;
class MSA_3R_DESC_BASE_VSBC_VVM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMV0:$v0);
	string  AsmString="vsbc.vvm	$vd, $vs2, $vs1, v0";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class SUBSUS_U_W_ENC_VSBC_VVM : MSA_3R_FMT_VSBC_VVM <0b010, 0b10, 0b010001>;
class SUBSUS_U_W_DESC_VSBC_VVM : MSA_3R_DESC_BASE_VSBC_VVM <"subsus_u.w", null_frag, ?>;
def VSBC_VVM : SUBSUS_U_W_ENC_VSBC_VVM , SUBSUS_U_W_DESC_VSBC_VVM , VSBC_VVM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSBC_VXM;
class MipsInst_VSBC_VXM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSBC_VXM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSBC_VXM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSBC_VXM : MipsInst_VSBC_VXM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSBC_VXM {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VSBC_VXM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMV0:$v0);
	string  AsmString="vsbc.vxm	$vd, $vs2, $rs1, v0";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VSBC_VXM<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSBC_VXM ;
class SUBSUU_S_W_DESC_VSBC_VXM : MSA_3R_DESC_BASE_VSBC_VXM <"subsuu_s.w", null_frag, ?>;
class SUBSUU_S_W_ENC_VSBC_VXM : MSA_3R_FMT_VSBC_VXM <0b011, 0b10, 0b010001>;
def VSBC_VXM : SUBSUU_S_W_ENC_VSBC_VXM , SUBSUU_S_W_DESC_VSBC_VXM , VSBC_VXM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWMACCUS_VX;
class MipsInst_VWMACCUS_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWMACCUS_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWMACCUS_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWMACCUS_VX : MipsInst_VWMACCUS_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWMACCUS_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VWMACCUS_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vwmaccus.vx	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VWMACCUS_VX<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VWMACCUS_VX ;
class MSA_3RF_DESC_BASE_VWMACCUS_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VWMACCUS_VX <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class IsCommutable_VWMACCUS_VX{
	bit  isCommutable=false;
}
class FADD_W_ENC_VWMACCUS_VX : MSA_3RF_FMT_VWMACCUS_VX <0b0000, 0b0, 0b011011>;
class FADD_W_DESC_VWMACCUS_VX : MSA_3RF_DESC_BASE_VWMACCUS_VX <"fadd.w", null_frag, ?>, IsCommutable_VWMACCUS_VX ;
def VWMACCUS_VX : FADD_W_ENC_VWMACCUS_VX , FADD_W_DESC_VWMACCUS_VX , VWMACCUS_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VASUB_VV;
class MipsInst_VASUB_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VASUB_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VASUB_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VASUB_VV : MipsInst_VASUB_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VASUB_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VASUB_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VASUB_VV ;
class MSA_3R_DESC_BASE_VASUB_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vasub.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MOD_U_W_ENC_VASUB_VV : MSA_3R_FMT_VASUB_VV <0b111, 0b10, 0b010010>;
class MOD_U_W_DESC_VASUB_VV : MSA_3R_DESC_BASE_VASUB_VV <"mod_u.w", null_frag, ?>;
def VASUB_VV : MOD_U_W_ENC_VASUB_VV , MOD_U_W_DESC_VASUB_VV , VASUB_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VASUB_VX;
class MipsInst_VASUB_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VASUB_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VASUB_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VASUB_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vasub.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VASUB_VX : MipsInst_VASUB_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VASUB_VX {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VASUB_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VASUB_VX <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VASUB_VX<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VASUB_VX ;
class MULR_Q_W_DESC_VASUB_VX : MSA_3RF_DESC_BASE_VASUB_VX <"mulr_q.w", null_frag, ?>;
class MULR_Q_W_ENC_VASUB_VX : MSA_3RF_FMT_VASUB_VX <0b1100, 0b1, 0b011100>;
def VASUB_VX : MULR_Q_W_ENC_VASUB_VX , MULR_Q_W_DESC_VASUB_VX , VASUB_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWSUBU_WV;
class MipsInst_VWSUBU_WV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWSUBU_WV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWSUBU_WV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWSUBU_WV : MipsInst_VWSUBU_WV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWSUBU_WV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VWSUBU_WV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWSUBU_WV ;
class MSA_3R_DESC_BASE_VWSUBU_WV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vwsubu.wv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VWSUBU_WV{
	bit  isCommutable=false;
}
class ADDV_D_ENC_VWSUBU_WV : MSA_3R_FMT_VWSUBU_WV <0b000, 0b11, 0b001110>;
class ADDV_D_DESC_VWSUBU_WV : MSA_3R_DESC_BASE_VWSUBU_WV <"addv.d", null_frag, ?>, IsCommutable_VWSUBU_WV ;
def VWSUBU_WV : ADDV_D_ENC_VWSUBU_WV , ADDV_D_DESC_VWSUBU_WV , VWSUBU_WV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSBC_VX;
class MipsInst_VMSBC_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSBC_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSBC_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSBC_VX : MipsInst_VMSBC_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSBC_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_4R_DESC_BASE_VMSBC_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1);
	string  AsmString="vmsbc.vx	$vd, $vs2, $rs1";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="@earlyclobber $vd";
}
class MSA_3R_FMT_VMSBC_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMSBC_VX ;
class MADDV_W_DESC_VMSBC_VX : MSA_3R_4R_DESC_BASE_VMSBC_VX <"maddv.w", null_frag, ?>;
class MADDV_W_ENC_VMSBC_VX : MSA_3R_FMT_VMSBC_VX <0b001, 0b10, 0b010010>;
def VMSBC_VX : MADDV_W_ENC_VMSBC_VX , MADDV_W_DESC_VMSBC_VX , VMSBC_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSBC_VXM;
class MipsInst_VMSBC_VXM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSBC_VXM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSBC_VXM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSBC_VXM : MipsInst_VMSBC_VXM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSBC_VXM {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMSBC_VXM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMV0:$v0);
	string  AsmString="vmsbc.vxm	$vd, $vs2, $rs1, v0";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VMSBC_VXM{
	bit  isCommutable=false;
}
class MSA_3R_FMT_VMSBC_VXM<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMSBC_VXM ;
class AVER_S_W_DESC_VMSBC_VXM : MSA_3R_DESC_BASE_VMSBC_VXM <"aver_s.w", null_frag, ?>, IsCommutable_VMSBC_VXM ;
class AVER_S_W_ENC_VMSBC_VXM : MSA_3R_FMT_VMSBC_VXM <0b110, 0b10, 0b010000>;
def VMSBC_VXM : AVER_S_W_ENC_VMSBC_VXM , AVER_S_W_DESC_VMSBC_VXM , VMSBC_VXM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSBC_VV;
class MipsInst_VMSBC_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSBC_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSBC_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSBC_VV : MipsInst_VMSBC_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSBC_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMSBC_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1);
	string  AsmString="vmsbc.vv	$vd, $vs2, $vs1";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VMSBC_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMSBC_VV ;
class ASUB_S_W_DESC_VMSBC_VV : MSA_3R_DESC_BASE_VMSBC_VV <"asub_s.w", null_frag, ?>;
class ASUB_S_W_ENC_VMSBC_VV : MSA_3R_FMT_VMSBC_VV <0b100, 0b10, 0b010001>;
def VMSBC_VV : ASUB_S_W_ENC_VMSBC_VV , ASUB_S_W_DESC_VMSBC_VV , VMSBC_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VASUBU_VV;
class MipsInst_VASUBU_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VASUBU_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VASUBU_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VASUBU_VV : MipsInst_VASUBU_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VASUBU_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VASUBU_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VASUBU_VV ;
class MSA_3R_DESC_BASE_VASUBU_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vasubu.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VASUBU_VV{
	bit  isCommutable=false;
}
class ADDV_W_ENC_VASUBU_VV : MSA_3R_FMT_VASUBU_VV <0b000, 0b10, 0b001110>;
class ADDV_W_DESC_VASUBU_VV : MSA_3R_DESC_BASE_VASUBU_VV <"addv.w", null_frag, ?>, IsCommutable_VASUBU_VV ;
def VASUBU_VV : ADDV_W_ENC_VASUBU_VV , ADDV_W_DESC_VASUBU_VV , VASUBU_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VASUBU_VX;
class MipsInst_VASUBU_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VASUBU_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VASUBU_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VASUBU_VX : MipsInst_VASUBU_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VASUBU_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VASUBU_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VASUBU_VX ;
class MSA_3R_DESC_BASE_VASUBU_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vasubu.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VASUBU_VX{
	bit  isCommutable=false;
}
class ADDV_W_ENC_VASUBU_VX : MSA_3R_FMT_VASUBU_VX <0b000, 0b10, 0b001110>;
class ADDV_W_DESC_VASUBU_VX : MSA_3R_DESC_BASE_VASUBU_VX <"addv.w", null_frag, ?>, IsCommutable_VASUBU_VX ;
def VASUBU_VX : ADDV_W_ENC_VASUBU_VX , ADDV_W_DESC_VASUBU_VX , VASUBU_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VRGATHER_VV;
class MipsInst_VRGATHER_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VRGATHER_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VRGATHER_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VRGATHER_VV : MipsInst_VRGATHER_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VRGATHER_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_SPLAT_DESC_BASE_VRGATHER_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vrgather.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_INDEX_FMT_VRGATHER_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VRGATHER_VV ;
class SPLAT_W_DESC_VRGATHER_VV : MSA_3R_SPLAT_DESC_BASE_VRGATHER_VV <"splat.w", null_frag, ?>;
class SPLAT_W_ENC_VRGATHER_VV : MSA_3R_INDEX_FMT_VRGATHER_VV <0b001, 0b10, 0b010100>;
def VRGATHER_VV : SPLAT_W_ENC_VRGATHER_VV , SPLAT_W_DESC_VRGATHER_VV , VRGATHER_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VRGATHEREI16_VV;
class MipsInst_VRGATHEREI16_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VRGATHEREI16_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VRGATHEREI16_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VRGATHEREI16_VV : MipsInst_VRGATHEREI16_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VRGATHEREI16_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_SPLAT_DESC_BASE_VRGATHEREI16_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vrgatherei16.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_INDEX_FMT_VRGATHEREI16_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VRGATHEREI16_VV ;
class SPLAT_W_DESC_VRGATHEREI16_VV : MSA_3R_SPLAT_DESC_BASE_VRGATHEREI16_VV <"splat.w", null_frag, ?>;
class SPLAT_W_ENC_VRGATHEREI16_VV : MSA_3R_INDEX_FMT_VRGATHEREI16_VV <0b001, 0b10, 0b010100>;
def VRGATHEREI16_VV : SPLAT_W_ENC_VRGATHEREI16_VV , SPLAT_W_DESC_VRGATHEREI16_VV , VRGATHEREI16_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VRGATHER_VI;
class MipsInst_VRGATHER_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VRGATHER_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VRGATHER_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VRGATHER_VI : MipsInst_VRGATHER_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VRGATHER_VI {
	let  EncodingPredicates=[];
}
class MSA_3R_SPLAT_DESC_BASE_VRGATHER_VI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, uimm5:$imm, VMaskOp:$vm);
	string  AsmString="vrgather.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_INDEX_FMT_VRGATHER_VI<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VRGATHER_VI ;
class SPLAT_W_DESC_VRGATHER_VI : MSA_3R_SPLAT_DESC_BASE_VRGATHER_VI <"splat.w", null_frag, ?>;
class SPLAT_W_ENC_VRGATHER_VI : MSA_3R_INDEX_FMT_VRGATHER_VI <0b001, 0b10, 0b010100>;
def VRGATHER_VI : SPLAT_W_ENC_VRGATHER_VI , SPLAT_W_DESC_VRGATHER_VI , VRGATHER_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSBF_M;
class MipsInst_VMSBF_M<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSBF_M {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSBF_M{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSBF_M : MipsInst_VMSBF_M <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSBF_M {
	let  EncodingPredicates=[];
}
class MSA_2R_FMT_VMSBF_M<bits<8>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMSBF_M ;
class MSA_2R_DESC_BASE_VMSBF_M<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vmsbf.m	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class NLOC_W_ENC_VMSBF_M : MSA_2R_FMT_VMSBF_M <0b11000010, 0b10, 0b011110>;
class NLOC_W_DESC_VMSBF_M : MSA_2R_DESC_BASE_VMSBF_M <"nloc.w", null_frag, ?>;
def VMSBF_M : NLOC_W_ENC_VMSBF_M , NLOC_W_DESC_VMSBF_M , VMSBF_M_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSIF_M;
class MipsInst_VMSIF_M<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSIF_M {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSIF_M{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSIF_M : MipsInst_VMSIF_M <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSIF_M {
	let  EncodingPredicates=[];
}
class MSA_VEC_FMT_VMSIF_M<bits<5>  major, bits<6>  minor> : MSAInst_VMSIF_M ;
class BMNZ_V_DESC_VMSIF_M{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vmsif.m	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=NoItinerary;
	string  Constraints="@earlyclobber $vd";
}
class BMNZ_V_ENC_VMSIF_M : MSA_VEC_FMT_VMSIF_M <0b00100, 0b011110>;
def VMSIF_M : BMNZ_V_ENC_VMSIF_M , BMNZ_V_DESC_VMSIF_M , VMSIF_M_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VRGATHER_VX;
class MipsInst_VRGATHER_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VRGATHER_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VRGATHER_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VRGATHER_VX : MipsInst_VRGATHER_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VRGATHER_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_SPLAT_DESC_BASE_VRGATHER_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vrgather.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_INDEX_FMT_VRGATHER_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VRGATHER_VX ;
class SPLAT_W_DESC_VRGATHER_VX : MSA_3R_SPLAT_DESC_BASE_VRGATHER_VX <"splat.w", null_frag, ?>;
class SPLAT_W_ENC_VRGATHER_VX : MSA_3R_INDEX_FMT_VRGATHER_VX <0b001, 0b10, 0b010100>;
def VRGATHER_VX : SPLAT_W_ENC_VRGATHER_VX , SPLAT_W_DESC_VRGATHER_VX , VRGATHER_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSETVL;
class MipsInst_VSETVL<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSETVL {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSETVL{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSETVL : MipsInst_VSETVL <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSETVL {
	let  EncodingPredicates=[];
}
class MSA_VEC_FMT_VSETVL<bits<5>  major, bits<6>  minor> : MSAInst_VSETVL ;
class BMNZ_V_DESC_VSETVL{
	dag  OutOperandList=(outs GPR:$rd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2);
	string  AsmString="vsetvl	$rd, $rs1, $rs2";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=NoItinerary;
	string  Constraints="";
}
class BMNZ_V_ENC_VSETVL : MSA_VEC_FMT_VSETVL <0b00100, 0b011110>;
def VSETVL : BMNZ_V_ENC_VSETVL , BMNZ_V_DESC_VSETVL , VSETVL_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 1;
	let mayStore = 0;
	let Defs = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSETVLI;
class MipsInst_VSETVLI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSETVLI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSETVLI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSETVLI : MipsInst_VSETVLI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSETVLI {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VSETVLI<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSETVLI ;
class MSA_3R_DESC_BASE_VSETVLI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs GPR:$rd);
	dag  InOperandList=(ins GPR:$rs1, VTypeIOp:$vtypei);
	string  AsmString="vsetvli	$rd, $rs1, $vtypei";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class BCLR_W_ENC_VSETVLI : MSA_3R_FMT_VSETVLI <0b011, 0b10, 0b001101>;
class BCLR_W_DESC_VSETVLI : MSA_3R_DESC_BASE_VSETVLI <"bclr.w", null_frag, ?>;
def VSETVLI : BCLR_W_ENC_VSETVLI , BCLR_W_DESC_VSETVLI , VSETVLI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 1;
	let mayStore = 0;
	let Defs = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VFIRST_M;
class MipsInst_VFIRST_M<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFIRST_M {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFIRST_M{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFIRST_M : MipsInst_VFIRST_M <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFIRST_M {
	let  EncodingPredicates=[];
}
class MSA_2R_FMT_VFIRST_M<bits<8>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFIRST_M ;
class MSA_2R_DESC_BASE_VFIRST_M<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs GPR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfirst.m	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class NLOC_W_ENC_VFIRST_M : MSA_2R_FMT_VFIRST_M <0b11000010, 0b10, 0b011110>;
class NLOC_W_DESC_VFIRST_M : MSA_2R_DESC_BASE_VFIRST_M <"nloc.w", null_frag, ?>;
def VFIRST_M : NLOC_W_ENC_VFIRST_M , NLOC_W_DESC_VFIRST_M , VFIRST_M_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSETIVLI;
class MipsInst_VSETIVLI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSETIVLI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSETIVLI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSETIVLI : MipsInst_VSETIVLI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSETIVLI {
	let  EncodingPredicates=[];
}
class MSA_BIT_W_FMT_VSETIVLI<bits<3>  major, bits<6>  minor> : MSAInst_VSETIVLI ;
class MSA_BIT_W_DESC_BASE_VSETIVLI<string  instr_asm, SDPatternOperator  OpNode, ComplexPattern  Imm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs GPR:$rd);
	dag  InOperandList=(ins uimm5:$uimm, VTypeIOp:$vtypei);
	string  AsmString="vsetivli	$rd, $uimm, $vtypei";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class BSETI_W_ENC_VSETIVLI : MSA_BIT_W_FMT_VSETIVLI <0b100, 0b001001>;
class BSETI_W_DESC_VSETIVLI : MSA_BIT_W_DESC_BASE_VSETIVLI <"bseti.w", null_frag, addr, ?>;
def VSETIVLI : BSETI_W_ENC_VSETIVLI , BSETI_W_DESC_VSETIVLI , VSETIVLI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 1;
	let mayStore = 0;
	let Defs = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSEQ_VV;
class MipsInst_VMSEQ_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSEQ_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSEQ_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSEQ_VV : MipsInst_VMSEQ_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSEQ_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMSEQ_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vmseq.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VMSEQ_VV{
	bit  isCommutable=false;
}
class MSA_3R_FMT_VMSEQ_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMSEQ_VV ;
class CEQ_W_DESC_VMSEQ_VV : MSA_3R_DESC_BASE_VMSEQ_VV <"ceq.w", null_frag, ?>, IsCommutable_VMSEQ_VV ;
class CEQ_W_ENC_VMSEQ_VV : MSA_3R_FMT_VMSEQ_VV <0b000, 0b10, 0b001111>;
def VMSEQ_VV : CEQ_W_ENC_VMSEQ_VV , CEQ_W_DESC_VMSEQ_VV , VMSEQ_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSNE_VX;
class MipsInst_VMSNE_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSNE_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSNE_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSNE_VX : MipsInst_VMSNE_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSNE_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMSNE_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vmsne.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VMSNE_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMSNE_VX ;
class MAX_U_W_DESC_VMSNE_VX : MSA_3R_DESC_BASE_VMSNE_VX <"max_u.w", null_frag, ?>;
class MAX_U_W_ENC_VMSNE_VX : MSA_3R_FMT_VMSNE_VX <0b011, 0b10, 0b001110>;
def VMSNE_VX : MAX_U_W_ENC_VMSNE_VX , MAX_U_W_DESC_VMSNE_VX , VMSNE_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSEQ_VX;
class MipsInst_VMSEQ_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSEQ_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSEQ_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSEQ_VX : MipsInst_VMSEQ_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSEQ_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMSEQ_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vmseq.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VMSEQ_VX<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMSEQ_VX ;
class MSA_3RF_DESC_BASE_VMSEQ_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMSEQ_VX <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class IsCommutable_VMSEQ_VX{
	bit  isCommutable=false;
}
class FCUNE_W_ENC_VMSEQ_VX : MSA_3RF_FMT_VMSEQ_VX <0b0010, 0b0, 0b011100>;
class FCUNE_W_DESC_VMSEQ_VX : MSA_3RF_DESC_BASE_VMSEQ_VX <"fcune.w", null_frag, ?>, IsCommutable_VMSEQ_VX ;
def VMSEQ_VX : FCUNE_W_ENC_VMSEQ_VX , FCUNE_W_DESC_VMSEQ_VX , VMSEQ_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSNE_VV;
class MipsInst_VMSNE_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSNE_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSNE_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSNE_VV : MipsInst_VMSNE_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSNE_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMSNE_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vmsne.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VMSNE_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMSNE_VV ;
class MSA_3RF_DESC_BASE_VMSNE_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMSNE_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FSNE_W_ENC_VMSNE_VV : MSA_3RF_FMT_VMSNE_VV <0b1011, 0b0, 0b011100>;
class FSNE_W_DESC_VMSNE_VV : MSA_3RF_DESC_BASE_VMSNE_VV <"fsne.w", null_frag, ?>;
def VMSNE_VV : FSNE_W_ENC_VMSNE_VV , FSNE_W_DESC_VMSNE_VV , VMSNE_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSEQ_VI;
class MipsInst_VMSEQ_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSEQ_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSEQ_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMSEQ_VI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, simm5:$imm, VMaskOp:$vm);
	string  AsmString="vmseq.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VMSEQ_VI : MipsInst_VMSEQ_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSEQ_VI {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VMSEQ_VI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMSEQ_VI <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class IsCommutable_VMSEQ_VI{
	bit  isCommutable=false;
}
class MSA_3RF_FMT_VMSEQ_VI<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMSEQ_VI ;
class FCULE_W_DESC_VMSEQ_VI : MSA_3RF_DESC_BASE_VMSEQ_VI <"fcule.w", null_frag, ?>, IsCommutable_VMSEQ_VI ;
class FCULE_W_ENC_VMSEQ_VI : MSA_3RF_FMT_VMSEQ_VI <0b0111, 0b0, 0b011010>;
def VMSEQ_VI : FCULE_W_ENC_VMSEQ_VI , FCULE_W_DESC_VMSEQ_VI , VMSEQ_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSNE_VI;
class MipsInst_VMSNE_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSNE_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSNE_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMSNE_VI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, simm5:$imm, VMaskOp:$vm);
	string  AsmString="vmsne.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VMSNE_VI : MipsInst_VMSNE_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSNE_VI {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VMSNE_VI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMSNE_VI <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class IsCommutable_VMSNE_VI{
	bit  isCommutable=false;
}
class MSA_3RF_FMT_VMSNE_VI<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMSNE_VI ;
class FCULE_W_DESC_VMSNE_VI : MSA_3RF_DESC_BASE_VMSNE_VI <"fcule.w", null_frag, ?>, IsCommutable_VMSNE_VI ;
class FCULE_W_ENC_VMSNE_VI : MSA_3RF_FMT_VMSNE_VI <0b0111, 0b0, 0b011010>;
def VMSNE_VI : FCULE_W_ENC_VMSNE_VI , FCULE_W_DESC_VMSNE_VI , VMSNE_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSLE_VV;
class MipsInst_VMSLE_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSLE_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSLE_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSLE_VV : MipsInst_VMSLE_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSLE_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMSLE_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vmsle.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VMSLE_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMSLE_VV ;
class MSA_3RF_DESC_BASE_VMSLE_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMSLE_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FSNE_W_ENC_VMSLE_VV : MSA_3RF_FMT_VMSLE_VV <0b1011, 0b0, 0b011100>;
class FSNE_W_DESC_VMSLE_VV : MSA_3RF_DESC_BASE_VMSLE_VV <"fsne.w", null_frag, ?>;
def VMSLE_VV : FSNE_W_ENC_VMSLE_VV , FSNE_W_DESC_VMSLE_VV , VMSLE_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSLE_VX;
class MipsInst_VMSLE_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSLE_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSLE_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSLE_VX : MipsInst_VMSLE_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSLE_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMSLE_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vmsle.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VMSLE_VX<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMSLE_VX ;
class MSA_3RF_DESC_BASE_VMSLE_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMSLE_VX <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FSNE_W_ENC_VMSLE_VX : MSA_3RF_FMT_VMSLE_VX <0b1011, 0b0, 0b011100>;
class FSNE_W_DESC_VMSLE_VX : MSA_3RF_DESC_BASE_VMSLE_VX <"fsne.w", null_frag, ?>;
def VMSLE_VX : FSNE_W_ENC_VMSLE_VX , FSNE_W_DESC_VMSLE_VX , VMSLE_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSLEU_VV;
class MipsInst_VMSLEU_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSLEU_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSLEU_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSLEU_VV : MipsInst_VMSLEU_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSLEU_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMSLEU_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vmsleu.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VMSLEU_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMSLEU_VV ;
class CLT_U_W_DESC_VMSLEU_VV : MSA_3R_DESC_BASE_VMSLEU_VV <"clt_u.w", null_frag, ?>;
class CLT_U_W_ENC_VMSLEU_VV : MSA_3R_FMT_VMSLEU_VV <0b011, 0b10, 0b001111>;
def VMSLEU_VV : CLT_U_W_ENC_VMSLEU_VV , CLT_U_W_DESC_VMSLEU_VV , VMSLEU_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSLEU_VX;
class MipsInst_VMSLEU_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSLEU_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSLEU_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSLEU_VX : MipsInst_VMSLEU_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSLEU_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VMSLEU_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMSLEU_VX ;
class MSA_3R_DESC_BASE_VMSLEU_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vmsleu.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MIN_S_W_ENC_VMSLEU_VX : MSA_3R_FMT_VMSLEU_VX <0b100, 0b10, 0b001110>;
class MIN_S_W_DESC_VMSLEU_VX : MSA_3R_DESC_BASE_VMSLEU_VX <"min_s.w", null_frag, ?>;
def VMSLEU_VX : MIN_S_W_ENC_VMSLEU_VX , MIN_S_W_DESC_VMSLEU_VX , VMSLEU_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSLE_VI;
class MipsInst_VMSLE_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSLE_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSLE_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSLE_VI : MipsInst_VMSLE_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSLE_VI {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMSLE_VI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, simm5:$imm, VMaskOp:$vm);
	string  AsmString="vmsle.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VMSLE_VI<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMSLE_VI ;
class MSA_3RF_DESC_BASE_VMSLE_VI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMSLE_VI <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FSLT_W_ENC_VMSLE_VI : MSA_3RF_FMT_VMSLE_VI <0b1100, 0b0, 0b011010>;
class FSLT_W_DESC_VMSLE_VI : MSA_3RF_DESC_BASE_VMSLE_VI <"fslt.w", null_frag, ?>;
def VMSLE_VI : FSLT_W_ENC_VMSLE_VI , FSLT_W_DESC_VMSLE_VI , VMSLE_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSLEU_VI;
class MipsInst_VMSLEU_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSLEU_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSLEU_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSLEU_VI : MipsInst_VMSLEU_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSLEU_VI {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VMSLEU_VI<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMSLEU_VI ;
class MSA_3R_DESC_BASE_VMSLEU_VI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, simm5:$imm, VMaskOp:$vm);
	string  AsmString="vmsleu.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MAX_S_W_ENC_VMSLEU_VI : MSA_3R_FMT_VMSLEU_VI <0b010, 0b10, 0b001110>;
class MAX_S_W_DESC_VMSLEU_VI : MSA_3R_DESC_BASE_VMSLEU_VI <"max_s.w", null_frag, ?>;
def VMSLEU_VI : MAX_S_W_ENC_VMSLEU_VI , MAX_S_W_DESC_VMSLEU_VI , VMSLEU_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSLT_VV;
class MipsInst_VMSLT_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSLT_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSLT_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSLT_VV : MipsInst_VMSLT_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSLT_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMSLT_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vmslt.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VMSLT_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMSLT_VV ;
class MAX_A_W_DESC_VMSLT_VV : MSA_3R_DESC_BASE_VMSLT_VV <"max_a.w", null_frag, ?>;
class MAX_A_W_ENC_VMSLT_VV : MSA_3R_FMT_VMSLT_VV <0b110, 0b10, 0b001110>;
def VMSLT_VV : MAX_A_W_ENC_VMSLT_VV , MAX_A_W_DESC_VMSLT_VV , VMSLT_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSLT_VX;
class MipsInst_VMSLT_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSLT_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSLT_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSLT_VX : MipsInst_VMSLT_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSLT_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMSLT_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vmslt.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VMSLT_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMSLT_VX ;
class CLT_S_W_DESC_VMSLT_VX : MSA_3R_DESC_BASE_VMSLT_VX <"clt_s.w", null_frag, ?>;
class CLT_S_W_ENC_VMSLT_VX : MSA_3R_FMT_VMSLT_VX <0b010, 0b10, 0b001111>;
def VMSLT_VX : CLT_S_W_ENC_VMSLT_VX , CLT_S_W_DESC_VMSLT_VX , VMSLT_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSGT_VX;
class MipsInst_VMSGT_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSGT_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSGT_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSGT_VX : MipsInst_VMSGT_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSGT_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMSGT_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vmsgt.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VMSGT_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMSGT_VX ;
class MAX_A_W_DESC_VMSGT_VX : MSA_3R_DESC_BASE_VMSGT_VX <"max_a.w", null_frag, ?>;
class MAX_A_W_ENC_VMSGT_VX : MSA_3R_FMT_VMSGT_VX <0b110, 0b10, 0b001110>;
def VMSGT_VX : MAX_A_W_ENC_VMSGT_VX , MAX_A_W_DESC_VMSGT_VX , VMSGT_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSLTU_VV;
class MipsInst_VMSLTU_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSLTU_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSLTU_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSLTU_VV : MipsInst_VMSLTU_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSLTU_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMSLTU_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vmsltu.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VMSLTU_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMSLTU_VV ;
class MSA_3RF_DESC_BASE_VMSLTU_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMSLTU_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FSNE_W_ENC_VMSLTU_VV : MSA_3RF_FMT_VMSLTU_VV <0b1011, 0b0, 0b011100>;
class FSNE_W_DESC_VMSLTU_VV : MSA_3RF_DESC_BASE_VMSLTU_VV <"fsne.w", null_frag, ?>;
def VMSLTU_VV : FSNE_W_ENC_VMSLTU_VV , FSNE_W_DESC_VMSLTU_VV , VMSLTU_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSLTU_VX;
class MipsInst_VMSLTU_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSLTU_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSLTU_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSLTU_VX : MipsInst_VMSLTU_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSLTU_VX {
	let  EncodingPredicates=[];
}
class MSA_I5_DESC_BASE_VMSLTU_VX<string  instr_asm, SDPatternOperator  OpNode, ComplexPattern  SplatImm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vmsltu.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_I5_FMT_VMSLTU_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMSLTU_VX ;
class MAXI_U_W_DESC_VMSLTU_VX : MSA_I5_DESC_BASE_VMSLTU_VX <"maxi_u.w", null_frag, ?, ?>;
class MAXI_U_W_ENC_VMSLTU_VX : MSA_I5_FMT_VMSLTU_VX <0b011, 0b10, 0b000110>;
def VMSLTU_VX : MAXI_U_W_ENC_VMSLTU_VX , MAXI_U_W_DESC_VMSLTU_VX , VMSLTU_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSGTU_VX;
class MipsInst_VMSGTU_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSGTU_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSGTU_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSGTU_VX : MipsInst_VMSGTU_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSGTU_VX {
	let  EncodingPredicates=[];
}
class MSA_I5_DESC_BASE_VMSGTU_VX<string  instr_asm, SDPatternOperator  OpNode, ComplexPattern  SplatImm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vmsgtu.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_I5_FMT_VMSGTU_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMSGTU_VX ;
class MAXI_U_W_DESC_VMSGTU_VX : MSA_I5_DESC_BASE_VMSGTU_VX <"maxi_u.w", null_frag, ?, ?>;
class MAXI_U_W_ENC_VMSGTU_VX : MSA_I5_FMT_VMSGTU_VX <0b011, 0b10, 0b000110>;
def VMSGTU_VX : MAXI_U_W_ENC_VMSGTU_VX , MAXI_U_W_DESC_VMSGTU_VX , VMSGTU_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSGTU_VI;
class MipsInst_VMSGTU_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSGTU_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSGTU_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSGTU_VI : MipsInst_VMSGTU_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSGTU_VI {
	let  EncodingPredicates=[];
}
class MSA_I5_DESC_BASE_VMSGTU_VI<string  instr_asm, SDPatternOperator  OpNode, ComplexPattern  SplatImm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, simm5:$imm, VMaskOp:$vm);
	string  AsmString="vmsgtu.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_I5_FMT_VMSGTU_VI<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMSGTU_VI ;
class MAXI_U_W_DESC_VMSGTU_VI : MSA_I5_DESC_BASE_VMSGTU_VI <"maxi_u.w", null_frag, ?, ?>;
class MAXI_U_W_ENC_VMSGTU_VI : MSA_I5_FMT_VMSGTU_VI <0b011, 0b10, 0b000110>;
def VMSGTU_VI : MAXI_U_W_ENC_VMSGTU_VI , MAXI_U_W_DESC_VMSGTU_VI , VMSGTU_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSGT_VI;
class MipsInst_VMSGT_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSGT_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSGT_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSGT_VI : MipsInst_VMSGT_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSGT_VI {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMSGT_VI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, simm5:$imm, VMaskOp:$vm);
	string  AsmString="vmsgt.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VMSGT_VI<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMSGT_VI ;
class CLE_U_W_DESC_VMSGT_VI : MSA_3R_DESC_BASE_VMSGT_VI <"cle_u.w", null_frag, ?>;
class CLE_U_W_ENC_VMSGT_VI : MSA_3R_FMT_VMSGT_VI <0b101, 0b10, 0b001111>;
def VMSGT_VI : CLE_U_W_ENC_VMSGT_VI , CLE_U_W_DESC_VMSGT_VI , VMSGT_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VDIV_VV;
class MipsInst_VDIV_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VDIV_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VDIV_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VDIV_VV : MipsInst_VDIV_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VDIV_VV {
	let  EncodingPredicates=[];
}
class IsCommutable_VDIV_VV{
	bit  isCommutable=false;
}
class MSA_3R_4R_DESC_BASE_VDIV_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vdiv.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="";
}
class MSA_3R_FMT_VDIV_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VDIV_VV ;
class DPADD_S_W_DESC_VDIV_VV : MSA_3R_4R_DESC_BASE_VDIV_VV <"dpadd_s.w", null_frag, ?, ?, ?>, IsCommutable_VDIV_VV ;
class DPADD_S_W_ENC_VDIV_VV : MSA_3R_FMT_VDIV_VV <0b010, 0b10, 0b010011>;
def VDIV_VV : DPADD_S_W_ENC_VDIV_VV , DPADD_S_W_DESC_VDIV_VV , VDIV_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VDIV_VX;
class MipsInst_VDIV_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VDIV_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VDIV_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VDIV_VX : MipsInst_VDIV_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VDIV_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VDIV_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vdiv.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VDIV_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VDIV_VX ;
class SUBV_W_DESC_VDIV_VX : MSA_3R_DESC_BASE_VDIV_VX <"subv.w", null_frag, ?>;
class SUBV_W_ENC_VDIV_VX : MSA_3R_FMT_VDIV_VX <0b001, 0b10, 0b001110>;
def VDIV_VX : SUBV_W_ENC_VDIV_VX , SUBV_W_DESC_VDIV_VX , VDIV_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VDIVU_VV;
class MipsInst_VDIVU_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VDIVU_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VDIVU_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VDIVU_VV : MipsInst_VDIVU_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VDIVU_VV {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VDIVU_VV<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VDIVU_VV ;
class MSA_2RF_DESC_BASE_VDIVU_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vdivu.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FRCP_W_ENC_VDIVU_VV : MSA_2RF_FMT_VDIVU_VV <0b110010101, 0b0, 0b011110>;
class FRCP_W_DESC_VDIVU_VV : MSA_2RF_DESC_BASE_VDIVU_VV <"frcp.w", null_frag, ?>;
def VDIVU_VV : FRCP_W_ENC_VDIVU_VV , FRCP_W_DESC_VDIVU_VV , VDIVU_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VDIVU_VX;
class MipsInst_VDIVU_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VDIVU_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VDIVU_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VDIVU_VX : MipsInst_VDIVU_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VDIVU_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VDIVU_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VDIVU_VX ;
class MSA_3R_DESC_BASE_VDIVU_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vdivu.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VDIVU_VX{
	bit  isCommutable=false;
}
class ADDV_W_ENC_VDIVU_VX : MSA_3R_FMT_VDIVU_VX <0b000, 0b10, 0b001110>;
class ADDV_W_DESC_VDIVU_VX : MSA_3R_DESC_BASE_VDIVU_VX <"addv.w", null_frag, ?>, IsCommutable_VDIVU_VX ;
def VDIVU_VX : ADDV_W_ENC_VDIVU_VX , ADDV_W_DESC_VDIVU_VX , VDIVU_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VFADD_VF;
class MipsInst_VFADD_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFADD_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFADD_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFADD_VF : MipsInst_VFADD_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFADD_VF {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VFADD_VF<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFADD_VF ;
class MSA_3R_DESC_BASE_VFADD_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vfadd.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class SUBS_U_W_ENC_VFADD_VF : MSA_3R_FMT_VFADD_VF <0b001, 0b10, 0b010001>;
class SUBS_U_W_DESC_VFADD_VF : MSA_3R_DESC_BASE_VFADD_VF <"subs_u.w", null_frag, ?>;
def VFADD_VF : SUBS_U_W_ENC_VFADD_VF , SUBS_U_W_DESC_VFADD_VF , VFADD_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWADD_VF;
class MipsInst_VFWADD_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWADD_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWADD_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_4R_DESC_BASE_VFWADD_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vfwadd.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="@earlyclobber $vd";
}
class MSAInst_VFWADD_VF : MipsInst_VFWADD_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWADD_VF {
	let  EncodingPredicates=[];
}
class MSA_3RF_4RF_DESC_BASE_VFWADD_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_4R_DESC_BASE_VFWADD_VF <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VFWADD_VF<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWADD_VF ;
class FMADD_D_DESC_VFWADD_VF : MSA_3RF_4RF_DESC_BASE_VFWADD_VF <"fmadd.d", null_frag, ?>;
class FMADD_D_ENC_VFWADD_VF : MSA_3RF_FMT_VFWADD_VF <0b0100, 0b1, 0b011011>;
def VFWADD_VF : FMADD_D_ENC_VFWADD_VF , FMADD_D_DESC_VFWADD_VF , VFWADD_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWADD_WF;
class MipsInst_VFWADD_WF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWADD_WF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWADD_WF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFWADD_WF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vfwadd.wf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VFWADD_WF : MipsInst_VFWADD_WF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWADD_WF {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VFWADD_WF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VFWADD_WF <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VFWADD_WF<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWADD_WF ;
class FSUB_D_DESC_VFWADD_WF : MSA_3RF_DESC_BASE_VFWADD_WF <"fsub.d", null_frag, ?>;
class FSUB_D_ENC_VFWADD_WF : MSA_3RF_FMT_VFWADD_WF <0b0001, 0b1, 0b011011>;
def VFWADD_WF : FSUB_D_ENC_VFWADD_WF , FSUB_D_DESC_VFWADD_WF , VFWADD_WF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFADD_VV;
class MipsInst_VFADD_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFADD_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFADD_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFADD_VV : MipsInst_VFADD_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFADD_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFADD_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vfadd.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VFADD_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFADD_VV ;
class MSA_3RF_DESC_BASE_VFADD_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VFADD_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class IsCommutable_VFADD_VV{
	bit  isCommutable=false;
}
class FADD_W_ENC_VFADD_VV : MSA_3RF_FMT_VFADD_VV <0b0000, 0b0, 0b011011>;
class FADD_W_DESC_VFADD_VV : MSA_3RF_DESC_BASE_VFADD_VV <"fadd.w", null_frag, ?>, IsCommutable_VFADD_VV ;
def VFADD_VV : FADD_W_ENC_VFADD_VV , FADD_W_DESC_VFADD_VV , VFADD_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWADD_VV;
class MipsInst_VFWADD_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWADD_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWADD_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWADD_VV : MipsInst_VFWADD_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWADD_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VFWADD_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFWADD_VV ;
class MSA_3R_DESC_BASE_VFWADD_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vfwadd.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MOD_U_D_ENC_VFWADD_VV : MSA_3R_FMT_VFWADD_VV <0b111, 0b11, 0b010010>;
class MOD_U_D_DESC_VFWADD_VV : MSA_3R_DESC_BASE_VFWADD_VV <"mod_u.d", null_frag, ?>;
def VFWADD_VV : MOD_U_D_ENC_VFWADD_VV , MOD_U_D_DESC_VFWADD_VV , VFWADD_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWADD_WV;
class MipsInst_VFWADD_WV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWADD_WV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWADD_WV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFWADD_WV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vfwadd.wv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VFWADD_WV : MipsInst_VFWADD_WV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWADD_WV {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VFWADD_WV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VFWADD_WV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VFWADD_WV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWADD_WV ;
class FDIV_D_DESC_VFWADD_WV : MSA_3RF_DESC_BASE_VFWADD_WV <"fdiv.d", null_frag, ?>;
class FDIV_D_ENC_VFWADD_WV : MSA_3RF_FMT_VFWADD_WV <0b0011, 0b1, 0b011011>;
def VFWADD_WV : FDIV_D_ENC_VFWADD_WV , FDIV_D_DESC_VFWADD_WV , VFWADD_WV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VMFEQ_VF;
class MipsInst_VMFEQ_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMFEQ_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMFEQ_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMFEQ_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vmfeq.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VMFEQ_VF : MipsInst_VMFEQ_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMFEQ_VF {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VMFEQ_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMFEQ_VF <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class IsCommutable_VMFEQ_VF{
	bit  isCommutable=false;
}
class MSA_3RF_FMT_VMFEQ_VF<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMFEQ_VF ;
class FCULE_W_DESC_VMFEQ_VF : MSA_3RF_DESC_BASE_VMFEQ_VF <"fcule.w", null_frag, ?>, IsCommutable_VMFEQ_VF ;
class FCULE_W_ENC_VMFEQ_VF : MSA_3RF_FMT_VMFEQ_VF <0b0111, 0b0, 0b011010>;
def VMFEQ_VF : FCULE_W_ENC_VMFEQ_VF , FCULE_W_DESC_VMFEQ_VF , VMFEQ_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VMFEQ_VV;
class MipsInst_VMFEQ_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMFEQ_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMFEQ_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMFEQ_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vmfeq.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VMFEQ_VV : MipsInst_VMFEQ_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMFEQ_VV {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VMFEQ_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMFEQ_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VMFEQ_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMFEQ_VV ;
class FSOR_W_DESC_VMFEQ_VV : MSA_3RF_DESC_BASE_VMFEQ_VV <"fsor.w", null_frag, ?>;
class FSOR_W_ENC_VMFEQ_VV : MSA_3RF_FMT_VMFEQ_VV <0b1001, 0b0, 0b011100>;
def VMFEQ_VV : FSOR_W_ENC_VMFEQ_VV , FSOR_W_DESC_VMFEQ_VV , VMFEQ_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFCLASS_V;
class MipsInst_VFCLASS_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFCLASS_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFCLASS_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFCLASS_V : MipsInst_VFCLASS_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFCLASS_V {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFCLASS_V<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFCLASS_V ;
class MSA_2RF_DESC_BASE_VFCLASS_V<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfclass.v	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FCLASS_W_ENC_VFCLASS_V : MSA_2RF_FMT_VFCLASS_V <0b110010000, 0b0, 0b011110>;
class FCLASS_W_DESC_VFCLASS_V : MSA_2RF_DESC_BASE_VFCLASS_V <"fclass.w", null_frag, ?>;
def VFCLASS_V : FCLASS_W_ENC_VFCLASS_V , FCLASS_W_DESC_VFCLASS_V , VFCLASS_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VMFLE_VF;
class MipsInst_VMFLE_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMFLE_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMFLE_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMFLE_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vmfle.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VMFLE_VF : MipsInst_VMFLE_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMFLE_VF {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VMFLE_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMFLE_VF <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VMFLE_VF<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMFLE_VF ;
class FMIN_W_DESC_VMFLE_VF : MSA_3RF_DESC_BASE_VMFLE_VF <"fmin.w", null_frag, ?>;
class FMIN_W_ENC_VMFLE_VF : MSA_3RF_FMT_VMFLE_VF <0b1100, 0b0, 0b011011>;
def VMFLE_VF : FMIN_W_ENC_VMFLE_VF , FMIN_W_DESC_VMFLE_VF , VMFLE_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VMFGE_VF;
class MipsInst_VMFGE_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMFGE_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMFGE_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMFGE_VF : MipsInst_VMFGE_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMFGE_VF {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMFGE_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vmfge.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VMFGE_VF<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMFGE_VF ;
class MSA_3RF_DESC_BASE_VMFGE_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMFGE_VF <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FCLE_W_ENC_VMFGE_VF : MSA_3RF_FMT_VMFGE_VF <0b0110, 0b0, 0b011010>;
class FCLE_W_DESC_VMFGE_VF : MSA_3RF_DESC_BASE_VMFGE_VF <"fcle.w", null_frag, ?>;
def VMFGE_VF : FCLE_W_ENC_VMFGE_VF , FCLE_W_DESC_VMFGE_VF , VMFGE_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VMFLE_VV;
class MipsInst_VMFLE_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMFLE_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMFLE_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMFLE_VV : MipsInst_VMFLE_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMFLE_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMFLE_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vmfle.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VMFLE_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMFLE_VV ;
class MSA_3RF_DESC_BASE_VMFLE_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMFLE_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FSNE_W_ENC_VMFLE_VV : MSA_3RF_FMT_VMFLE_VV <0b1011, 0b0, 0b011100>;
class FSNE_W_DESC_VMFLE_VV : MSA_3RF_DESC_BASE_VMFLE_VV <"fsne.w", null_frag, ?>;
def VMFLE_VV : FSNE_W_ENC_VMFLE_VV , FSNE_W_DESC_VMFLE_VV , VMFLE_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VMFLT_VF;
class MipsInst_VMFLT_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMFLT_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMFLT_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMFLT_VF : MipsInst_VMFLT_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMFLT_VF {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMFLT_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vmflt.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VMFLT_VF<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMFLT_VF ;
class MSA_3RF_DESC_BASE_VMFLT_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMFLT_VF <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FSULT_W_ENC_VMFLT_VF : MSA_3RF_FMT_VMFLT_VF <0b1101, 0b0, 0b011010>;
class FSULT_W_DESC_VMFLT_VF : MSA_3RF_DESC_BASE_VMFLT_VF <"fsult.w", null_frag, ?>;
def VMFLT_VF : FSULT_W_ENC_VMFLT_VF , FSULT_W_DESC_VMFLT_VF , VMFLT_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VMFGT_VF;
class MipsInst_VMFGT_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMFGT_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMFGT_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMFGT_VF : MipsInst_VMFGT_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMFGT_VF {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMFGT_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vmfgt.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VMFGT_VF<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMFGT_VF ;
class MSA_3RF_DESC_BASE_VMFGT_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMFGT_VF <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FSNE_W_ENC_VMFGT_VF : MSA_3RF_FMT_VMFGT_VF <0b1011, 0b0, 0b011100>;
class FSNE_W_DESC_VMFGT_VF : MSA_3RF_DESC_BASE_VMFGT_VF <"fsne.w", null_frag, ?>;
def VMFGT_VF : FSNE_W_ENC_VMFGT_VF , FSNE_W_DESC_VMFGT_VF , VMFGT_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VMFLT_VV;
class MipsInst_VMFLT_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMFLT_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMFLT_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMFLT_VV : MipsInst_VMFLT_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMFLT_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMFLT_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vmflt.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VMFLT_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMFLT_VV ;
class MSA_3RF_DESC_BASE_VMFLT_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMFLT_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FCLE_W_ENC_VMFLT_VV : MSA_3RF_FMT_VMFLT_VV <0b0110, 0b0, 0b011010>;
class FCLE_W_DESC_VMFLT_VV : MSA_3RF_DESC_BASE_VMFLT_VV <"fcle.w", null_frag, ?>;
def VMFLT_VV : FCLE_W_ENC_VMFLT_VV , FCLE_W_DESC_VMFLT_VV , VMFLT_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VMFNE_VF;
class MipsInst_VMFNE_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMFNE_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMFNE_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMFNE_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vmfne.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VMFNE_VF : MipsInst_VMFNE_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMFNE_VF {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VMFNE_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMFNE_VF <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class IsCommutable_VMFNE_VF{
	bit  isCommutable=false;
}
class MSA_3RF_FMT_VMFNE_VF<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMFNE_VF ;
class FCAF_W_DESC_VMFNE_VF : MSA_3RF_DESC_BASE_VMFNE_VF <"fcaf.w", null_frag, ?>, IsCommutable_VMFNE_VF ;
class FCAF_W_ENC_VMFNE_VF : MSA_3RF_FMT_VMFNE_VF <0b0000, 0b0, 0b011010>;
def VMFNE_VF : FCAF_W_ENC_VMFNE_VF , FCAF_W_DESC_VMFNE_VF , VMFNE_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VMFNE_VV;
class MipsInst_VMFNE_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMFNE_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMFNE_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMFNE_VV : MipsInst_VMFNE_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMFNE_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMFNE_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vmfne.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VMFNE_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMFNE_VV ;
class MSA_3RF_DESC_BASE_VMFNE_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMFNE_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FSAF_W_ENC_VMFNE_VV : MSA_3RF_FMT_VMFNE_VV <0b1000, 0b0, 0b011010>;
class FSAF_W_DESC_VMFNE_VV : MSA_3RF_DESC_BASE_VMFNE_VV <"fsaf.w", null_frag, ?>;
def VMFNE_VV : FSAF_W_ENC_VMFNE_VV , FSAF_W_DESC_VMFNE_VV , VMFNE_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFDIV_VF;
class MipsInst_VFDIV_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFDIV_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFDIV_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFDIV_VF : MipsInst_VFDIV_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFDIV_VF {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VFDIV_VF<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFDIV_VF ;
class MSA_3R_4R_DESC_BASE_VFDIV_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vfdiv.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="";
}
class DPSUB_S_W_ENC_VFDIV_VF : MSA_3R_FMT_VFDIV_VF <0b100, 0b10, 0b010011>;
class DPSUB_S_W_DESC_VFDIV_VF : MSA_3R_4R_DESC_BASE_VFDIV_VF <"dpsub_s.w", null_frag, ?, ?, ?>;
def VFDIV_VF : DPSUB_S_W_ENC_VFDIV_VF , DPSUB_S_W_DESC_VFDIV_VF , VFDIV_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFRDIV_VF;
class MipsInst_VFRDIV_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFRDIV_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFRDIV_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFRDIV_VF : MipsInst_VFRDIV_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFRDIV_VF {
	let  EncodingPredicates=[];
}
class MSA_3R_4R_DESC_BASE_VFRDIV_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vfrdiv.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="";
}
class MSA_3RF_FMT_VFRDIV_VF<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFRDIV_VF ;
class MSA_3RF_4RF_DESC_BASE_VFRDIV_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_4R_DESC_BASE_VFRDIV_VF <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MADDR_Q_W_ENC_VFRDIV_VF : MSA_3RF_FMT_VFRDIV_VF <0b1101, 0b1, 0b011100>;
class MADDR_Q_W_DESC_VFRDIV_VF : MSA_3RF_4RF_DESC_BASE_VFRDIV_VF <"maddr_q.w", null_frag, ?>;
def VFRDIV_VF : MADDR_Q_W_ENC_VFRDIV_VF , MADDR_Q_W_DESC_VFRDIV_VF , VFRDIV_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFDIV_VV;
class MipsInst_VFDIV_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFDIV_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFDIV_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFDIV_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vfdiv.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VFDIV_VV : MipsInst_VFDIV_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFDIV_VV {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VFDIV_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VFDIV_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VFDIV_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFDIV_VV ;
class MULR_Q_W_DESC_VFDIV_VV : MSA_3RF_DESC_BASE_VFDIV_VV <"mulr_q.w", null_frag, ?>;
class MULR_Q_W_ENC_VFDIV_VV : MSA_3RF_FMT_VFDIV_VV <0b1100, 0b1, 0b011100>;
def VFDIV_VV : MULR_Q_W_ENC_VFDIV_VV , MULR_Q_W_DESC_VFDIV_VV , VFDIV_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWCVT_F_X_V;
class MipsInst_VFWCVT_F_X_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWCVT_F_X_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWCVT_F_X_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWCVT_F_X_V : MipsInst_VFWCVT_F_X_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWCVT_F_X_V {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VFWCVT_F_X_V<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfwcvt.f.x.v	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VFWCVT_F_X_V<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWCVT_F_X_V ;
class FEXUPR_W_DESC_VFWCVT_F_X_V : MSA_2RF_DESC_BASE_VFWCVT_F_X_V <"fexupr.w", null_frag, ?, ?>;
class FEXUPR_W_ENC_VFWCVT_F_X_V : MSA_2RF_FMT_VFWCVT_F_X_V <0b110011001, 0b0, 0b011110>;
def VFWCVT_F_X_V : FEXUPR_W_ENC_VFWCVT_F_X_V , FEXUPR_W_DESC_VFWCVT_F_X_V , VFWCVT_F_X_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFCVT_RTZ_XU_F_V;
class MipsInst_VFCVT_RTZ_XU_F_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFCVT_RTZ_XU_F_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFCVT_RTZ_XU_F_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFCVT_RTZ_XU_F_V : MipsInst_VFCVT_RTZ_XU_F_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFCVT_RTZ_XU_F_V {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VFCVT_RTZ_XU_F_V<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfcvt.rtz.xu.f.v	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VFCVT_RTZ_XU_F_V<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFCVT_RTZ_XU_F_V ;
class FEXUPL_W_DESC_VFCVT_RTZ_XU_F_V : MSA_2RF_DESC_BASE_VFCVT_RTZ_XU_F_V <"fexupl.w", null_frag, ?, ?>;
class FEXUPL_W_ENC_VFCVT_RTZ_XU_F_V : MSA_2RF_FMT_VFCVT_RTZ_XU_F_V <0b110011000, 0b0, 0b011110>;
def VFCVT_RTZ_XU_F_V : FEXUPL_W_ENC_VFCVT_RTZ_XU_F_V , FEXUPL_W_DESC_VFCVT_RTZ_XU_F_V , VFCVT_RTZ_XU_F_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFCVT_RTZ_X_F_V;
class MipsInst_VFCVT_RTZ_X_F_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFCVT_RTZ_X_F_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFCVT_RTZ_X_F_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFCVT_RTZ_X_F_V : MipsInst_VFCVT_RTZ_X_F_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFCVT_RTZ_X_F_V {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFCVT_RTZ_X_F_V<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFCVT_RTZ_X_F_V ;
class MSA_2RF_DESC_BASE_VFCVT_RTZ_X_F_V<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfcvt.rtz.x.f.v	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FFQR_W_ENC_VFCVT_RTZ_X_F_V : MSA_2RF_FMT_VFCVT_RTZ_X_F_V <0b110011011, 0b0, 0b011110>;
class FFQR_W_DESC_VFCVT_RTZ_X_F_V : MSA_2RF_DESC_BASE_VFCVT_RTZ_X_F_V <"ffqr.w", null_frag, ?, ?>;
def VFCVT_RTZ_X_F_V : FFQR_W_ENC_VFCVT_RTZ_X_F_V , FFQR_W_DESC_VFCVT_RTZ_X_F_V , VFCVT_RTZ_X_F_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFCVT_F_X_V;
class MipsInst_VFCVT_F_X_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFCVT_F_X_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFCVT_F_X_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFCVT_F_X_V : MipsInst_VFCVT_F_X_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFCVT_F_X_V {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFCVT_F_X_V<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFCVT_F_X_V ;
class MSA_2RF_DESC_BASE_VFCVT_F_X_V<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfcvt.f.x.v	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FTINT_U_W_ENC_VFCVT_F_X_V : MSA_2RF_FMT_VFCVT_F_X_V <0b110011101, 0b0, 0b011110>;
class FTINT_U_W_DESC_VFCVT_F_X_V : MSA_2RF_DESC_BASE_VFCVT_F_X_V <"ftint_u.w", null_frag, ?>;
def VFCVT_F_X_V : FTINT_U_W_ENC_VFCVT_F_X_V , FTINT_U_W_DESC_VFCVT_F_X_V , VFCVT_F_X_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWCVT_RTZ_XU_F_V;
class MipsInst_VFWCVT_RTZ_XU_F_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWCVT_RTZ_XU_F_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWCVT_RTZ_XU_F_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWCVT_RTZ_XU_F_V : MipsInst_VFWCVT_RTZ_XU_F_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWCVT_RTZ_XU_F_V {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFWCVT_RTZ_XU_F_V<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWCVT_RTZ_XU_F_V ;
class MSA_2RF_DESC_BASE_VFWCVT_RTZ_XU_F_V<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfwcvt.rtz.xu.f.v	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FTINT_U_W_ENC_VFWCVT_RTZ_XU_F_V : MSA_2RF_FMT_VFWCVT_RTZ_XU_F_V <0b110011101, 0b0, 0b011110>;
class FTINT_U_W_DESC_VFWCVT_RTZ_XU_F_V : MSA_2RF_DESC_BASE_VFWCVT_RTZ_XU_F_V <"ftint_u.w", null_frag, ?>;
def VFWCVT_RTZ_XU_F_V : FTINT_U_W_ENC_VFWCVT_RTZ_XU_F_V , FTINT_U_W_DESC_VFWCVT_RTZ_XU_F_V , VFWCVT_RTZ_XU_F_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWCVT_RTZ_X_F_V;
class MipsInst_VFWCVT_RTZ_X_F_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWCVT_RTZ_X_F_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWCVT_RTZ_X_F_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWCVT_RTZ_X_F_V : MipsInst_VFWCVT_RTZ_X_F_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWCVT_RTZ_X_F_V {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VFWCVT_RTZ_X_F_V<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfwcvt.rtz.x.f.v	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VFWCVT_RTZ_X_F_V<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWCVT_RTZ_X_F_V ;
class FEXUPL_W_DESC_VFWCVT_RTZ_X_F_V : MSA_2RF_DESC_BASE_VFWCVT_RTZ_X_F_V <"fexupl.w", null_frag, ?, ?>;
class FEXUPL_W_ENC_VFWCVT_RTZ_X_F_V : MSA_2RF_FMT_VFWCVT_RTZ_X_F_V <0b110011000, 0b0, 0b011110>;
def VFWCVT_RTZ_X_F_V : FEXUPL_W_ENC_VFWCVT_RTZ_X_F_V , FEXUPL_W_DESC_VFWCVT_RTZ_X_F_V , VFWCVT_RTZ_X_F_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWCVT_F_F_V;
class MipsInst_VFWCVT_F_F_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWCVT_F_F_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWCVT_F_F_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWCVT_F_F_V : MipsInst_VFWCVT_F_F_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWCVT_F_F_V {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VFWCVT_F_F_V<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfwcvt.f.f.v	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VFWCVT_F_F_V<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWCVT_F_F_V ;
class FEXUPR_W_DESC_VFWCVT_F_F_V : MSA_2RF_DESC_BASE_VFWCVT_F_F_V <"fexupr.w", null_frag, ?, ?>;
class FEXUPR_W_ENC_VFWCVT_F_F_V : MSA_2RF_FMT_VFWCVT_F_F_V <0b110011001, 0b0, 0b011110>;
def VFWCVT_F_F_V : FEXUPR_W_ENC_VFWCVT_F_F_V , FEXUPR_W_DESC_VFWCVT_F_F_V , VFWCVT_F_F_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFNCVT_RTZ_XU_F_W;
class MipsInst_VFNCVT_RTZ_XU_F_W<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFNCVT_RTZ_XU_F_W {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFNCVT_RTZ_XU_F_W{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFNCVT_RTZ_XU_F_W : MipsInst_VFNCVT_RTZ_XU_F_W <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFNCVT_RTZ_XU_F_W {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VFNCVT_RTZ_XU_F_W<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfncvt.rtz.xu.f.w	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VFNCVT_RTZ_XU_F_W<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFNCVT_RTZ_XU_F_W ;
class FEXUPR_W_DESC_VFNCVT_RTZ_XU_F_W : MSA_2RF_DESC_BASE_VFNCVT_RTZ_XU_F_W <"fexupr.w", null_frag, ?, ?>;
class FEXUPR_W_ENC_VFNCVT_RTZ_XU_F_W : MSA_2RF_FMT_VFNCVT_RTZ_XU_F_W <0b110011001, 0b0, 0b011110>;
def VFNCVT_RTZ_XU_F_W : FEXUPR_W_ENC_VFNCVT_RTZ_XU_F_W , FEXUPR_W_DESC_VFNCVT_RTZ_XU_F_W , VFNCVT_RTZ_XU_F_W_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFNCVT_RTZ_X_F_W;
class MipsInst_VFNCVT_RTZ_X_F_W<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFNCVT_RTZ_X_F_W {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFNCVT_RTZ_X_F_W{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFNCVT_RTZ_X_F_W : MipsInst_VFNCVT_RTZ_X_F_W <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFNCVT_RTZ_X_F_W {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFNCVT_RTZ_X_F_W<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFNCVT_RTZ_X_F_W ;
class MSA_2RF_DESC_BASE_VFNCVT_RTZ_X_F_W<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfncvt.rtz.x.f.w	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FFQR_W_ENC_VFNCVT_RTZ_X_F_W : MSA_2RF_FMT_VFNCVT_RTZ_X_F_W <0b110011011, 0b0, 0b011110>;
class FFQR_W_DESC_VFNCVT_RTZ_X_F_W : MSA_2RF_DESC_BASE_VFNCVT_RTZ_X_F_W <"ffqr.w", null_frag, ?, ?>;
def VFNCVT_RTZ_X_F_W : FFQR_W_ENC_VFNCVT_RTZ_X_F_W , FFQR_W_DESC_VFNCVT_RTZ_X_F_W , VFNCVT_RTZ_X_F_W_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFNCVT_F_X_W;
class MipsInst_VFNCVT_F_X_W<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFNCVT_F_X_W {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFNCVT_F_X_W{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFNCVT_F_X_W : MipsInst_VFNCVT_F_X_W <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFNCVT_F_X_W {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VFNCVT_F_X_W<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfncvt.f.x.w	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VFNCVT_F_X_W<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFNCVT_F_X_W ;
class FFINT_S_W_DESC_VFNCVT_F_X_W : MSA_2RF_DESC_BASE_VFNCVT_F_X_W <"ffint_s.w", null_frag, ?>;
class FFINT_S_W_ENC_VFNCVT_F_X_W : MSA_2RF_FMT_VFNCVT_F_X_W <0b110011110, 0b0, 0b011110>;
def VFNCVT_F_X_W : FFINT_S_W_ENC_VFNCVT_F_X_W , FFINT_S_W_DESC_VFNCVT_F_X_W , VFNCVT_F_X_W_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFNCVT_ROD_F_F_W;
class MipsInst_VFNCVT_ROD_F_F_W<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFNCVT_ROD_F_F_W {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFNCVT_ROD_F_F_W{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFNCVT_ROD_F_F_W : MipsInst_VFNCVT_ROD_F_F_W <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFNCVT_ROD_F_F_W {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFNCVT_ROD_F_F_W<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFNCVT_ROD_F_F_W ;
class MSA_2RF_DESC_BASE_VFNCVT_ROD_F_F_W<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfncvt.rod.f.f.w	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FFQR_W_ENC_VFNCVT_ROD_F_F_W : MSA_2RF_FMT_VFNCVT_ROD_F_F_W <0b110011011, 0b0, 0b011110>;
class FFQR_W_DESC_VFNCVT_ROD_F_F_W : MSA_2RF_DESC_BASE_VFNCVT_ROD_F_F_W <"ffqr.w", null_frag, ?, ?>;
def VFNCVT_ROD_F_F_W : FFQR_W_ENC_VFNCVT_ROD_F_F_W , FFQR_W_DESC_VFNCVT_ROD_F_F_W , VFNCVT_ROD_F_F_W_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWCVT_F_XU_V;
class MipsInst_VFWCVT_F_XU_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWCVT_F_XU_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWCVT_F_XU_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWCVT_F_XU_V : MipsInst_VFWCVT_F_XU_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWCVT_F_XU_V {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFWCVT_F_XU_V<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWCVT_F_XU_V ;
class MSA_2RF_DESC_BASE_VFWCVT_F_XU_V<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfwcvt.f.xu.v	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FFQR_W_ENC_VFWCVT_F_XU_V : MSA_2RF_FMT_VFWCVT_F_XU_V <0b110011011, 0b0, 0b011110>;
class FFQR_W_DESC_VFWCVT_F_XU_V : MSA_2RF_DESC_BASE_VFWCVT_F_XU_V <"ffqr.w", null_frag, ?, ?>;
def VFWCVT_F_XU_V : FFQR_W_ENC_VFWCVT_F_XU_V , FFQR_W_DESC_VFWCVT_F_XU_V , VFWCVT_F_XU_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFCVT_F_XU_V;
class MipsInst_VFCVT_F_XU_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFCVT_F_XU_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFCVT_F_XU_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFCVT_F_XU_V : MipsInst_VFCVT_F_XU_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFCVT_F_XU_V {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFCVT_F_XU_V<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFCVT_F_XU_V ;
class MSA_2RF_DESC_BASE_VFCVT_F_XU_V<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfcvt.f.xu.v	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FFQR_W_ENC_VFCVT_F_XU_V : MSA_2RF_FMT_VFCVT_F_XU_V <0b110011011, 0b0, 0b011110>;
class FFQR_W_DESC_VFCVT_F_XU_V : MSA_2RF_DESC_BASE_VFCVT_F_XU_V <"ffqr.w", null_frag, ?, ?>;
def VFCVT_F_XU_V : FFQR_W_ENC_VFCVT_F_XU_V , FFQR_W_DESC_VFCVT_F_XU_V , VFCVT_F_XU_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFNCVT_F_XU_W;
class MipsInst_VFNCVT_F_XU_W<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFNCVT_F_XU_W {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFNCVT_F_XU_W{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFNCVT_F_XU_W : MipsInst_VFNCVT_F_XU_W <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFNCVT_F_XU_W {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VFNCVT_F_XU_W<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfncvt.f.xu.w	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VFNCVT_F_XU_W<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFNCVT_F_XU_W ;
class FEXUPR_W_DESC_VFNCVT_F_XU_W : MSA_2RF_DESC_BASE_VFNCVT_F_XU_W <"fexupr.w", null_frag, ?, ?>;
class FEXUPR_W_ENC_VFNCVT_F_XU_W : MSA_2RF_FMT_VFNCVT_F_XU_W <0b110011001, 0b0, 0b011110>;
def VFNCVT_F_XU_W : FEXUPR_W_ENC_VFNCVT_F_XU_W , FEXUPR_W_DESC_VFNCVT_F_XU_W , VFNCVT_F_XU_W_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFNCVT_F_F_W;
class MipsInst_VFNCVT_F_F_W<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFNCVT_F_F_W {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFNCVT_F_F_W{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFNCVT_F_F_W : MipsInst_VFNCVT_F_F_W <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFNCVT_F_F_W {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VFNCVT_F_F_W<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfncvt.f.f.w	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VFNCVT_F_F_W<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFNCVT_F_F_W ;
class FEXUPL_W_DESC_VFNCVT_F_F_W : MSA_2RF_DESC_BASE_VFNCVT_F_F_W <"fexupl.w", null_frag, ?, ?>;
class FEXUPL_W_ENC_VFNCVT_F_F_W : MSA_2RF_FMT_VFNCVT_F_F_W <0b110011000, 0b0, 0b011110>;
def VFNCVT_F_F_W : FEXUPL_W_ENC_VFNCVT_F_F_W , FEXUPL_W_DESC_VFNCVT_F_F_W , VFNCVT_F_F_W_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFMACC_VF;
class MipsInst_VFMACC_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFMACC_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFMACC_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFMACC_VF : MipsInst_VFMACC_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFMACC_VF {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFMACC_VF<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFMACC_VF ;
class MSA_2RF_DESC_BASE_VFMACC_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins FPR32:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfmacc.vf	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FRINT_W_ENC_VFMACC_VF : MSA_2RF_FMT_VFMACC_VF <0b110010110, 0b0, 0b011110>;
class FRINT_W_DESC_VFMACC_VF : MSA_2RF_DESC_BASE_VFMACC_VF <"frint.w", null_frag, ?>;
def VFMACC_VF : FRINT_W_ENC_VFMACC_VF , FRINT_W_DESC_VFMACC_VF , VFMACC_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFNMACC_VF;
class MipsInst_VFNMACC_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFNMACC_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFNMACC_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFNMACC_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins FPR32:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfnmacc.vf	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VFNMACC_VF : MipsInst_VFNMACC_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFNMACC_VF {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VFNMACC_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VFNMACC_VF <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VFNMACC_VF<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFNMACC_VF ;
class FSUB_W_DESC_VFNMACC_VF : MSA_3RF_DESC_BASE_VFNMACC_VF <"fsub.w", null_frag, ?>;
class FSUB_W_ENC_VFNMACC_VF : MSA_3RF_FMT_VFNMACC_VF <0b0001, 0b0, 0b011011>;
def VFNMACC_VF : FSUB_W_ENC_VFNMACC_VF , FSUB_W_DESC_VFNMACC_VF , VFNMACC_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFMADD_VF;
class MipsInst_VFMADD_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFMADD_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFMADD_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFMADD_VF : MipsInst_VFMADD_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFMADD_VF {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFMADD_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins FPR32:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfmadd.vf	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VFMADD_VF<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFMADD_VF ;
class MSA_3RF_DESC_BASE_VFMADD_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VFMADD_VF <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FEXP2_W_ENC_VFMADD_VF : MSA_3RF_FMT_VFMADD_VF <0b0111, 0b0, 0b011011>;
class FEXP2_W_DESC_VFMADD_VF : MSA_3RF_DESC_BASE_VFMADD_VF <"fexp2.w", null_frag, ?>;
def VFMADD_VF : FEXP2_W_ENC_VFMADD_VF , FEXP2_W_DESC_VFMADD_VF , VFMADD_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFNMADD_VF;
class MipsInst_VFNMADD_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFNMADD_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFNMADD_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFNMADD_VF : MipsInst_VFNMADD_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFNMADD_VF {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VFNMADD_VF<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFNMADD_VF ;
class MSA_3R_DESC_BASE_VFNMADD_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins FPR32:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfnmadd.vf	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VFNMADD_VF{
	bit  isCommutable=false;
}
class AVE_U_W_ENC_VFNMADD_VF : MSA_3R_FMT_VFNMADD_VF <0b101, 0b10, 0b010000>;
class AVE_U_W_DESC_VFNMADD_VF : MSA_3R_DESC_BASE_VFNMADD_VF <"ave_u.w", null_frag, ?>, IsCommutable_VFNMADD_VF ;
def VFNMADD_VF : AVE_U_W_ENC_VFNMADD_VF , AVE_U_W_DESC_VFNMADD_VF , VFNMADD_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWMACC_VF;
class MipsInst_VFWMACC_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWMACC_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWMACC_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWMACC_VF : MipsInst_VFWMACC_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWMACC_VF {
	let  EncodingPredicates=[];
}
class MSA_3R_4R_DESC_BASE_VFWMACC_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins FPR32:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfwmacc.vf	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="@earlyclobber $vd";
}
class MSA_3RF_FMT_VFWMACC_VF<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWMACC_VF ;
class MSA_3RF_4RF_DESC_BASE_VFWMACC_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_4R_DESC_BASE_VFWMACC_VF <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FMSUB_D_ENC_VFWMACC_VF : MSA_3RF_FMT_VFWMACC_VF <0b0101, 0b1, 0b011011>;
class FMSUB_D_DESC_VFWMACC_VF : MSA_3RF_4RF_DESC_BASE_VFWMACC_VF <"fmsub.d", null_frag, ?>;
def VFWMACC_VF : FMSUB_D_ENC_VFWMACC_VF , FMSUB_D_DESC_VFWMACC_VF , VFWMACC_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWNMACC_VF;
class MipsInst_VFWNMACC_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWNMACC_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWNMACC_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWNMACC_VF : MipsInst_VFWNMACC_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWNMACC_VF {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFWNMACC_VF<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWNMACC_VF ;
class MSA_2RF_DESC_BASE_VFWNMACC_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins FPR32:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfwnmacc.vf	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FRINT_D_ENC_VFWNMACC_VF : MSA_2RF_FMT_VFWNMACC_VF <0b110010110, 0b1, 0b011110>;
class FRINT_D_DESC_VFWNMACC_VF : MSA_2RF_DESC_BASE_VFWNMACC_VF <"frint.d", null_frag, ?>;
def VFWNMACC_VF : FRINT_D_ENC_VFWNMACC_VF , FRINT_D_DESC_VFWNMACC_VF , VFWNMACC_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFMACC_VV;
class MipsInst_VFMACC_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFMACC_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFMACC_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFMACC_VV : MipsInst_VFMACC_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFMACC_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VFMACC_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFMACC_VV ;
class MSA_3R_DESC_BASE_VFMACC_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfmacc.vv	$vd, $vs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VFMACC_VV{
	bit  isCommutable=false;
}
class AVE_U_W_ENC_VFMACC_VV : MSA_3R_FMT_VFMACC_VV <0b101, 0b10, 0b010000>;
class AVE_U_W_DESC_VFMACC_VV : MSA_3R_DESC_BASE_VFMACC_VV <"ave_u.w", null_frag, ?>, IsCommutable_VFMACC_VV ;
def VFMACC_VV : AVE_U_W_ENC_VFMACC_VV , AVE_U_W_DESC_VFMACC_VV , VFMACC_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFNMACC_VV;
class MipsInst_VFNMACC_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFNMACC_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFNMACC_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFNMACC_VV : MipsInst_VFNMACC_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFNMACC_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VFNMACC_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFNMACC_VV ;
class MSA_3R_DESC_BASE_VFNMACC_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfnmacc.vv	$vd, $vs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VFNMACC_VV{
	bit  isCommutable=false;
}
class AVE_U_W_ENC_VFNMACC_VV : MSA_3R_FMT_VFNMACC_VV <0b101, 0b10, 0b010000>;
class AVE_U_W_DESC_VFNMACC_VV : MSA_3R_DESC_BASE_VFNMACC_VV <"ave_u.w", null_frag, ?>, IsCommutable_VFNMACC_VV ;
def VFNMACC_VV : AVE_U_W_ENC_VFNMACC_VV , AVE_U_W_DESC_VFNMACC_VV , VFNMACC_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFMADD_VV;
class MipsInst_VFMADD_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFMADD_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFMADD_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFMADD_VV : MipsInst_VFMADD_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFMADD_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VFMADD_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFMADD_VV ;
class MSA_3R_DESC_BASE_VFMADD_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfmadd.vv	$vd, $vs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VFMADD_VV{
	bit  isCommutable=false;
}
class DOTP_S_W_ENC_VFMADD_VV : MSA_3R_FMT_VFMADD_VV <0b000, 0b10, 0b010011>;
class DOTP_S_W_DESC_VFMADD_VV : MSA_3R_DESC_BASE_VFMADD_VV <"dotp_s.w", null_frag, ?, ?, ?>, IsCommutable_VFMADD_VV ;
def VFMADD_VV : DOTP_S_W_ENC_VFMADD_VV , DOTP_S_W_DESC_VFMADD_VV , VFMADD_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFNMADD_VV;
class MipsInst_VFNMADD_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFNMADD_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFNMADD_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFNMADD_VV : MipsInst_VFNMADD_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFNMADD_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VFNMADD_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFNMADD_VV ;
class MSA_3R_4R_DESC_BASE_VFNMADD_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfnmadd.vv	$vd, $vs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="";
}
class DPSUB_S_W_ENC_VFNMADD_VV : MSA_3R_FMT_VFNMADD_VV <0b100, 0b10, 0b010011>;
class DPSUB_S_W_DESC_VFNMADD_VV : MSA_3R_4R_DESC_BASE_VFNMADD_VV <"dpsub_s.w", null_frag, ?, ?, ?>;
def VFNMADD_VV : DPSUB_S_W_ENC_VFNMADD_VV , DPSUB_S_W_DESC_VFNMADD_VV , VFNMADD_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWMACC_VV;
class MipsInst_VFWMACC_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWMACC_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWMACC_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWMACC_VV : MipsInst_VFWMACC_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWMACC_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_4R_DESC_BASE_VFWMACC_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfwmacc.vv	$vd, $vs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="@earlyclobber $vd";
}
class MSA_3R_FMT_VFWMACC_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFWMACC_VV ;
class MSUBV_D_DESC_VFWMACC_VV : MSA_3R_4R_DESC_BASE_VFWMACC_VV <"msubv.d", null_frag, ?>;
class MSUBV_D_ENC_VFWMACC_VV : MSA_3R_FMT_VFWMACC_VV <0b010, 0b11, 0b010010>;
def VFWMACC_VV : MSUBV_D_ENC_VFWMACC_VV , MSUBV_D_DESC_VFWMACC_VV , VFWMACC_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWNMACC_VV;
class MipsInst_VFWNMACC_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWNMACC_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWNMACC_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWNMACC_VV : MipsInst_VFWNMACC_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWNMACC_VV {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFWNMACC_VV<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWNMACC_VV ;
class MSA_2RF_DESC_BASE_VFWNMACC_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfwnmacc.vv	$vd, $vs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FSQRT_D_ENC_VFWNMACC_VV : MSA_2RF_FMT_VFWNMACC_VV <0b110010011, 0b1, 0b011110>;
class FSQRT_D_DESC_VFWNMACC_VV : MSA_2RF_DESC_BASE_VFWNMACC_VV <"fsqrt.d", null_frag, ?>;
def VFWNMACC_VV : FSQRT_D_ENC_VFWNMACC_VV , FSQRT_D_DESC_VFWNMACC_VV , VFWNMACC_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFMAX_VF;
class MipsInst_VFMAX_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFMAX_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFMAX_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFMAX_VF : MipsInst_VFMAX_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFMAX_VF {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VFMAX_VF<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFMAX_VF ;
class MSA_3R_DESC_BASE_VFMAX_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vfmax.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MIN_U_W_ENC_VFMAX_VF : MSA_3R_FMT_VFMAX_VF <0b101, 0b10, 0b001110>;
class MIN_U_W_DESC_VFMAX_VF : MSA_3R_DESC_BASE_VFMAX_VF <"min_u.w", null_frag, ?>;
def VFMAX_VF : MIN_U_W_ENC_VFMAX_VF , MIN_U_W_DESC_VFMAX_VF , VFMAX_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFMAX_VV;
class MipsInst_VFMAX_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFMAX_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFMAX_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFMAX_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vfmax.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VFMAX_VV : MipsInst_VFMAX_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFMAX_VV {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VFMAX_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VFMAX_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VFMAX_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFMAX_VV ;
class FMIN_W_DESC_VFMAX_VV : MSA_3RF_DESC_BASE_VFMAX_VV <"fmin.w", null_frag, ?>;
class FMIN_W_ENC_VFMAX_VV : MSA_3RF_FMT_VFMAX_VV <0b1100, 0b0, 0b011011>;
def VFMAX_VV : FMIN_W_ENC_VFMAX_VV , FMIN_W_DESC_VFMAX_VV , VFMAX_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFMIN_VF;
class MipsInst_VFMIN_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFMIN_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFMIN_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFMIN_VF : MipsInst_VFMIN_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFMIN_VF {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFMIN_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vfmin.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VFMIN_VF<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFMIN_VF ;
class MSA_3RF_DESC_BASE_VFMIN_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VFMIN_VF <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FSNE_W_ENC_VFMIN_VF : MSA_3RF_FMT_VFMIN_VF <0b1011, 0b0, 0b011100>;
class FSNE_W_DESC_VFMIN_VF : MSA_3RF_DESC_BASE_VFMIN_VF <"fsne.w", null_frag, ?>;
def VFMIN_VF : FSNE_W_ENC_VFMIN_VF , FSNE_W_DESC_VFMIN_VF , VFMIN_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFMIN_VV;
class MipsInst_VFMIN_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFMIN_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFMIN_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFMIN_VV : MipsInst_VFMIN_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFMIN_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFMIN_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vfmin.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VFMIN_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFMIN_VV ;
class MSA_3RF_DESC_BASE_VFMIN_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VFMIN_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FSNE_W_ENC_VFMIN_VV : MSA_3RF_FMT_VFMIN_VV <0b1011, 0b0, 0b011100>;
class FSNE_W_DESC_VFMIN_VV : MSA_3RF_DESC_BASE_VFMIN_VV <"fsne.w", null_frag, ?>;
def VFMIN_VV : FSNE_W_ENC_VFMIN_VV , FSNE_W_DESC_VFMIN_VV , VFMIN_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFMSAC_VF;
class MipsInst_VFMSAC_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFMSAC_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFMSAC_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFMSAC_VF : MipsInst_VFMSAC_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFMSAC_VF {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFMSAC_VF<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFMSAC_VF ;
class MSA_2RF_DESC_BASE_VFMSAC_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins FPR32:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfmsac.vf	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FRCP_W_ENC_VFMSAC_VF : MSA_2RF_FMT_VFMSAC_VF <0b110010101, 0b0, 0b011110>;
class FRCP_W_DESC_VFMSAC_VF : MSA_2RF_DESC_BASE_VFMSAC_VF <"frcp.w", null_frag, ?>;
def VFMSAC_VF : FRCP_W_ENC_VFMSAC_VF , FRCP_W_DESC_VFMSAC_VF , VFMSAC_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFNMSAC_VF;
class MipsInst_VFNMSAC_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFNMSAC_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFNMSAC_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFNMSAC_VF : MipsInst_VFNMSAC_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFNMSAC_VF {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFNMSAC_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins FPR32:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfnmsac.vf	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VFNMSAC_VF<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFNMSAC_VF ;
class MSA_3RF_DESC_BASE_VFNMSAC_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VFNMSAC_VF <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FEXP2_W_ENC_VFNMSAC_VF : MSA_3RF_FMT_VFNMSAC_VF <0b0111, 0b0, 0b011011>;
class FEXP2_W_DESC_VFNMSAC_VF : MSA_3RF_DESC_BASE_VFNMSAC_VF <"fexp2.w", null_frag, ?>;
def VFNMSAC_VF : FEXP2_W_ENC_VFNMSAC_VF , FEXP2_W_DESC_VFNMSAC_VF , VFNMSAC_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFMSUB_VF;
class MipsInst_VFMSUB_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFMSUB_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFMSUB_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFMSUB_VF : MipsInst_VFMSUB_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFMSUB_VF {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFMSUB_VF<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFMSUB_VF ;
class MSA_2RF_DESC_BASE_VFMSUB_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins FPR32:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfmsub.vf	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FRINT_W_ENC_VFMSUB_VF : MSA_2RF_FMT_VFMSUB_VF <0b110010110, 0b0, 0b011110>;
class FRINT_W_DESC_VFMSUB_VF : MSA_2RF_DESC_BASE_VFMSUB_VF <"frint.w", null_frag, ?>;
def VFMSUB_VF : FRINT_W_ENC_VFMSUB_VF , FRINT_W_DESC_VFMSUB_VF , VFMSUB_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFNMSUB_VF;
class MipsInst_VFNMSUB_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFNMSUB_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFNMSUB_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFNMSUB_VF : MipsInst_VFNMSUB_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFNMSUB_VF {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VFNMSUB_VF<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFNMSUB_VF ;
class MSA_3R_4R_DESC_BASE_VFNMSUB_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins FPR32:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfnmsub.vf	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="";
}
class DPSUB_S_W_ENC_VFNMSUB_VF : MSA_3R_FMT_VFNMSUB_VF <0b100, 0b10, 0b010011>;
class DPSUB_S_W_DESC_VFNMSUB_VF : MSA_3R_4R_DESC_BASE_VFNMSUB_VF <"dpsub_s.w", null_frag, ?, ?, ?>;
def VFNMSUB_VF : DPSUB_S_W_ENC_VFNMSUB_VF , DPSUB_S_W_DESC_VFNMSUB_VF , VFNMSUB_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWMSAC_VF;
class MipsInst_VFWMSAC_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWMSAC_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWMSAC_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_4R_DESC_BASE_VFWMSAC_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins FPR32:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfwmsac.vf	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="@earlyclobber $vd";
}
class MSAInst_VFWMSAC_VF : MipsInst_VFWMSAC_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWMSAC_VF {
	let  EncodingPredicates=[];
}
class MSA_3RF_4RF_DESC_BASE_VFWMSAC_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_4R_DESC_BASE_VFWMSAC_VF <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VFWMSAC_VF<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWMSAC_VF ;
class FMADD_D_DESC_VFWMSAC_VF : MSA_3RF_4RF_DESC_BASE_VFWMSAC_VF <"fmadd.d", null_frag, ?>;
class FMADD_D_ENC_VFWMSAC_VF : MSA_3RF_FMT_VFWMSAC_VF <0b0100, 0b1, 0b011011>;
def VFWMSAC_VF : FMADD_D_ENC_VFWMSAC_VF , FMADD_D_DESC_VFWMSAC_VF , VFWMSAC_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWNMSAC_VF;
class MipsInst_VFWNMSAC_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWNMSAC_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWNMSAC_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWNMSAC_VF : MipsInst_VFWNMSAC_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWNMSAC_VF {
	let  EncodingPredicates=[];
}
class MSA_3R_4R_DESC_BASE_VFWNMSAC_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins FPR32:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfwnmsac.vf	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="@earlyclobber $vd";
}
class MSA_3RF_FMT_VFWNMSAC_VF<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWNMSAC_VF ;
class MSA_3RF_4RF_DESC_BASE_VFWNMSAC_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_4R_DESC_BASE_VFWNMSAC_VF <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FMSUB_D_ENC_VFWNMSAC_VF : MSA_3RF_FMT_VFWNMSAC_VF <0b0101, 0b1, 0b011011>;
class FMSUB_D_DESC_VFWNMSAC_VF : MSA_3RF_4RF_DESC_BASE_VFWNMSAC_VF <"fmsub.d", null_frag, ?>;
def VFWNMSAC_VF : FMSUB_D_ENC_VFWNMSAC_VF , FMSUB_D_DESC_VFWNMSAC_VF , VFWNMSAC_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFMSAC_VV;
class MipsInst_VFMSAC_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFMSAC_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFMSAC_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFMSAC_VV : MipsInst_VFMSAC_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFMSAC_VV {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VFMSAC_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfmsac.vv	$vd, $vs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VFMSAC_VV<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFMSAC_VV ;
class FRSQRT_W_DESC_VFMSAC_VV : MSA_2RF_DESC_BASE_VFMSAC_VV <"frsqrt.w", null_frag, ?>;
class FRSQRT_W_ENC_VFMSAC_VV : MSA_2RF_FMT_VFMSAC_VV <0b110010100, 0b0, 0b011110>;
def VFMSAC_VV : FRSQRT_W_ENC_VFMSAC_VV , FRSQRT_W_DESC_VFMSAC_VV , VFMSAC_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFNMSAC_VV;
class MipsInst_VFNMSAC_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFNMSAC_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFNMSAC_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFNMSAC_VV : MipsInst_VFNMSAC_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFNMSAC_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFNMSAC_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfnmsac.vv	$vd, $vs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VFNMSAC_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFNMSAC_VV ;
class SUBSUU_S_W_DESC_VFNMSAC_VV : MSA_3R_DESC_BASE_VFNMSAC_VV <"subsuu_s.w", null_frag, ?>;
class SUBSUU_S_W_ENC_VFNMSAC_VV : MSA_3R_FMT_VFNMSAC_VV <0b011, 0b10, 0b010001>;
def VFNMSAC_VV : SUBSUU_S_W_ENC_VFNMSAC_VV , SUBSUU_S_W_DESC_VFNMSAC_VV , VFNMSAC_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFMSUB_VV;
class MipsInst_VFMSUB_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFMSUB_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFMSUB_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFMSUB_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfmsub.vv	$vd, $vs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VFMSUB_VV : MipsInst_VFMSUB_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFMSUB_VV {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VFMSUB_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VFMSUB_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VFMSUB_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFMSUB_VV ;
class FSUB_W_DESC_VFMSUB_VV : MSA_3RF_DESC_BASE_VFMSUB_VV <"fsub.w", null_frag, ?>;
class FSUB_W_ENC_VFMSUB_VV : MSA_3RF_FMT_VFMSUB_VV <0b0001, 0b0, 0b011011>;
def VFMSUB_VV : FSUB_W_ENC_VFMSUB_VV , FSUB_W_DESC_VFMSUB_VV , VFMSUB_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFNMSUB_VV;
class MipsInst_VFNMSUB_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFNMSUB_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFNMSUB_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFNMSUB_VV : MipsInst_VFNMSUB_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFNMSUB_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VFNMSUB_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFNMSUB_VV ;
class MSA_3R_DESC_BASE_VFNMSUB_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfnmsub.vv	$vd, $vs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VFNMSUB_VV{
	bit  isCommutable=false;
}
class DOTP_S_W_ENC_VFNMSUB_VV : MSA_3R_FMT_VFNMSUB_VV <0b000, 0b10, 0b010011>;
class DOTP_S_W_DESC_VFNMSUB_VV : MSA_3R_DESC_BASE_VFNMSUB_VV <"dotp_s.w", null_frag, ?, ?, ?>, IsCommutable_VFNMSUB_VV ;
def VFNMSUB_VV : DOTP_S_W_ENC_VFNMSUB_VV , DOTP_S_W_DESC_VFNMSUB_VV , VFNMSUB_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWMSAC_VV;
class MipsInst_VFWMSAC_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWMSAC_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWMSAC_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWMSAC_VV : MipsInst_VFWMSAC_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWMSAC_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFWMSAC_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfwmsac.vv	$vd, $vs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VFWMSAC_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFWMSAC_VV ;
class SUBS_S_D_DESC_VFWMSAC_VV : MSA_3R_DESC_BASE_VFWMSAC_VV <"subs_s.d", null_frag, ?>;
class SUBS_S_D_ENC_VFWMSAC_VV : MSA_3R_FMT_VFWMSAC_VV <0b000, 0b11, 0b010001>;
def VFWMSAC_VV : SUBS_S_D_ENC_VFWMSAC_VV , SUBS_S_D_DESC_VFWMSAC_VV , VFWMSAC_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWNMSAC_VV;
class MipsInst_VFWNMSAC_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWNMSAC_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWNMSAC_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFWNMSAC_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfwnmsac.vv	$vd, $vs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VFWNMSAC_VV : MipsInst_VFWNMSAC_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWNMSAC_VV {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VFWNMSAC_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VFWNMSAC_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VFWNMSAC_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWNMSAC_VV ;
class FSUB_D_DESC_VFWNMSAC_VV : MSA_3RF_DESC_BASE_VFWNMSAC_VV <"fsub.d", null_frag, ?>;
class FSUB_D_ENC_VFWNMSAC_VV : MSA_3RF_FMT_VFWNMSAC_VV <0b0001, 0b1, 0b011011>;
def VFWNMSAC_VV : FSUB_D_ENC_VFWNMSAC_VV , FSUB_D_DESC_VFWNMSAC_VV , VFWNMSAC_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFMUL_VF;
class MipsInst_VFMUL_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFMUL_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFMUL_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFMUL_VF : MipsInst_VFMUL_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFMUL_VF {
	let  EncodingPredicates=[];
}
class MSA_3R_4R_DESC_BASE_VFMUL_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vfmul.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="";
}
class MSA_3RF_FMT_VFMUL_VF<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFMUL_VF ;
class MSA_3RF_4RF_DESC_BASE_VFMUL_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_4R_DESC_BASE_VFMUL_VF <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FMADD_W_ENC_VFMUL_VF : MSA_3RF_FMT_VFMUL_VF <0b0100, 0b0, 0b011011>;
class FMADD_W_DESC_VFMUL_VF : MSA_3RF_4RF_DESC_BASE_VFMUL_VF <"fmadd.w", null_frag, ?>;
def VFMUL_VF : FMADD_W_ENC_VFMUL_VF , FMADD_W_DESC_VFMUL_VF , VFMUL_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWMUL_VF;
class MipsInst_VFWMUL_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWMUL_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWMUL_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWMUL_VF : MipsInst_VFWMUL_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWMUL_VF {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFWMUL_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vfwmul.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VFWMUL_VF<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWMUL_VF ;
class MSA_3RF_DESC_BASE_VFWMUL_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VFWMUL_VF <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class IsCommutable_VFWMUL_VF{
	bit  isCommutable=false;
}
class FADD_W_ENC_VFWMUL_VF : MSA_3RF_FMT_VFWMUL_VF <0b0000, 0b0, 0b011011>;
class FADD_W_DESC_VFWMUL_VF : MSA_3RF_DESC_BASE_VFWMUL_VF <"fadd.w", null_frag, ?>, IsCommutable_VFWMUL_VF ;
def VFWMUL_VF : FADD_W_ENC_VFWMUL_VF , FADD_W_DESC_VFWMUL_VF , VFWMUL_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFMUL_VV;
class MipsInst_VFMUL_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFMUL_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFMUL_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFMUL_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vfmul.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VFMUL_VV : MipsInst_VFMUL_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFMUL_VV {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VFMUL_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VFMUL_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VFMUL_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFMUL_VV ;
class FSUB_W_DESC_VFMUL_VV : MSA_3RF_DESC_BASE_VFMUL_VV <"fsub.w", null_frag, ?>;
class FSUB_W_ENC_VFMUL_VV : MSA_3RF_FMT_VFMUL_VV <0b0001, 0b0, 0b011011>;
def VFMUL_VV : FSUB_W_ENC_VFMUL_VV , FSUB_W_DESC_VFMUL_VV , VFMUL_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWMUL_VV;
class MipsInst_VFWMUL_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWMUL_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWMUL_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFWMUL_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vfwmul.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VFWMUL_VV : MipsInst_VFWMUL_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWMUL_VV {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VFWMUL_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VFWMUL_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VFWMUL_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWMUL_VV ;
class FSUB_W_DESC_VFWMUL_VV : MSA_3RF_DESC_BASE_VFWMUL_VV <"fsub.w", null_frag, ?>;
class FSUB_W_ENC_VFWMUL_VV : MSA_3RF_FMT_VFWMUL_VV <0b0001, 0b0, 0b011011>;
def VFWMUL_VV : FSUB_W_ENC_VFWMUL_VV , FSUB_W_DESC_VFWMUL_VV , VFWMUL_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFREC7_V;
class MipsInst_VFREC7_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFREC7_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFREC7_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFREC7_V : MipsInst_VFREC7_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFREC7_V {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VFREC7_V<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfrec7.v	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VFREC7_V<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFREC7_V ;
class FRSQRT_W_DESC_VFREC7_V : MSA_2RF_DESC_BASE_VFREC7_V <"frsqrt.w", null_frag, ?>;
class FRSQRT_W_ENC_VFREC7_V : MSA_2RF_FMT_VFREC7_V <0b110010100, 0b0, 0b011110>;
def VFREC7_V : FRSQRT_W_ENC_VFREC7_V , FRSQRT_W_DESC_VFREC7_V , VFREC7_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFRSQRT7_V;
class MipsInst_VFRSQRT7_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFRSQRT7_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFRSQRT7_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFRSQRT7_V : MipsInst_VFRSQRT7_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFRSQRT7_V {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VFRSQRT7_V<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfrsqrt7.v	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VFRSQRT7_V<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFRSQRT7_V ;
class FRSQRT_W_DESC_VFRSQRT7_V : MSA_2RF_DESC_BASE_VFRSQRT7_V <"frsqrt.w", null_frag, ?>;
class FRSQRT_W_ENC_VFRSQRT7_V : MSA_2RF_FMT_VFRSQRT7_V <0b110010100, 0b0, 0b011110>;
def VFRSQRT7_V : FRSQRT_W_ENC_VFRSQRT7_V , FRSQRT_W_DESC_VFRSQRT7_V , VFRSQRT7_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFSQRT_V;
class MipsInst_VFSQRT_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFSQRT_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFSQRT_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFSQRT_V<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfsqrt.v	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VFSQRT_V : MipsInst_VFSQRT_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFSQRT_V {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VFSQRT_V<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VFSQRT_V <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VFSQRT_V<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFSQRT_V ;
class FDIV_W_DESC_VFSQRT_V : MSA_3RF_DESC_BASE_VFSQRT_V <"fdiv.w", null_frag, ?>;
class FDIV_W_ENC_VFSQRT_V : MSA_3RF_FMT_VFSQRT_V <0b0011, 0b0, 0b011011>;
def VFSQRT_V : FDIV_W_ENC_VFSQRT_V , FDIV_W_DESC_VFSQRT_V , VFSQRT_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFSUB_VF;
class MipsInst_VFSUB_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFSUB_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFSUB_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFSUB_VF : MipsInst_VFSUB_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFSUB_VF {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VFSUB_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vfsub.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VFSUB_VF<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFSUB_VF ;
class FRSQRT_W_DESC_VFSUB_VF : MSA_2RF_DESC_BASE_VFSUB_VF <"frsqrt.w", null_frag, ?>;
class FRSQRT_W_ENC_VFSUB_VF : MSA_2RF_FMT_VFSUB_VF <0b110010100, 0b0, 0b011110>;
def VFSUB_VF : FRSQRT_W_ENC_VFSUB_VF , FRSQRT_W_DESC_VFSUB_VF , VFSUB_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWSUB_VF;
class MipsInst_VFWSUB_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWSUB_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWSUB_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWSUB_VF : MipsInst_VFWSUB_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWSUB_VF {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFWSUB_VF<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWSUB_VF ;
class MSA_2RF_DESC_BASE_VFWSUB_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vfwsub.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FRCP_D_ENC_VFWSUB_VF : MSA_2RF_FMT_VFWSUB_VF <0b110010101, 0b1, 0b011110>;
class FRCP_D_DESC_VFWSUB_VF : MSA_2RF_DESC_BASE_VFWSUB_VF <"frcp.d", null_frag, ?>;
def VFWSUB_VF : FRCP_D_ENC_VFWSUB_VF , FRCP_D_DESC_VFWSUB_VF , VFWSUB_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWSUB_WF;
class MipsInst_VFWSUB_WF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWSUB_WF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWSUB_WF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWSUB_WF : MipsInst_VFWSUB_WF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWSUB_WF {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VFWSUB_WF<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFWSUB_WF ;
class MSA_3R_DESC_BASE_VFWSUB_WF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vfwsub.wf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MOD_U_D_ENC_VFWSUB_WF : MSA_3R_FMT_VFWSUB_WF <0b111, 0b11, 0b010010>;
class MOD_U_D_DESC_VFWSUB_WF : MSA_3R_DESC_BASE_VFWSUB_WF <"mod_u.d", null_frag, ?>;
def VFWSUB_WF : MOD_U_D_ENC_VFWSUB_WF , MOD_U_D_DESC_VFWSUB_WF , VFWSUB_WF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFSUB_VV;
class MipsInst_VFSUB_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFSUB_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFSUB_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFSUB_VV : MipsInst_VFSUB_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFSUB_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFSUB_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vfsub.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VFSUB_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFSUB_VV ;
class MSA_3RF_DESC_BASE_VFSUB_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VFSUB_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class IsCommutable_VFSUB_VV{
	bit  isCommutable=false;
}
class FADD_W_ENC_VFSUB_VV : MSA_3RF_FMT_VFSUB_VV <0b0000, 0b0, 0b011011>;
class FADD_W_DESC_VFSUB_VV : MSA_3RF_DESC_BASE_VFSUB_VV <"fadd.w", null_frag, ?>, IsCommutable_VFSUB_VV ;
def VFSUB_VV : FADD_W_ENC_VFSUB_VV , FADD_W_DESC_VFSUB_VV , VFSUB_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFRSUB_VF;
class MipsInst_VFRSUB_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFRSUB_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFRSUB_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFRSUB_VF : MipsInst_VFRSUB_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFRSUB_VF {
	let  EncodingPredicates=[];
}
class MSA_3R_4R_DESC_BASE_VFRSUB_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vfrsub.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="";
}
class MSA_3RF_FMT_VFRSUB_VF<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFRSUB_VF ;
class MSA_3RF_4RF_DESC_BASE_VFRSUB_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_4R_DESC_BASE_VFRSUB_VF <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MADDR_Q_W_ENC_VFRSUB_VF : MSA_3RF_FMT_VFRSUB_VF <0b1101, 0b1, 0b011100>;
class MADDR_Q_W_DESC_VFRSUB_VF : MSA_3RF_4RF_DESC_BASE_VFRSUB_VF <"maddr_q.w", null_frag, ?>;
def VFRSUB_VF : MADDR_Q_W_ENC_VFRSUB_VF , MADDR_Q_W_DESC_VFRSUB_VF , VFRSUB_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWSUB_VV;
class MipsInst_VFWSUB_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWSUB_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWSUB_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWSUB_VV : MipsInst_VFWSUB_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWSUB_VV {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFWSUB_VV<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWSUB_VV ;
class MSA_2RF_DESC_BASE_VFWSUB_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vfwsub.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FSQRT_D_ENC_VFWSUB_VV : MSA_2RF_FMT_VFWSUB_VV <0b110010011, 0b1, 0b011110>;
class FSQRT_D_DESC_VFWSUB_VV : MSA_2RF_DESC_BASE_VFWSUB_VV <"fsqrt.d", null_frag, ?>;
def VFWSUB_VV : FSQRT_D_ENC_VFWSUB_VV , FSQRT_D_DESC_VFWSUB_VV , VFWSUB_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWSUB_WV;
class MipsInst_VFWSUB_WV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWSUB_WV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWSUB_WV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWSUB_WV : MipsInst_VFWSUB_WV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWSUB_WV {
	let  EncodingPredicates=[];
}
class MSA_3R_4R_DESC_BASE_VFWSUB_WV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vfwsub.wv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="@earlyclobber $vd";
}
class MSA_3RF_FMT_VFWSUB_WV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWSUB_WV ;
class MSA_3RF_4RF_DESC_BASE_VFWSUB_WV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_4R_DESC_BASE_VFWSUB_WV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FMSUB_D_ENC_VFWSUB_WV : MSA_3RF_FMT_VFWSUB_WV <0b0101, 0b1, 0b011011>;
class FMSUB_D_DESC_VFWSUB_WV : MSA_3RF_4RF_DESC_BASE_VFWSUB_WV <"fmsub.d", null_frag, ?>;
def VFWSUB_WV : FMSUB_D_ENC_VFWSUB_WV , FMSUB_D_DESC_VFWSUB_WV , VFWSUB_WV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWCVT_X_F_V;
class MipsInst_VFWCVT_X_F_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWCVT_X_F_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWCVT_X_F_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWCVT_X_F_V : MipsInst_VFWCVT_X_F_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWCVT_X_F_V {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFWCVT_X_F_V<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWCVT_X_F_V ;
class MSA_2RF_DESC_BASE_VFWCVT_X_F_V<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfwcvt.x.f.v	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FTRUNC_S_W_ENC_VFWCVT_X_F_V : MSA_2RF_FMT_VFWCVT_X_F_V <0b110010001, 0b0, 0b011110>;
class FTRUNC_S_W_DESC_VFWCVT_X_F_V : MSA_2RF_DESC_BASE_VFWCVT_X_F_V <"ftrunc_s.w", null_frag, ?>;
def VFWCVT_X_F_V : FTRUNC_S_W_ENC_VFWCVT_X_F_V , FTRUNC_S_W_DESC_VFWCVT_X_F_V , VFWCVT_X_F_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFCVT_X_F_V;
class MipsInst_VFCVT_X_F_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFCVT_X_F_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFCVT_X_F_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFCVT_X_F_V : MipsInst_VFCVT_X_F_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFCVT_X_F_V {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFCVT_X_F_V<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFCVT_X_F_V ;
class MSA_2RF_DESC_BASE_VFCVT_X_F_V<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfcvt.x.f.v	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FFQR_W_ENC_VFCVT_X_F_V : MSA_2RF_FMT_VFCVT_X_F_V <0b110011011, 0b0, 0b011110>;
class FFQR_W_DESC_VFCVT_X_F_V : MSA_2RF_DESC_BASE_VFCVT_X_F_V <"ffqr.w", null_frag, ?, ?>;
def VFCVT_X_F_V : FFQR_W_ENC_VFCVT_X_F_V , FFQR_W_DESC_VFCVT_X_F_V , VFCVT_X_F_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFNCVT_X_F_W;
class MipsInst_VFNCVT_X_F_W<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFNCVT_X_F_W {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFNCVT_X_F_W{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFNCVT_X_F_W : MipsInst_VFNCVT_X_F_W <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFNCVT_X_F_W {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VFNCVT_X_F_W<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfncvt.x.f.w	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VFNCVT_X_F_W<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFNCVT_X_F_W ;
class FEXUPL_W_DESC_VFNCVT_X_F_W : MSA_2RF_DESC_BASE_VFNCVT_X_F_W <"fexupl.w", null_frag, ?, ?>;
class FEXUPL_W_ENC_VFNCVT_X_F_W : MSA_2RF_FMT_VFNCVT_X_F_W <0b110011000, 0b0, 0b011110>;
def VFNCVT_X_F_W : FEXUPL_W_ENC_VFNCVT_X_F_W , FEXUPL_W_DESC_VFNCVT_X_F_W , VFNCVT_X_F_W_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWCVT_XU_F_V;
class MipsInst_VFWCVT_XU_F_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWCVT_XU_F_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWCVT_XU_F_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWCVT_XU_F_V : MipsInst_VFWCVT_XU_F_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWCVT_XU_F_V {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFWCVT_XU_F_V<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFWCVT_XU_F_V ;
class MSA_2RF_DESC_BASE_VFWCVT_XU_F_V<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfwcvt.xu.f.v	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FTINT_S_W_ENC_VFWCVT_XU_F_V : MSA_2RF_FMT_VFWCVT_XU_F_V <0b110011100, 0b0, 0b011110>;
class FTINT_S_W_DESC_VFWCVT_XU_F_V : MSA_2RF_DESC_BASE_VFWCVT_XU_F_V <"ftint_s.w", null_frag, ?>;
def VFWCVT_XU_F_V : FTINT_S_W_ENC_VFWCVT_XU_F_V , FTINT_S_W_DESC_VFWCVT_XU_F_V , VFWCVT_XU_F_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFCVT_XU_F_V;
class MipsInst_VFCVT_XU_F_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFCVT_XU_F_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFCVT_XU_F_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFCVT_XU_F_V : MipsInst_VFCVT_XU_F_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFCVT_XU_F_V {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VFCVT_XU_F_V<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfcvt.xu.f.v	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VFCVT_XU_F_V<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFCVT_XU_F_V ;
class FEXUPR_W_DESC_VFCVT_XU_F_V : MSA_2RF_DESC_BASE_VFCVT_XU_F_V <"fexupr.w", null_frag, ?, ?>;
class FEXUPR_W_ENC_VFCVT_XU_F_V : MSA_2RF_FMT_VFCVT_XU_F_V <0b110011001, 0b0, 0b011110>;
def VFCVT_XU_F_V : FEXUPR_W_ENC_VFCVT_XU_F_V , FEXUPR_W_DESC_VFCVT_XU_F_V , VFCVT_XU_F_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFNCVT_XU_F_W;
class MipsInst_VFNCVT_XU_F_W<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFNCVT_XU_F_W {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFNCVT_XU_F_W{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFNCVT_XU_F_W : MipsInst_VFNCVT_XU_F_W <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFNCVT_XU_F_W {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFNCVT_XU_F_W<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFNCVT_XU_F_W ;
class MSA_2RF_DESC_BASE_VFNCVT_XU_F_W<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vfncvt.xu.f.w	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FTRUNC_S_W_ENC_VFNCVT_XU_F_W : MSA_2RF_FMT_VFNCVT_XU_F_W <0b110010001, 0b0, 0b011110>;
class FTRUNC_S_W_DESC_VFNCVT_XU_F_W : MSA_2RF_DESC_BASE_VFNCVT_XU_F_W <"ftrunc_s.w", null_frag, ?>;
def VFNCVT_XU_F_W : FTRUNC_S_W_ENC_VFNCVT_XU_F_W , FTRUNC_S_W_DESC_VFNCVT_XU_F_W , VFNCVT_XU_F_W_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VWSUBU_WX;
class MipsInst_VWSUBU_WX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWSUBU_WX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWSUBU_WX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWSUBU_WX : MipsInst_VWSUBU_WX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWSUBU_WX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VWSUBU_WX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWSUBU_WX ;
class MSA_3R_DESC_BASE_VWSUBU_WX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vwsubu.wx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VWSUBU_WX{
	bit  isCommutable=false;
}
class AVER_S_D_ENC_VWSUBU_WX : MSA_3R_FMT_VWSUBU_WX <0b110, 0b11, 0b010000>;
class AVER_S_D_DESC_VWSUBU_WX : MSA_3R_DESC_BASE_VWSUBU_WX <"aver_s.d", null_frag, ?>, IsCommutable_VWSUBU_WX ;
def VWSUBU_WX : AVER_S_D_ENC_VWSUBU_WX , AVER_S_D_DESC_VWSUBU_WX , VWSUBU_WX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWSUBU_VV;
class MipsInst_VWSUBU_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWSUBU_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWSUBU_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWSUBU_VV : MipsInst_VWSUBU_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWSUBU_VV {
	let  EncodingPredicates=[];
}
class IsCommutable_VWSUBU_VV{
	bit  isCommutable=false;
}
class MSA_3R_4R_DESC_BASE_VWSUBU_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vwsubu.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="@earlyclobber $vd";
}
class MSA_3R_FMT_VWSUBU_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWSUBU_VV ;
class DPADD_U_D_DESC_VWSUBU_VV : MSA_3R_4R_DESC_BASE_VWSUBU_VV <"dpadd_u.d", null_frag, ?, ?, ?>, IsCommutable_VWSUBU_VV ;
class DPADD_U_D_ENC_VWSUBU_VV : MSA_3R_FMT_VWSUBU_VV <0b011, 0b11, 0b010011>;
def VWSUBU_VV : DPADD_U_D_ENC_VWSUBU_VV , DPADD_U_D_DESC_VWSUBU_VV , VWSUBU_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWSUBU_VX;
class MipsInst_VWSUBU_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWSUBU_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWSUBU_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWSUBU_VX : MipsInst_VWSUBU_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWSUBU_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VWSUBU_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vwsubu.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VWSUBU_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWSUBU_VX ;
class SUBS_S_D_DESC_VWSUBU_VX : MSA_3R_DESC_BASE_VWSUBU_VX <"subs_s.d", null_frag, ?>;
class SUBS_S_D_ENC_VWSUBU_VX : MSA_3R_FMT_VWSUBU_VX <0b000, 0b11, 0b010001>;
def VWSUBU_VX : SUBS_S_D_ENC_VWSUBU_VX , SUBS_S_D_DESC_VWSUBU_VX , VWSUBU_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLE8_V;
class MipsInst_VLE8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLE8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLE8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLE8_V : MipsInst_VLE8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLE8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLE8_V<bits<2>  df, bits<4>  minor> : MSAInst_VLE8_V ;
class LD_DESC_BASE_VLE8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vle8.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_B_ENC_VLE8_V : MSA_MI10_FMT_VLE8_V <0b00, 0b1000>;
class LD_B_DESC_VLE8_V : LD_DESC_BASE_VLE8_V <"ld.b", null_frag, ?, ?, ?>;
def VLE8_V : LD_B_ENC_VLE8_V , LD_B_DESC_VLE8_V , VLE8_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLE1_V;
class MipsInst_VLE1_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLE1_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLE1_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLE1_V : MipsInst_VLE1_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLE1_V {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VLE1_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1);
	string  AsmString="vle1.v	$vd, (${rs1})";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VLE1_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLE1_V ;
class LDI_W_DESC_VLE1_V : MSA_I10_LDI_DESC_BASE_VLE1_V <"ldi.w", ?>;
class LDI_W_ENC_VLE1_V : MSA_I10_FMT_VLE1_V <0b110, 0b10, 0b000111>;
def VLE1_V : LDI_W_ENC_VLE1_V , LDI_W_DESC_VLE1_V , VLE1_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLSE8_V;
class MipsInst_VLSE8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSE8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSE8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSE8_V : MipsInst_VLSE8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSE8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSE8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSE8_V ;
class MSA_I10_LDI_DESC_BASE_VLSE8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlse8.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLSE8_V : MSA_I10_FMT_VLSE8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLSE8_V : MSA_I10_LDI_DESC_BASE_VLSE8_V <"ldi.b", ?>;
def VLSE8_V : LDI_B_ENC_VLSE8_V , LDI_B_DESC_VLSE8_V , VLSE8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLUXEI8_V;
class MipsInst_VLUXEI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXEI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXEI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXEI8_V : MipsInst_VLUXEI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXEI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLUXEI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXEI8_V ;
class LD_DESC_BASE_VLUXEI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxei8.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_B_ENC_VLUXEI8_V : MSA_MI10_FMT_VLUXEI8_V <0b00, 0b1000>;
class LD_B_DESC_VLUXEI8_V : LD_DESC_BASE_VLUXEI8_V <"ld.b", null_frag, ?, ?, ?>;
def VLUXEI8_V : LD_B_ENC_VLUXEI8_V , LD_B_DESC_VLUXEI8_V , VLUXEI8_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLOXEI8_V;
class MipsInst_VLOXEI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXEI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXEI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXEI8_V : MipsInst_VLOXEI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXEI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLOXEI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXEI8_V ;
class LD_DESC_BASE_VLOXEI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxei8.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_B_ENC_VLOXEI8_V : MSA_MI10_FMT_VLOXEI8_V <0b00, 0b1000>;
class LD_B_DESC_VLOXEI8_V : LD_DESC_BASE_VLOXEI8_V <"ld.b", null_frag, ?, ?, ?>;
def VLOXEI8_V : LD_B_ENC_VLOXEI8_V , LD_B_DESC_VLOXEI8_V , VLOXEI8_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLE8FF_V;
class MipsInst_VLE8FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLE8FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLE8FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLE8FF_V : MipsInst_VLE8FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLE8FF_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLE8FF_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLE8FF_V ;
class MSA_I10_LDI_DESC_BASE_VLE8FF_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vle8ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLE8FF_V : MSA_I10_FMT_VLE8FF_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLE8FF_V : MSA_I10_LDI_DESC_BASE_VLE8FF_V <"ldi.b", ?>;
def VLE8FF_V : LDI_B_ENC_VLE8FF_V , LDI_B_DESC_VLE8FF_V , VLE8FF_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLSEG2E8_V;
class MipsInst_VLSEG2E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG2E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG2E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG2E8_V : MipsInst_VLSEG2E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG2E8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG2E8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG2E8_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG2E8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg2e8.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLSEG2E8_V : MSA_I10_FMT_VLSEG2E8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLSEG2E8_V : MSA_I10_LDI_DESC_BASE_VLSEG2E8_V <"ldi.b", ?>;
def VLSEG2E8_V : LDI_B_ENC_VLSEG2E8_V , LDI_B_DESC_VLSEG2E8_V , VLSEG2E8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG3E8_V;
class MipsInst_VLSEG3E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG3E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG3E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG3E8_V : MipsInst_VLSEG3E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG3E8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG3E8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG3E8_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG3E8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg3e8.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLSEG3E8_V : MSA_I10_FMT_VLSEG3E8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLSEG3E8_V : MSA_I10_LDI_DESC_BASE_VLSEG3E8_V <"ldi.b", ?>;
def VLSEG3E8_V : LDI_B_ENC_VLSEG3E8_V , LDI_B_DESC_VLSEG3E8_V , VLSEG3E8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG4E8_V;
class MipsInst_VLSEG4E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG4E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG4E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG4E8_V : MipsInst_VLSEG4E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG4E8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG4E8_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG4E8_V ;
class LD_DESC_BASE_VLSEG4E8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg4e8.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_B_ENC_VLSEG4E8_V : MSA_MI10_FMT_VLSEG4E8_V <0b00, 0b1000>;
class LD_B_DESC_VLSEG4E8_V : LD_DESC_BASE_VLSEG4E8_V <"ld.b", null_frag, ?, ?, ?>;
def VLSEG4E8_V : LD_B_ENC_VLSEG4E8_V , LD_B_DESC_VLSEG4E8_V , VLSEG4E8_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG5E8_V;
class MipsInst_VLSEG5E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG5E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG5E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG5E8_V : MipsInst_VLSEG5E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG5E8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG5E8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG5E8_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG5E8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg5e8.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLSEG5E8_V : MSA_I10_FMT_VLSEG5E8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLSEG5E8_V : MSA_I10_LDI_DESC_BASE_VLSEG5E8_V <"ldi.b", ?>;
def VLSEG5E8_V : LDI_B_ENC_VLSEG5E8_V , LDI_B_DESC_VLSEG5E8_V , VLSEG5E8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG6E8_V;
class MipsInst_VLSEG6E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG6E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG6E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG6E8_V : MipsInst_VLSEG6E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG6E8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG6E8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG6E8_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG6E8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg6e8.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLSEG6E8_V : MSA_I10_FMT_VLSEG6E8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLSEG6E8_V : MSA_I10_LDI_DESC_BASE_VLSEG6E8_V <"ldi.b", ?>;
def VLSEG6E8_V : LDI_B_ENC_VLSEG6E8_V , LDI_B_DESC_VLSEG6E8_V , VLSEG6E8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG7E8_V;
class MipsInst_VLSEG7E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG7E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG7E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG7E8_V : MipsInst_VLSEG7E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG7E8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG7E8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG7E8_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG7E8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg7e8.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLSEG7E8_V : MSA_I10_FMT_VLSEG7E8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLSEG7E8_V : MSA_I10_LDI_DESC_BASE_VLSEG7E8_V <"ldi.b", ?>;
def VLSEG7E8_V : LDI_B_ENC_VLSEG7E8_V , LDI_B_DESC_VLSEG7E8_V , VLSEG7E8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG8E8_V;
class MipsInst_VLSEG8E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG8E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG8E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG8E8_V : MipsInst_VLSEG8E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG8E8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG8E8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG8E8_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG8E8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg8e8.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLSEG8E8_V : MSA_I10_FMT_VLSEG8E8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLSEG8E8_V : MSA_I10_LDI_DESC_BASE_VLSEG8E8_V <"ldi.b", ?>;
def VLSEG8E8_V : LDI_B_ENC_VLSEG8E8_V , LDI_B_DESC_VLSEG8E8_V , VLSEG8E8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG2E8FF_V;
class MipsInst_VLSEG2E8FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG2E8FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG2E8FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG2E8FF_V : MipsInst_VLSEG2E8FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG2E8FF_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG2E8FF_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG2E8FF_V ;
class LD_DESC_BASE_VLSEG2E8FF_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg2e8ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_B_ENC_VLSEG2E8FF_V : MSA_MI10_FMT_VLSEG2E8FF_V <0b00, 0b1000>;
class LD_B_DESC_VLSEG2E8FF_V : LD_DESC_BASE_VLSEG2E8FF_V <"ld.b", null_frag, ?, ?, ?>;
def VLSEG2E8FF_V : LD_B_ENC_VLSEG2E8FF_V , LD_B_DESC_VLSEG2E8FF_V , VLSEG2E8FF_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG3E8FF_V;
class MipsInst_VLSEG3E8FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG3E8FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG3E8FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG3E8FF_V : MipsInst_VLSEG3E8FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG3E8FF_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG3E8FF_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG3E8FF_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG3E8FF_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg3e8ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLSEG3E8FF_V : MSA_I10_FMT_VLSEG3E8FF_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLSEG3E8FF_V : MSA_I10_LDI_DESC_BASE_VLSEG3E8FF_V <"ldi.b", ?>;
def VLSEG3E8FF_V : LDI_B_ENC_VLSEG3E8FF_V , LDI_B_DESC_VLSEG3E8FF_V , VLSEG3E8FF_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG4E8FF_V;
class MipsInst_VLSEG4E8FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG4E8FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG4E8FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG4E8FF_V : MipsInst_VLSEG4E8FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG4E8FF_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG4E8FF_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG4E8FF_V ;
class LD_DESC_BASE_VLSEG4E8FF_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg4e8ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_B_ENC_VLSEG4E8FF_V : MSA_MI10_FMT_VLSEG4E8FF_V <0b00, 0b1000>;
class LD_B_DESC_VLSEG4E8FF_V : LD_DESC_BASE_VLSEG4E8FF_V <"ld.b", null_frag, ?, ?, ?>;
def VLSEG4E8FF_V : LD_B_ENC_VLSEG4E8FF_V , LD_B_DESC_VLSEG4E8FF_V , VLSEG4E8FF_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG5E8FF_V;
class MipsInst_VLSEG5E8FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG5E8FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG5E8FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG5E8FF_V : MipsInst_VLSEG5E8FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG5E8FF_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG5E8FF_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG5E8FF_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG5E8FF_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg5e8ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLSEG5E8FF_V : MSA_I10_FMT_VLSEG5E8FF_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLSEG5E8FF_V : MSA_I10_LDI_DESC_BASE_VLSEG5E8FF_V <"ldi.b", ?>;
def VLSEG5E8FF_V : LDI_B_ENC_VLSEG5E8FF_V , LDI_B_DESC_VLSEG5E8FF_V , VLSEG5E8FF_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG6E8FF_V;
class MipsInst_VLSEG6E8FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG6E8FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG6E8FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG6E8FF_V : MipsInst_VLSEG6E8FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG6E8FF_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG6E8FF_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG6E8FF_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG6E8FF_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg6e8ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLSEG6E8FF_V : MSA_I10_FMT_VLSEG6E8FF_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLSEG6E8FF_V : MSA_I10_LDI_DESC_BASE_VLSEG6E8FF_V <"ldi.b", ?>;
def VLSEG6E8FF_V : LDI_B_ENC_VLSEG6E8FF_V , LDI_B_DESC_VLSEG6E8FF_V , VLSEG6E8FF_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG7E8FF_V;
class MipsInst_VLSEG7E8FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG7E8FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG7E8FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG7E8FF_V : MipsInst_VLSEG7E8FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG7E8FF_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG7E8FF_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG7E8FF_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG7E8FF_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg7e8ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLSEG7E8FF_V : MSA_I10_FMT_VLSEG7E8FF_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLSEG7E8FF_V : MSA_I10_LDI_DESC_BASE_VLSEG7E8FF_V <"ldi.b", ?>;
def VLSEG7E8FF_V : LDI_B_ENC_VLSEG7E8FF_V , LDI_B_DESC_VLSEG7E8FF_V , VLSEG7E8FF_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG8E8FF_V;
class MipsInst_VLSEG8E8FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG8E8FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG8E8FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG8E8FF_V : MipsInst_VLSEG8E8FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG8E8FF_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG8E8FF_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG8E8FF_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG8E8FF_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg8e8ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLSEG8E8FF_V : MSA_I10_FMT_VLSEG8E8FF_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLSEG8E8FF_V : MSA_I10_LDI_DESC_BASE_VLSEG8E8FF_V <"ldi.b", ?>;
def VLSEG8E8FF_V : LDI_B_ENC_VLSEG8E8FF_V , LDI_B_DESC_VLSEG8E8FF_V , VLSEG8E8FF_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG2E8_V;
class MipsInst_VLSSEG2E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG2E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG2E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG2E8_V : MipsInst_VLSSEG2E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG2E8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSSEG2E8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSSEG2E8_V ;
class MSA_I10_LDI_DESC_BASE_VLSSEG2E8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg2e8.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLSSEG2E8_V : MSA_I10_FMT_VLSSEG2E8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLSSEG2E8_V : MSA_I10_LDI_DESC_BASE_VLSSEG2E8_V <"ldi.b", ?>;
def VLSSEG2E8_V : LDI_B_ENC_VLSSEG2E8_V , LDI_B_DESC_VLSSEG2E8_V , VLSSEG2E8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG3E8_V;
class MipsInst_VLSSEG3E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG3E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG3E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG3E8_V : MipsInst_VLSSEG3E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG3E8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSSEG3E8_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG3E8_V ;
class LD_DESC_BASE_VLSSEG3E8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg3e8.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_B_ENC_VLSSEG3E8_V : MSA_MI10_FMT_VLSSEG3E8_V <0b00, 0b1000>;
class LD_B_DESC_VLSSEG3E8_V : LD_DESC_BASE_VLSSEG3E8_V <"ld.b", null_frag, ?, ?, ?>;
def VLSSEG3E8_V : LD_B_ENC_VLSSEG3E8_V , LD_B_DESC_VLSSEG3E8_V , VLSSEG3E8_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG4E8_V;
class MipsInst_VLSSEG4E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG4E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG4E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG4E8_V : MipsInst_VLSSEG4E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG4E8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSSEG4E8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSSEG4E8_V ;
class MSA_I10_LDI_DESC_BASE_VLSSEG4E8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg4e8.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLSSEG4E8_V : MSA_I10_FMT_VLSSEG4E8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLSSEG4E8_V : MSA_I10_LDI_DESC_BASE_VLSSEG4E8_V <"ldi.b", ?>;
def VLSSEG4E8_V : LDI_B_ENC_VLSSEG4E8_V , LDI_B_DESC_VLSSEG4E8_V , VLSSEG4E8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG5E8_V;
class MipsInst_VLSSEG5E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG5E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG5E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG5E8_V : MipsInst_VLSSEG5E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG5E8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSSEG5E8_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG5E8_V ;
class LD_DESC_BASE_VLSSEG5E8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg5e8.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_B_ENC_VLSSEG5E8_V : MSA_MI10_FMT_VLSSEG5E8_V <0b00, 0b1000>;
class LD_B_DESC_VLSSEG5E8_V : LD_DESC_BASE_VLSSEG5E8_V <"ld.b", null_frag, ?, ?, ?>;
def VLSSEG5E8_V : LD_B_ENC_VLSSEG5E8_V , LD_B_DESC_VLSSEG5E8_V , VLSSEG5E8_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG6E8_V;
class MipsInst_VLSSEG6E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG6E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG6E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG6E8_V : MipsInst_VLSSEG6E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG6E8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSSEG6E8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSSEG6E8_V ;
class MSA_I10_LDI_DESC_BASE_VLSSEG6E8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg6e8.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLSSEG6E8_V : MSA_I10_FMT_VLSSEG6E8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLSSEG6E8_V : MSA_I10_LDI_DESC_BASE_VLSSEG6E8_V <"ldi.b", ?>;
def VLSSEG6E8_V : LDI_B_ENC_VLSSEG6E8_V , LDI_B_DESC_VLSSEG6E8_V , VLSSEG6E8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG7E8_V;
class MipsInst_VLSSEG7E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG7E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG7E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG7E8_V : MipsInst_VLSSEG7E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG7E8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSSEG7E8_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG7E8_V ;
class LD_DESC_BASE_VLSSEG7E8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg7e8.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_B_ENC_VLSSEG7E8_V : MSA_MI10_FMT_VLSSEG7E8_V <0b00, 0b1000>;
class LD_B_DESC_VLSSEG7E8_V : LD_DESC_BASE_VLSSEG7E8_V <"ld.b", null_frag, ?, ?, ?>;
def VLSSEG7E8_V : LD_B_ENC_VLSSEG7E8_V , LD_B_DESC_VLSSEG7E8_V , VLSSEG7E8_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG8E8_V;
class MipsInst_VLSSEG8E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG8E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG8E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG8E8_V : MipsInst_VLSSEG8E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG8E8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSSEG8E8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSSEG8E8_V ;
class MSA_I10_LDI_DESC_BASE_VLSSEG8E8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg8e8.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLSSEG8E8_V : MSA_I10_FMT_VLSSEG8E8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLSSEG8E8_V : MSA_I10_LDI_DESC_BASE_VLSSEG8E8_V <"ldi.b", ?>;
def VLSSEG8E8_V : LDI_B_ENC_VLSSEG8E8_V , LDI_B_DESC_VLSSEG8E8_V , VLSSEG8E8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG2EI8_V;
class MipsInst_VLUXSEG2EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG2EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG2EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG2EI8_V : MipsInst_VLUXSEG2EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG2EI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLUXSEG2EI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG2EI8_V ;
class LD_DESC_BASE_VLUXSEG2EI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg2ei8.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_B_ENC_VLUXSEG2EI8_V : MSA_MI10_FMT_VLUXSEG2EI8_V <0b00, 0b1000>;
class LD_B_DESC_VLUXSEG2EI8_V : LD_DESC_BASE_VLUXSEG2EI8_V <"ld.b", null_frag, ?, ?, ?>;
def VLUXSEG2EI8_V : LD_B_ENC_VLUXSEG2EI8_V , LD_B_DESC_VLUXSEG2EI8_V , VLUXSEG2EI8_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG3EI8_V;
class MipsInst_VLUXSEG3EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG3EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG3EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG3EI8_V : MipsInst_VLUXSEG3EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG3EI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLUXSEG3EI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG3EI8_V ;
class LD_DESC_BASE_VLUXSEG3EI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg3ei8.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_B_ENC_VLUXSEG3EI8_V : MSA_MI10_FMT_VLUXSEG3EI8_V <0b00, 0b1000>;
class LD_B_DESC_VLUXSEG3EI8_V : LD_DESC_BASE_VLUXSEG3EI8_V <"ld.b", null_frag, ?, ?, ?>;
def VLUXSEG3EI8_V : LD_B_ENC_VLUXSEG3EI8_V , LD_B_DESC_VLUXSEG3EI8_V , VLUXSEG3EI8_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG4EI8_V;
class MipsInst_VLUXSEG4EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG4EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG4EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG4EI8_V : MipsInst_VLUXSEG4EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG4EI8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLUXSEG4EI8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLUXSEG4EI8_V ;
class MSA_I10_LDI_DESC_BASE_VLUXSEG4EI8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg4ei8.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLUXSEG4EI8_V : MSA_I10_FMT_VLUXSEG4EI8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLUXSEG4EI8_V : MSA_I10_LDI_DESC_BASE_VLUXSEG4EI8_V <"ldi.b", ?>;
def VLUXSEG4EI8_V : LDI_B_ENC_VLUXSEG4EI8_V , LDI_B_DESC_VLUXSEG4EI8_V , VLUXSEG4EI8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG5EI8_V;
class MipsInst_VLUXSEG5EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG5EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG5EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG5EI8_V : MipsInst_VLUXSEG5EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG5EI8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLUXSEG5EI8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLUXSEG5EI8_V ;
class MSA_I10_LDI_DESC_BASE_VLUXSEG5EI8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg5ei8.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLUXSEG5EI8_V : MSA_I10_FMT_VLUXSEG5EI8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLUXSEG5EI8_V : MSA_I10_LDI_DESC_BASE_VLUXSEG5EI8_V <"ldi.b", ?>;
def VLUXSEG5EI8_V : LDI_B_ENC_VLUXSEG5EI8_V , LDI_B_DESC_VLUXSEG5EI8_V , VLUXSEG5EI8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG6EI8_V;
class MipsInst_VLUXSEG6EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG6EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG6EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG6EI8_V : MipsInst_VLUXSEG6EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG6EI8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLUXSEG6EI8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLUXSEG6EI8_V ;
class MSA_I10_LDI_DESC_BASE_VLUXSEG6EI8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg6ei8.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLUXSEG6EI8_V : MSA_I10_FMT_VLUXSEG6EI8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLUXSEG6EI8_V : MSA_I10_LDI_DESC_BASE_VLUXSEG6EI8_V <"ldi.b", ?>;
def VLUXSEG6EI8_V : LDI_B_ENC_VLUXSEG6EI8_V , LDI_B_DESC_VLUXSEG6EI8_V , VLUXSEG6EI8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG7EI8_V;
class MipsInst_VLUXSEG7EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG7EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG7EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG7EI8_V : MipsInst_VLUXSEG7EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG7EI8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLUXSEG7EI8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLUXSEG7EI8_V ;
class MSA_I10_LDI_DESC_BASE_VLUXSEG7EI8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg7ei8.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLUXSEG7EI8_V : MSA_I10_FMT_VLUXSEG7EI8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLUXSEG7EI8_V : MSA_I10_LDI_DESC_BASE_VLUXSEG7EI8_V <"ldi.b", ?>;
def VLUXSEG7EI8_V : LDI_B_ENC_VLUXSEG7EI8_V , LDI_B_DESC_VLUXSEG7EI8_V , VLUXSEG7EI8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG8EI8_V;
class MipsInst_VLUXSEG8EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG8EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG8EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG8EI8_V : MipsInst_VLUXSEG8EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG8EI8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLUXSEG8EI8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLUXSEG8EI8_V ;
class MSA_I10_LDI_DESC_BASE_VLUXSEG8EI8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg8ei8.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLUXSEG8EI8_V : MSA_I10_FMT_VLUXSEG8EI8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLUXSEG8EI8_V : MSA_I10_LDI_DESC_BASE_VLUXSEG8EI8_V <"ldi.b", ?>;
def VLUXSEG8EI8_V : LDI_B_ENC_VLUXSEG8EI8_V , LDI_B_DESC_VLUXSEG8EI8_V , VLUXSEG8EI8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG2EI8_V;
class MipsInst_VLOXSEG2EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG2EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG2EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG2EI8_V : MipsInst_VLOXSEG2EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG2EI8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLOXSEG2EI8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLOXSEG2EI8_V ;
class MSA_I10_LDI_DESC_BASE_VLOXSEG2EI8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg2ei8.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLOXSEG2EI8_V : MSA_I10_FMT_VLOXSEG2EI8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLOXSEG2EI8_V : MSA_I10_LDI_DESC_BASE_VLOXSEG2EI8_V <"ldi.b", ?>;
def VLOXSEG2EI8_V : LDI_B_ENC_VLOXSEG2EI8_V , LDI_B_DESC_VLOXSEG2EI8_V , VLOXSEG2EI8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG3EI8_V;
class MipsInst_VLOXSEG3EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG3EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG3EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG3EI8_V : MipsInst_VLOXSEG3EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG3EI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLOXSEG3EI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG3EI8_V ;
class LD_DESC_BASE_VLOXSEG3EI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg3ei8.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_B_ENC_VLOXSEG3EI8_V : MSA_MI10_FMT_VLOXSEG3EI8_V <0b00, 0b1000>;
class LD_B_DESC_VLOXSEG3EI8_V : LD_DESC_BASE_VLOXSEG3EI8_V <"ld.b", null_frag, ?, ?, ?>;
def VLOXSEG3EI8_V : LD_B_ENC_VLOXSEG3EI8_V , LD_B_DESC_VLOXSEG3EI8_V , VLOXSEG3EI8_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG4EI8_V;
class MipsInst_VLOXSEG4EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG4EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG4EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG4EI8_V : MipsInst_VLOXSEG4EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG4EI8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLOXSEG4EI8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLOXSEG4EI8_V ;
class MSA_I10_LDI_DESC_BASE_VLOXSEG4EI8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg4ei8.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLOXSEG4EI8_V : MSA_I10_FMT_VLOXSEG4EI8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLOXSEG4EI8_V : MSA_I10_LDI_DESC_BASE_VLOXSEG4EI8_V <"ldi.b", ?>;
def VLOXSEG4EI8_V : LDI_B_ENC_VLOXSEG4EI8_V , LDI_B_DESC_VLOXSEG4EI8_V , VLOXSEG4EI8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG5EI8_V;
class MipsInst_VLOXSEG5EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG5EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG5EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG5EI8_V : MipsInst_VLOXSEG5EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG5EI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLOXSEG5EI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG5EI8_V ;
class LD_DESC_BASE_VLOXSEG5EI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg5ei8.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_B_ENC_VLOXSEG5EI8_V : MSA_MI10_FMT_VLOXSEG5EI8_V <0b00, 0b1000>;
class LD_B_DESC_VLOXSEG5EI8_V : LD_DESC_BASE_VLOXSEG5EI8_V <"ld.b", null_frag, ?, ?, ?>;
def VLOXSEG5EI8_V : LD_B_ENC_VLOXSEG5EI8_V , LD_B_DESC_VLOXSEG5EI8_V , VLOXSEG5EI8_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG6EI8_V;
class MipsInst_VLOXSEG6EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG6EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG6EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG6EI8_V : MipsInst_VLOXSEG6EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG6EI8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLOXSEG6EI8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLOXSEG6EI8_V ;
class MSA_I10_LDI_DESC_BASE_VLOXSEG6EI8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg6ei8.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLOXSEG6EI8_V : MSA_I10_FMT_VLOXSEG6EI8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLOXSEG6EI8_V : MSA_I10_LDI_DESC_BASE_VLOXSEG6EI8_V <"ldi.b", ?>;
def VLOXSEG6EI8_V : LDI_B_ENC_VLOXSEG6EI8_V , LDI_B_DESC_VLOXSEG6EI8_V , VLOXSEG6EI8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG7EI8_V;
class MipsInst_VLOXSEG7EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG7EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG7EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG7EI8_V : MipsInst_VLOXSEG7EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG7EI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLOXSEG7EI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG7EI8_V ;
class LD_DESC_BASE_VLOXSEG7EI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg7ei8.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_B_ENC_VLOXSEG7EI8_V : MSA_MI10_FMT_VLOXSEG7EI8_V <0b00, 0b1000>;
class LD_B_DESC_VLOXSEG7EI8_V : LD_DESC_BASE_VLOXSEG7EI8_V <"ld.b", null_frag, ?, ?, ?>;
def VLOXSEG7EI8_V : LD_B_ENC_VLOXSEG7EI8_V , LD_B_DESC_VLOXSEG7EI8_V , VLOXSEG7EI8_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG8EI8_V;
class MipsInst_VLOXSEG8EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG8EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG8EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG8EI8_V : MipsInst_VLOXSEG8EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG8EI8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLOXSEG8EI8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLOXSEG8EI8_V ;
class MSA_I10_LDI_DESC_BASE_VLOXSEG8EI8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg8ei8.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VLOXSEG8EI8_V : MSA_I10_FMT_VLOXSEG8EI8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VLOXSEG8EI8_V : MSA_I10_LDI_DESC_BASE_VLOXSEG8EI8_V <"ldi.b", ?>;
def VLOXSEG8EI8_V : LDI_B_ENC_VLOXSEG8EI8_V , LDI_B_DESC_VLOXSEG8EI8_V , VLOXSEG8EI8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VL1RE8_V;
class MipsInst_VL1RE8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VL1RE8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VL1RE8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VL1RE8_V : MipsInst_VL1RE8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VL1RE8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VL1RE8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VL1RE8_V ;
class MSA_I10_LDI_DESC_BASE_VL1RE8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1);
	string  AsmString="vl1re8.v	$vd, (${rs1})";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VL1RE8_V : MSA_I10_FMT_VL1RE8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VL1RE8_V : MSA_I10_LDI_DESC_BASE_VL1RE8_V <"ldi.b", ?>;
def VL1RE8_V : LDI_B_ENC_VL1RE8_V , LDI_B_DESC_VL1RE8_V , VL1RE8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VL2RE8_V;
class MipsInst_VL2RE8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VL2RE8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VL2RE8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VL2RE8_V : MipsInst_VL2RE8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VL2RE8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VL2RE8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VL2RE8_V ;
class MSA_I10_LDI_DESC_BASE_VL2RE8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1);
	string  AsmString="vl2re8.v	$vd, (${rs1})";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VL2RE8_V : MSA_I10_FMT_VL2RE8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VL2RE8_V : MSA_I10_LDI_DESC_BASE_VL2RE8_V <"ldi.b", ?>;
def VL2RE8_V : LDI_B_ENC_VL2RE8_V , LDI_B_DESC_VL2RE8_V , VL2RE8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VL4RE8_V;
class MipsInst_VL4RE8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VL4RE8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VL4RE8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VL4RE8_V : MipsInst_VL4RE8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VL4RE8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VL4RE8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VL4RE8_V ;
class MSA_I10_LDI_DESC_BASE_VL4RE8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1);
	string  AsmString="vl4re8.v	$vd, (${rs1})";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VL4RE8_V : MSA_I10_FMT_VL4RE8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VL4RE8_V : MSA_I10_LDI_DESC_BASE_VL4RE8_V <"ldi.b", ?>;
def VL4RE8_V : LDI_B_ENC_VL4RE8_V , LDI_B_DESC_VL4RE8_V , VL4RE8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VL8RE8_V;
class MipsInst_VL8RE8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VL8RE8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VL8RE8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VL8RE8_V : MipsInst_VL8RE8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VL8RE8_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VL8RE8_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VL8RE8_V ;
class MSA_I10_LDI_DESC_BASE_VL8RE8_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1);
	string  AsmString="vl8re8.v	$vd, (${rs1})";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_B_ENC_VL8RE8_V : MSA_I10_FMT_VL8RE8_V <0b110, 0b00, 0b000111>;
class LDI_B_DESC_VL8RE8_V : MSA_I10_LDI_DESC_BASE_VL8RE8_V <"ldi.b", ?>;
def VL8RE8_V : LDI_B_ENC_VL8RE8_V , LDI_B_DESC_VL8RE8_V , VL8RE8_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLE64_V;
class MipsInst_VLE64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLE64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLE64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLE64_V : MipsInst_VLE64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLE64_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLE64_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLE64_V ;
class MSA_I10_LDI_DESC_BASE_VLE64_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vle64.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_D_ENC_VLE64_V : MSA_I10_FMT_VLE64_V <0b110, 0b11, 0b000111>;
class LDI_D_DESC_VLE64_V : MSA_I10_LDI_DESC_BASE_VLE64_V <"ldi.d", ?>;
def VLE64_V : LDI_D_ENC_VLE64_V , LDI_D_DESC_VLE64_V , VLE64_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLSE64_V;
class MipsInst_VLSE64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSE64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSE64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSE64_V : MipsInst_VLSE64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSE64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLSE64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlse64.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLSE64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSE64_V ;
class LD_D_DESC_VLSE64_V : LD_DESC_BASE_VLSE64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLSE64_V : MSA_MI10_FMT_VLSE64_V <0b11, 0b1000>;
def VLSE64_V : LD_D_ENC_VLSE64_V , LD_D_DESC_VLSE64_V , VLSE64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLUXEI64_V;
class MipsInst_VLUXEI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXEI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXEI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXEI64_V : MipsInst_VLUXEI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXEI64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLUXEI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxei64.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLUXEI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXEI64_V ;
class LD_D_DESC_VLUXEI64_V : LD_DESC_BASE_VLUXEI64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLUXEI64_V : MSA_MI10_FMT_VLUXEI64_V <0b11, 0b1000>;
def VLUXEI64_V : LD_D_ENC_VLUXEI64_V , LD_D_DESC_VLUXEI64_V , VLUXEI64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLOXEI64_V;
class MipsInst_VLOXEI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXEI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXEI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXEI64_V : MipsInst_VLOXEI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXEI64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLOXEI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxei64.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLOXEI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXEI64_V ;
class LD_D_DESC_VLOXEI64_V : LD_DESC_BASE_VLOXEI64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLOXEI64_V : MSA_MI10_FMT_VLOXEI64_V <0b11, 0b1000>;
def VLOXEI64_V : LD_D_ENC_VLOXEI64_V , LD_D_DESC_VLOXEI64_V , VLOXEI64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLE64FF_V;
class MipsInst_VLE64FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLE64FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLE64FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLE64FF_V : MipsInst_VLE64FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLE64FF_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLE64FF_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLE64FF_V ;
class MSA_I10_LDI_DESC_BASE_VLE64FF_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vle64ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_D_ENC_VLE64FF_V : MSA_I10_FMT_VLE64FF_V <0b110, 0b11, 0b000111>;
class LDI_D_DESC_VLE64FF_V : MSA_I10_LDI_DESC_BASE_VLE64FF_V <"ldi.d", ?>;
def VLE64FF_V : LDI_D_ENC_VLE64FF_V , LDI_D_DESC_VLE64FF_V , VLE64FF_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLSEG2E64_V;
class MipsInst_VLSEG2E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG2E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG2E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG2E64_V : MipsInst_VLSEG2E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG2E64_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG2E64_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG2E64_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG2E64_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg2e64.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_D_ENC_VLSEG2E64_V : MSA_I10_FMT_VLSEG2E64_V <0b110, 0b11, 0b000111>;
class LDI_D_DESC_VLSEG2E64_V : MSA_I10_LDI_DESC_BASE_VLSEG2E64_V <"ldi.d", ?>;
def VLSEG2E64_V : LDI_D_ENC_VLSEG2E64_V , LDI_D_DESC_VLSEG2E64_V , VLSEG2E64_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG3E64_V;
class MipsInst_VLSEG3E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG3E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG3E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG3E64_V : MipsInst_VLSEG3E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG3E64_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG3E64_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG3E64_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG3E64_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg3e64.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_D_ENC_VLSEG3E64_V : MSA_I10_FMT_VLSEG3E64_V <0b110, 0b11, 0b000111>;
class LDI_D_DESC_VLSEG3E64_V : MSA_I10_LDI_DESC_BASE_VLSEG3E64_V <"ldi.d", ?>;
def VLSEG3E64_V : LDI_D_ENC_VLSEG3E64_V , LDI_D_DESC_VLSEG3E64_V , VLSEG3E64_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG4E64_V;
class MipsInst_VLSEG4E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG4E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG4E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG4E64_V : MipsInst_VLSEG4E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG4E64_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG4E64_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG4E64_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG4E64_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg4e64.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_D_ENC_VLSEG4E64_V : MSA_I10_FMT_VLSEG4E64_V <0b110, 0b11, 0b000111>;
class LDI_D_DESC_VLSEG4E64_V : MSA_I10_LDI_DESC_BASE_VLSEG4E64_V <"ldi.d", ?>;
def VLSEG4E64_V : LDI_D_ENC_VLSEG4E64_V , LDI_D_DESC_VLSEG4E64_V , VLSEG4E64_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG5E64_V;
class MipsInst_VLSEG5E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG5E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG5E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG5E64_V : MipsInst_VLSEG5E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG5E64_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG5E64_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG5E64_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG5E64_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg5e64.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_D_ENC_VLSEG5E64_V : MSA_I10_FMT_VLSEG5E64_V <0b110, 0b11, 0b000111>;
class LDI_D_DESC_VLSEG5E64_V : MSA_I10_LDI_DESC_BASE_VLSEG5E64_V <"ldi.d", ?>;
def VLSEG5E64_V : LDI_D_ENC_VLSEG5E64_V , LDI_D_DESC_VLSEG5E64_V , VLSEG5E64_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG6E64_V;
class MipsInst_VLSEG6E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG6E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG6E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG6E64_V : MipsInst_VLSEG6E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG6E64_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG6E64_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG6E64_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG6E64_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg6e64.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_D_ENC_VLSEG6E64_V : MSA_I10_FMT_VLSEG6E64_V <0b110, 0b11, 0b000111>;
class LDI_D_DESC_VLSEG6E64_V : MSA_I10_LDI_DESC_BASE_VLSEG6E64_V <"ldi.d", ?>;
def VLSEG6E64_V : LDI_D_ENC_VLSEG6E64_V , LDI_D_DESC_VLSEG6E64_V , VLSEG6E64_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG7E64_V;
class MipsInst_VLSEG7E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG7E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG7E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG7E64_V : MipsInst_VLSEG7E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG7E64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLSEG7E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg7e64.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLSEG7E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG7E64_V ;
class LD_D_DESC_VLSEG7E64_V : LD_DESC_BASE_VLSEG7E64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLSEG7E64_V : MSA_MI10_FMT_VLSEG7E64_V <0b11, 0b1000>;
def VLSEG7E64_V : LD_D_ENC_VLSEG7E64_V , LD_D_DESC_VLSEG7E64_V , VLSEG7E64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG8E64_V;
class MipsInst_VLSEG8E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG8E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG8E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG8E64_V : MipsInst_VLSEG8E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG8E64_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG8E64_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG8E64_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG8E64_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg8e64.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_D_ENC_VLSEG8E64_V : MSA_I10_FMT_VLSEG8E64_V <0b110, 0b11, 0b000111>;
class LDI_D_DESC_VLSEG8E64_V : MSA_I10_LDI_DESC_BASE_VLSEG8E64_V <"ldi.d", ?>;
def VLSEG8E64_V : LDI_D_ENC_VLSEG8E64_V , LDI_D_DESC_VLSEG8E64_V , VLSEG8E64_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG2E64FF_V;
class MipsInst_VLSEG2E64FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG2E64FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG2E64FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG2E64FF_V : MipsInst_VLSEG2E64FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG2E64FF_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG2E64FF_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG2E64FF_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG2E64FF_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg2e64ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_D_ENC_VLSEG2E64FF_V : MSA_I10_FMT_VLSEG2E64FF_V <0b110, 0b11, 0b000111>;
class LDI_D_DESC_VLSEG2E64FF_V : MSA_I10_LDI_DESC_BASE_VLSEG2E64FF_V <"ldi.d", ?>;
def VLSEG2E64FF_V : LDI_D_ENC_VLSEG2E64FF_V , LDI_D_DESC_VLSEG2E64FF_V , VLSEG2E64FF_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG3E64FF_V;
class MipsInst_VLSEG3E64FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG3E64FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG3E64FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG3E64FF_V : MipsInst_VLSEG3E64FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG3E64FF_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLSEG3E64FF_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg3e64ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLSEG3E64FF_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG3E64FF_V ;
class LD_D_DESC_VLSEG3E64FF_V : LD_DESC_BASE_VLSEG3E64FF_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLSEG3E64FF_V : MSA_MI10_FMT_VLSEG3E64FF_V <0b11, 0b1000>;
def VLSEG3E64FF_V : LD_D_ENC_VLSEG3E64FF_V , LD_D_DESC_VLSEG3E64FF_V , VLSEG3E64FF_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG4E64FF_V;
class MipsInst_VLSEG4E64FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG4E64FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG4E64FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG4E64FF_V : MipsInst_VLSEG4E64FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG4E64FF_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLSEG4E64FF_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg4e64ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLSEG4E64FF_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG4E64FF_V ;
class LD_D_DESC_VLSEG4E64FF_V : LD_DESC_BASE_VLSEG4E64FF_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLSEG4E64FF_V : MSA_MI10_FMT_VLSEG4E64FF_V <0b11, 0b1000>;
def VLSEG4E64FF_V : LD_D_ENC_VLSEG4E64FF_V , LD_D_DESC_VLSEG4E64FF_V , VLSEG4E64FF_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG5E64FF_V;
class MipsInst_VLSEG5E64FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG5E64FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG5E64FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG5E64FF_V : MipsInst_VLSEG5E64FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG5E64FF_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG5E64FF_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG5E64FF_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG5E64FF_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg5e64ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_D_ENC_VLSEG5E64FF_V : MSA_I10_FMT_VLSEG5E64FF_V <0b110, 0b11, 0b000111>;
class LDI_D_DESC_VLSEG5E64FF_V : MSA_I10_LDI_DESC_BASE_VLSEG5E64FF_V <"ldi.d", ?>;
def VLSEG5E64FF_V : LDI_D_ENC_VLSEG5E64FF_V , LDI_D_DESC_VLSEG5E64FF_V , VLSEG5E64FF_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG6E64FF_V;
class MipsInst_VLSEG6E64FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG6E64FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG6E64FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG6E64FF_V : MipsInst_VLSEG6E64FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG6E64FF_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLSEG6E64FF_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg6e64ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLSEG6E64FF_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG6E64FF_V ;
class LD_D_DESC_VLSEG6E64FF_V : LD_DESC_BASE_VLSEG6E64FF_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLSEG6E64FF_V : MSA_MI10_FMT_VLSEG6E64FF_V <0b11, 0b1000>;
def VLSEG6E64FF_V : LD_D_ENC_VLSEG6E64FF_V , LD_D_DESC_VLSEG6E64FF_V , VLSEG6E64FF_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG7E64FF_V;
class MipsInst_VLSEG7E64FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG7E64FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG7E64FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG7E64FF_V : MipsInst_VLSEG7E64FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG7E64FF_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG7E64FF_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG7E64FF_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG7E64FF_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg7e64ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_D_ENC_VLSEG7E64FF_V : MSA_I10_FMT_VLSEG7E64FF_V <0b110, 0b11, 0b000111>;
class LDI_D_DESC_VLSEG7E64FF_V : MSA_I10_LDI_DESC_BASE_VLSEG7E64FF_V <"ldi.d", ?>;
def VLSEG7E64FF_V : LDI_D_ENC_VLSEG7E64FF_V , LDI_D_DESC_VLSEG7E64FF_V , VLSEG7E64FF_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG8E64FF_V;
class MipsInst_VLSEG8E64FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG8E64FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG8E64FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG8E64FF_V : MipsInst_VLSEG8E64FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG8E64FF_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VLSEG8E64FF_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG8E64FF_V ;
class MSA_I10_LDI_DESC_BASE_VLSEG8E64FF_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg8e64ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_D_ENC_VLSEG8E64FF_V : MSA_I10_FMT_VLSEG8E64FF_V <0b110, 0b11, 0b000111>;
class LDI_D_DESC_VLSEG8E64FF_V : MSA_I10_LDI_DESC_BASE_VLSEG8E64FF_V <"ldi.d", ?>;
def VLSEG8E64FF_V : LDI_D_ENC_VLSEG8E64FF_V , LDI_D_DESC_VLSEG8E64FF_V , VLSEG8E64FF_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG2E64_V;
class MipsInst_VLSSEG2E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG2E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG2E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG2E64_V : MipsInst_VLSSEG2E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG2E64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLSSEG2E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg2e64.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLSSEG2E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG2E64_V ;
class LD_D_DESC_VLSSEG2E64_V : LD_DESC_BASE_VLSSEG2E64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLSSEG2E64_V : MSA_MI10_FMT_VLSSEG2E64_V <0b11, 0b1000>;
def VLSSEG2E64_V : LD_D_ENC_VLSSEG2E64_V , LD_D_DESC_VLSSEG2E64_V , VLSSEG2E64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG3E64_V;
class MipsInst_VLSSEG3E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG3E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG3E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG3E64_V : MipsInst_VLSSEG3E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG3E64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLSSEG3E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg3e64.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLSSEG3E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG3E64_V ;
class LD_D_DESC_VLSSEG3E64_V : LD_DESC_BASE_VLSSEG3E64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLSSEG3E64_V : MSA_MI10_FMT_VLSSEG3E64_V <0b11, 0b1000>;
def VLSSEG3E64_V : LD_D_ENC_VLSSEG3E64_V , LD_D_DESC_VLSSEG3E64_V , VLSSEG3E64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG4E64_V;
class MipsInst_VLSSEG4E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG4E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG4E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG4E64_V : MipsInst_VLSSEG4E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG4E64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLSSEG4E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg4e64.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLSSEG4E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG4E64_V ;
class LD_D_DESC_VLSSEG4E64_V : LD_DESC_BASE_VLSSEG4E64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLSSEG4E64_V : MSA_MI10_FMT_VLSSEG4E64_V <0b11, 0b1000>;
def VLSSEG4E64_V : LD_D_ENC_VLSSEG4E64_V , LD_D_DESC_VLSSEG4E64_V , VLSSEG4E64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG5E64_V;
class MipsInst_VLSSEG5E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG5E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG5E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG5E64_V : MipsInst_VLSSEG5E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG5E64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLSSEG5E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg5e64.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLSSEG5E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG5E64_V ;
class LD_D_DESC_VLSSEG5E64_V : LD_DESC_BASE_VLSSEG5E64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLSSEG5E64_V : MSA_MI10_FMT_VLSSEG5E64_V <0b11, 0b1000>;
def VLSSEG5E64_V : LD_D_ENC_VLSSEG5E64_V , LD_D_DESC_VLSSEG5E64_V , VLSSEG5E64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG6E64_V;
class MipsInst_VLSSEG6E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG6E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG6E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG6E64_V : MipsInst_VLSSEG6E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG6E64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLSSEG6E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg6e64.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLSSEG6E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG6E64_V ;
class LD_D_DESC_VLSSEG6E64_V : LD_DESC_BASE_VLSSEG6E64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLSSEG6E64_V : MSA_MI10_FMT_VLSSEG6E64_V <0b11, 0b1000>;
def VLSSEG6E64_V : LD_D_ENC_VLSSEG6E64_V , LD_D_DESC_VLSSEG6E64_V , VLSSEG6E64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG7E64_V;
class MipsInst_VLSSEG7E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG7E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG7E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG7E64_V : MipsInst_VLSSEG7E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG7E64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLSSEG7E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg7e64.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLSSEG7E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG7E64_V ;
class LD_D_DESC_VLSSEG7E64_V : LD_DESC_BASE_VLSSEG7E64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLSSEG7E64_V : MSA_MI10_FMT_VLSSEG7E64_V <0b11, 0b1000>;
def VLSSEG7E64_V : LD_D_ENC_VLSSEG7E64_V , LD_D_DESC_VLSSEG7E64_V , VLSSEG7E64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG8E64_V;
class MipsInst_VLSSEG8E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG8E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG8E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG8E64_V : MipsInst_VLSSEG8E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG8E64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLSSEG8E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg8e64.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLSSEG8E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG8E64_V ;
class LD_D_DESC_VLSSEG8E64_V : LD_DESC_BASE_VLSSEG8E64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLSSEG8E64_V : MSA_MI10_FMT_VLSSEG8E64_V <0b11, 0b1000>;
def VLSSEG8E64_V : LD_D_ENC_VLSSEG8E64_V , LD_D_DESC_VLSSEG8E64_V , VLSSEG8E64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG2EI64_V;
class MipsInst_VLUXSEG2EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG2EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG2EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG2EI64_V : MipsInst_VLUXSEG2EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG2EI64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLUXSEG2EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg2ei64.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLUXSEG2EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG2EI64_V ;
class LD_D_DESC_VLUXSEG2EI64_V : LD_DESC_BASE_VLUXSEG2EI64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLUXSEG2EI64_V : MSA_MI10_FMT_VLUXSEG2EI64_V <0b11, 0b1000>;
def VLUXSEG2EI64_V : LD_D_ENC_VLUXSEG2EI64_V , LD_D_DESC_VLUXSEG2EI64_V , VLUXSEG2EI64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG3EI64_V;
class MipsInst_VLUXSEG3EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG3EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG3EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG3EI64_V : MipsInst_VLUXSEG3EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG3EI64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLUXSEG3EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg3ei64.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLUXSEG3EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG3EI64_V ;
class LD_D_DESC_VLUXSEG3EI64_V : LD_DESC_BASE_VLUXSEG3EI64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLUXSEG3EI64_V : MSA_MI10_FMT_VLUXSEG3EI64_V <0b11, 0b1000>;
def VLUXSEG3EI64_V : LD_D_ENC_VLUXSEG3EI64_V , LD_D_DESC_VLUXSEG3EI64_V , VLUXSEG3EI64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG4EI64_V;
class MipsInst_VLUXSEG4EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG4EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG4EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG4EI64_V : MipsInst_VLUXSEG4EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG4EI64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLUXSEG4EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg4ei64.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLUXSEG4EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG4EI64_V ;
class LD_D_DESC_VLUXSEG4EI64_V : LD_DESC_BASE_VLUXSEG4EI64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLUXSEG4EI64_V : MSA_MI10_FMT_VLUXSEG4EI64_V <0b11, 0b1000>;
def VLUXSEG4EI64_V : LD_D_ENC_VLUXSEG4EI64_V , LD_D_DESC_VLUXSEG4EI64_V , VLUXSEG4EI64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG5EI64_V;
class MipsInst_VLUXSEG5EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG5EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG5EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG5EI64_V : MipsInst_VLUXSEG5EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG5EI64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLUXSEG5EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg5ei64.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLUXSEG5EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG5EI64_V ;
class LD_D_DESC_VLUXSEG5EI64_V : LD_DESC_BASE_VLUXSEG5EI64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLUXSEG5EI64_V : MSA_MI10_FMT_VLUXSEG5EI64_V <0b11, 0b1000>;
def VLUXSEG5EI64_V : LD_D_ENC_VLUXSEG5EI64_V , LD_D_DESC_VLUXSEG5EI64_V , VLUXSEG5EI64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG6EI64_V;
class MipsInst_VLUXSEG6EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG6EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG6EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG6EI64_V : MipsInst_VLUXSEG6EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG6EI64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLUXSEG6EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg6ei64.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLUXSEG6EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG6EI64_V ;
class LD_D_DESC_VLUXSEG6EI64_V : LD_DESC_BASE_VLUXSEG6EI64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLUXSEG6EI64_V : MSA_MI10_FMT_VLUXSEG6EI64_V <0b11, 0b1000>;
def VLUXSEG6EI64_V : LD_D_ENC_VLUXSEG6EI64_V , LD_D_DESC_VLUXSEG6EI64_V , VLUXSEG6EI64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG7EI64_V;
class MipsInst_VLUXSEG7EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG7EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG7EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG7EI64_V : MipsInst_VLUXSEG7EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG7EI64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLUXSEG7EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg7ei64.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLUXSEG7EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG7EI64_V ;
class LD_D_DESC_VLUXSEG7EI64_V : LD_DESC_BASE_VLUXSEG7EI64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLUXSEG7EI64_V : MSA_MI10_FMT_VLUXSEG7EI64_V <0b11, 0b1000>;
def VLUXSEG7EI64_V : LD_D_ENC_VLUXSEG7EI64_V , LD_D_DESC_VLUXSEG7EI64_V , VLUXSEG7EI64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG8EI64_V;
class MipsInst_VLUXSEG8EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG8EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG8EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG8EI64_V : MipsInst_VLUXSEG8EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG8EI64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLUXSEG8EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg8ei64.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLUXSEG8EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG8EI64_V ;
class LD_D_DESC_VLUXSEG8EI64_V : LD_DESC_BASE_VLUXSEG8EI64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLUXSEG8EI64_V : MSA_MI10_FMT_VLUXSEG8EI64_V <0b11, 0b1000>;
def VLUXSEG8EI64_V : LD_D_ENC_VLUXSEG8EI64_V , LD_D_DESC_VLUXSEG8EI64_V , VLUXSEG8EI64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG2EI64_V;
class MipsInst_VLOXSEG2EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG2EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG2EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG2EI64_V : MipsInst_VLOXSEG2EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG2EI64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLOXSEG2EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg2ei64.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLOXSEG2EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG2EI64_V ;
class LD_D_DESC_VLOXSEG2EI64_V : LD_DESC_BASE_VLOXSEG2EI64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLOXSEG2EI64_V : MSA_MI10_FMT_VLOXSEG2EI64_V <0b11, 0b1000>;
def VLOXSEG2EI64_V : LD_D_ENC_VLOXSEG2EI64_V , LD_D_DESC_VLOXSEG2EI64_V , VLOXSEG2EI64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG3EI64_V;
class MipsInst_VLOXSEG3EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG3EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG3EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG3EI64_V : MipsInst_VLOXSEG3EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG3EI64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLOXSEG3EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg3ei64.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLOXSEG3EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG3EI64_V ;
class LD_D_DESC_VLOXSEG3EI64_V : LD_DESC_BASE_VLOXSEG3EI64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLOXSEG3EI64_V : MSA_MI10_FMT_VLOXSEG3EI64_V <0b11, 0b1000>;
def VLOXSEG3EI64_V : LD_D_ENC_VLOXSEG3EI64_V , LD_D_DESC_VLOXSEG3EI64_V , VLOXSEG3EI64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG4EI64_V;
class MipsInst_VLOXSEG4EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG4EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG4EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG4EI64_V : MipsInst_VLOXSEG4EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG4EI64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLOXSEG4EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg4ei64.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLOXSEG4EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG4EI64_V ;
class LD_D_DESC_VLOXSEG4EI64_V : LD_DESC_BASE_VLOXSEG4EI64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLOXSEG4EI64_V : MSA_MI10_FMT_VLOXSEG4EI64_V <0b11, 0b1000>;
def VLOXSEG4EI64_V : LD_D_ENC_VLOXSEG4EI64_V , LD_D_DESC_VLOXSEG4EI64_V , VLOXSEG4EI64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG5EI64_V;
class MipsInst_VLOXSEG5EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG5EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG5EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG5EI64_V : MipsInst_VLOXSEG5EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG5EI64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLOXSEG5EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg5ei64.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLOXSEG5EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG5EI64_V ;
class LD_D_DESC_VLOXSEG5EI64_V : LD_DESC_BASE_VLOXSEG5EI64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLOXSEG5EI64_V : MSA_MI10_FMT_VLOXSEG5EI64_V <0b11, 0b1000>;
def VLOXSEG5EI64_V : LD_D_ENC_VLOXSEG5EI64_V , LD_D_DESC_VLOXSEG5EI64_V , VLOXSEG5EI64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG6EI64_V;
class MipsInst_VLOXSEG6EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG6EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG6EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG6EI64_V : MipsInst_VLOXSEG6EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG6EI64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLOXSEG6EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg6ei64.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLOXSEG6EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG6EI64_V ;
class LD_D_DESC_VLOXSEG6EI64_V : LD_DESC_BASE_VLOXSEG6EI64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLOXSEG6EI64_V : MSA_MI10_FMT_VLOXSEG6EI64_V <0b11, 0b1000>;
def VLOXSEG6EI64_V : LD_D_ENC_VLOXSEG6EI64_V , LD_D_DESC_VLOXSEG6EI64_V , VLOXSEG6EI64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG7EI64_V;
class MipsInst_VLOXSEG7EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG7EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG7EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG7EI64_V : MipsInst_VLOXSEG7EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG7EI64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLOXSEG7EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg7ei64.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLOXSEG7EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG7EI64_V ;
class LD_D_DESC_VLOXSEG7EI64_V : LD_DESC_BASE_VLOXSEG7EI64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLOXSEG7EI64_V : MSA_MI10_FMT_VLOXSEG7EI64_V <0b11, 0b1000>;
def VLOXSEG7EI64_V : LD_D_ENC_VLOXSEG7EI64_V , LD_D_DESC_VLOXSEG7EI64_V , VLOXSEG7EI64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG8EI64_V;
class MipsInst_VLOXSEG8EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG8EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG8EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG8EI64_V : MipsInst_VLOXSEG8EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG8EI64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VLOXSEG8EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg8ei64.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VLOXSEG8EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG8EI64_V ;
class LD_D_DESC_VLOXSEG8EI64_V : LD_DESC_BASE_VLOXSEG8EI64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VLOXSEG8EI64_V : MSA_MI10_FMT_VLOXSEG8EI64_V <0b11, 0b1000>;
def VLOXSEG8EI64_V : LD_D_ENC_VLOXSEG8EI64_V , LD_D_DESC_VLOXSEG8EI64_V , VLOXSEG8EI64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VL1RE64_V;
class MipsInst_VL1RE64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VL1RE64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VL1RE64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VL1RE64_V : MipsInst_VL1RE64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VL1RE64_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VL1RE64_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VL1RE64_V ;
class MSA_I10_LDI_DESC_BASE_VL1RE64_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1);
	string  AsmString="vl1re64.v	$vd, (${rs1})";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_D_ENC_VL1RE64_V : MSA_I10_FMT_VL1RE64_V <0b110, 0b11, 0b000111>;
class LDI_D_DESC_VL1RE64_V : MSA_I10_LDI_DESC_BASE_VL1RE64_V <"ldi.d", ?>;
def VL1RE64_V : LDI_D_ENC_VL1RE64_V , LDI_D_DESC_VL1RE64_V , VL1RE64_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VL2RE64_V;
class MipsInst_VL2RE64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VL2RE64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VL2RE64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VL2RE64_V : MipsInst_VL2RE64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VL2RE64_V {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VL2RE64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1);
	string  AsmString="vl2re64.v	$vd, (${rs1})";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VL2RE64_V<bits<2>  df, bits<4>  minor> : MSAInst_VL2RE64_V ;
class LD_D_DESC_VL2RE64_V : LD_DESC_BASE_VL2RE64_V <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VL2RE64_V : MSA_MI10_FMT_VL2RE64_V <0b11, 0b1000>;
def VL2RE64_V : LD_D_ENC_VL2RE64_V , LD_D_DESC_VL2RE64_V , VL2RE64_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VL4RE64_V;
class MipsInst_VL4RE64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VL4RE64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VL4RE64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VL4RE64_V : MipsInst_VL4RE64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VL4RE64_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VL4RE64_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VL4RE64_V ;
class MSA_I10_LDI_DESC_BASE_VL4RE64_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1);
	string  AsmString="vl4re64.v	$vd, (${rs1})";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_D_ENC_VL4RE64_V : MSA_I10_FMT_VL4RE64_V <0b110, 0b11, 0b000111>;
class LDI_D_DESC_VL4RE64_V : MSA_I10_LDI_DESC_BASE_VL4RE64_V <"ldi.d", ?>;
def VL4RE64_V : LDI_D_ENC_VL4RE64_V , LDI_D_DESC_VL4RE64_V , VL4RE64_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VL8RE64_V;
class MipsInst_VL8RE64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VL8RE64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VL8RE64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VL8RE64_V : MipsInst_VL8RE64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VL8RE64_V {
	let  EncodingPredicates=[];
}
class MSA_I10_FMT_VL8RE64_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VL8RE64_V ;
class MSA_I10_LDI_DESC_BASE_VL8RE64_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1);
	string  AsmString="vl8re64.v	$vd, (${rs1})";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class LDI_D_ENC_VL8RE64_V : MSA_I10_FMT_VL8RE64_V <0b110, 0b11, 0b000111>;
class LDI_D_DESC_VL8RE64_V : MSA_I10_LDI_DESC_BASE_VL8RE64_V <"ldi.d", ?>;
def VL8RE64_V : LDI_D_ENC_VL8RE64_V , LDI_D_DESC_VL8RE64_V , VL8RE64_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLE16_V;
class MipsInst_VLE16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLE16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLE16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLE16_V : MipsInst_VLE16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLE16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLE16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLE16_V ;
class LD_DESC_BASE_VLE16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vle16.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLE16_V : MSA_MI10_FMT_VLE16_V <0b01, 0b1000>;
class LD_H_DESC_VLE16_V : LD_DESC_BASE_VLE16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLE16_V : LD_H_ENC_VLE16_V , LD_H_DESC_VLE16_V , VLE16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLSE16_V;
class MipsInst_VLSE16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSE16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSE16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSE16_V : MipsInst_VLSE16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSE16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSE16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSE16_V ;
class LD_DESC_BASE_VLSE16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlse16.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLSE16_V : MSA_MI10_FMT_VLSE16_V <0b01, 0b1000>;
class LD_H_DESC_VLSE16_V : LD_DESC_BASE_VLSE16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLSE16_V : LD_H_ENC_VLSE16_V , LD_H_DESC_VLSE16_V , VLSE16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLUXEI16_V;
class MipsInst_VLUXEI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXEI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXEI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXEI16_V : MipsInst_VLUXEI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXEI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLUXEI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXEI16_V ;
class LD_DESC_BASE_VLUXEI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxei16.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLUXEI16_V : MSA_MI10_FMT_VLUXEI16_V <0b01, 0b1000>;
class LD_H_DESC_VLUXEI16_V : LD_DESC_BASE_VLUXEI16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLUXEI16_V : LD_H_ENC_VLUXEI16_V , LD_H_DESC_VLUXEI16_V , VLUXEI16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLOXEI16_V;
class MipsInst_VLOXEI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXEI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXEI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXEI16_V : MipsInst_VLOXEI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXEI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLOXEI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXEI16_V ;
class LD_DESC_BASE_VLOXEI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxei16.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLOXEI16_V : MSA_MI10_FMT_VLOXEI16_V <0b01, 0b1000>;
class LD_H_DESC_VLOXEI16_V : LD_DESC_BASE_VLOXEI16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLOXEI16_V : LD_H_ENC_VLOXEI16_V , LD_H_DESC_VLOXEI16_V , VLOXEI16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLE16FF_V;
class MipsInst_VLE16FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLE16FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLE16FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLE16FF_V : MipsInst_VLE16FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLE16FF_V {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VLE16FF_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vle16ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VLE16FF_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLE16FF_V ;
class LDI_H_DESC_VLE16FF_V : MSA_I10_LDI_DESC_BASE_VLE16FF_V <"ldi.h", ?>;
class LDI_H_ENC_VLE16FF_V : MSA_I10_FMT_VLE16FF_V <0b110, 0b01, 0b000111>;
def VLE16FF_V : LDI_H_ENC_VLE16FF_V , LDI_H_DESC_VLE16FF_V , VLE16FF_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLSEG2E16_V;
class MipsInst_VLSEG2E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG2E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG2E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG2E16_V : MipsInst_VLSEG2E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG2E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG2E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG2E16_V ;
class LD_DESC_BASE_VLSEG2E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg2e16.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLSEG2E16_V : MSA_MI10_FMT_VLSEG2E16_V <0b01, 0b1000>;
class LD_H_DESC_VLSEG2E16_V : LD_DESC_BASE_VLSEG2E16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLSEG2E16_V : LD_H_ENC_VLSEG2E16_V , LD_H_DESC_VLSEG2E16_V , VLSEG2E16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG3E16_V;
class MipsInst_VLSEG3E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG3E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG3E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG3E16_V : MipsInst_VLSEG3E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG3E16_V {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VLSEG3E16_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg3e16.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VLSEG3E16_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG3E16_V ;
class LDI_H_DESC_VLSEG3E16_V : MSA_I10_LDI_DESC_BASE_VLSEG3E16_V <"ldi.h", ?>;
class LDI_H_ENC_VLSEG3E16_V : MSA_I10_FMT_VLSEG3E16_V <0b110, 0b01, 0b000111>;
def VLSEG3E16_V : LDI_H_ENC_VLSEG3E16_V , LDI_H_DESC_VLSEG3E16_V , VLSEG3E16_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG4E16_V;
class MipsInst_VLSEG4E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG4E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG4E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG4E16_V : MipsInst_VLSEG4E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG4E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG4E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG4E16_V ;
class LD_DESC_BASE_VLSEG4E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg4e16.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLSEG4E16_V : MSA_MI10_FMT_VLSEG4E16_V <0b01, 0b1000>;
class LD_H_DESC_VLSEG4E16_V : LD_DESC_BASE_VLSEG4E16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLSEG4E16_V : LD_H_ENC_VLSEG4E16_V , LD_H_DESC_VLSEG4E16_V , VLSEG4E16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG5E16_V;
class MipsInst_VLSEG5E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG5E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG5E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG5E16_V : MipsInst_VLSEG5E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG5E16_V {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VLSEG5E16_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg5e16.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VLSEG5E16_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG5E16_V ;
class LDI_H_DESC_VLSEG5E16_V : MSA_I10_LDI_DESC_BASE_VLSEG5E16_V <"ldi.h", ?>;
class LDI_H_ENC_VLSEG5E16_V : MSA_I10_FMT_VLSEG5E16_V <0b110, 0b01, 0b000111>;
def VLSEG5E16_V : LDI_H_ENC_VLSEG5E16_V , LDI_H_DESC_VLSEG5E16_V , VLSEG5E16_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG6E16_V;
class MipsInst_VLSEG6E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG6E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG6E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG6E16_V : MipsInst_VLSEG6E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG6E16_V {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VLSEG6E16_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg6e16.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VLSEG6E16_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG6E16_V ;
class LDI_H_DESC_VLSEG6E16_V : MSA_I10_LDI_DESC_BASE_VLSEG6E16_V <"ldi.h", ?>;
class LDI_H_ENC_VLSEG6E16_V : MSA_I10_FMT_VLSEG6E16_V <0b110, 0b01, 0b000111>;
def VLSEG6E16_V : LDI_H_ENC_VLSEG6E16_V , LDI_H_DESC_VLSEG6E16_V , VLSEG6E16_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG7E16_V;
class MipsInst_VLSEG7E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG7E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG7E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG7E16_V : MipsInst_VLSEG7E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG7E16_V {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VLSEG7E16_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg7e16.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VLSEG7E16_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG7E16_V ;
class LDI_H_DESC_VLSEG7E16_V : MSA_I10_LDI_DESC_BASE_VLSEG7E16_V <"ldi.h", ?>;
class LDI_H_ENC_VLSEG7E16_V : MSA_I10_FMT_VLSEG7E16_V <0b110, 0b01, 0b000111>;
def VLSEG7E16_V : LDI_H_ENC_VLSEG7E16_V , LDI_H_DESC_VLSEG7E16_V , VLSEG7E16_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG8E16_V;
class MipsInst_VLSEG8E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG8E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG8E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG8E16_V : MipsInst_VLSEG8E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG8E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG8E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG8E16_V ;
class LD_DESC_BASE_VLSEG8E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg8e16.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLSEG8E16_V : MSA_MI10_FMT_VLSEG8E16_V <0b01, 0b1000>;
class LD_H_DESC_VLSEG8E16_V : LD_DESC_BASE_VLSEG8E16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLSEG8E16_V : LD_H_ENC_VLSEG8E16_V , LD_H_DESC_VLSEG8E16_V , VLSEG8E16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG2E16FF_V;
class MipsInst_VLSEG2E16FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG2E16FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG2E16FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG2E16FF_V : MipsInst_VLSEG2E16FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG2E16FF_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG2E16FF_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG2E16FF_V ;
class LD_DESC_BASE_VLSEG2E16FF_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg2e16ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLSEG2E16FF_V : MSA_MI10_FMT_VLSEG2E16FF_V <0b01, 0b1000>;
class LD_H_DESC_VLSEG2E16FF_V : LD_DESC_BASE_VLSEG2E16FF_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLSEG2E16FF_V : LD_H_ENC_VLSEG2E16FF_V , LD_H_DESC_VLSEG2E16FF_V , VLSEG2E16FF_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG3E16FF_V;
class MipsInst_VLSEG3E16FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG3E16FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG3E16FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG3E16FF_V : MipsInst_VLSEG3E16FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG3E16FF_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG3E16FF_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG3E16FF_V ;
class LD_DESC_BASE_VLSEG3E16FF_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg3e16ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLSEG3E16FF_V : MSA_MI10_FMT_VLSEG3E16FF_V <0b01, 0b1000>;
class LD_H_DESC_VLSEG3E16FF_V : LD_DESC_BASE_VLSEG3E16FF_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLSEG3E16FF_V : LD_H_ENC_VLSEG3E16FF_V , LD_H_DESC_VLSEG3E16FF_V , VLSEG3E16FF_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG4E16FF_V;
class MipsInst_VLSEG4E16FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG4E16FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG4E16FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG4E16FF_V : MipsInst_VLSEG4E16FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG4E16FF_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG4E16FF_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG4E16FF_V ;
class LD_DESC_BASE_VLSEG4E16FF_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg4e16ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLSEG4E16FF_V : MSA_MI10_FMT_VLSEG4E16FF_V <0b01, 0b1000>;
class LD_H_DESC_VLSEG4E16FF_V : LD_DESC_BASE_VLSEG4E16FF_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLSEG4E16FF_V : LD_H_ENC_VLSEG4E16FF_V , LD_H_DESC_VLSEG4E16FF_V , VLSEG4E16FF_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG5E16FF_V;
class MipsInst_VLSEG5E16FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG5E16FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG5E16FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG5E16FF_V : MipsInst_VLSEG5E16FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG5E16FF_V {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VLSEG5E16FF_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg5e16ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VLSEG5E16FF_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG5E16FF_V ;
class LDI_H_DESC_VLSEG5E16FF_V : MSA_I10_LDI_DESC_BASE_VLSEG5E16FF_V <"ldi.h", ?>;
class LDI_H_ENC_VLSEG5E16FF_V : MSA_I10_FMT_VLSEG5E16FF_V <0b110, 0b01, 0b000111>;
def VLSEG5E16FF_V : LDI_H_ENC_VLSEG5E16FF_V , LDI_H_DESC_VLSEG5E16FF_V , VLSEG5E16FF_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG6E16FF_V;
class MipsInst_VLSEG6E16FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG6E16FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG6E16FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG6E16FF_V : MipsInst_VLSEG6E16FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG6E16FF_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG6E16FF_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG6E16FF_V ;
class LD_DESC_BASE_VLSEG6E16FF_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg6e16ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLSEG6E16FF_V : MSA_MI10_FMT_VLSEG6E16FF_V <0b01, 0b1000>;
class LD_H_DESC_VLSEG6E16FF_V : LD_DESC_BASE_VLSEG6E16FF_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLSEG6E16FF_V : LD_H_ENC_VLSEG6E16FF_V , LD_H_DESC_VLSEG6E16FF_V , VLSEG6E16FF_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG7E16FF_V;
class MipsInst_VLSEG7E16FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG7E16FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG7E16FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG7E16FF_V : MipsInst_VLSEG7E16FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG7E16FF_V {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VLSEG7E16FF_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg7e16ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VLSEG7E16FF_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG7E16FF_V ;
class LDI_H_DESC_VLSEG7E16FF_V : MSA_I10_LDI_DESC_BASE_VLSEG7E16FF_V <"ldi.h", ?>;
class LDI_H_ENC_VLSEG7E16FF_V : MSA_I10_FMT_VLSEG7E16FF_V <0b110, 0b01, 0b000111>;
def VLSEG7E16FF_V : LDI_H_ENC_VLSEG7E16FF_V , LDI_H_DESC_VLSEG7E16FF_V , VLSEG7E16FF_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG8E16FF_V;
class MipsInst_VLSEG8E16FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG8E16FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG8E16FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG8E16FF_V : MipsInst_VLSEG8E16FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG8E16FF_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG8E16FF_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG8E16FF_V ;
class LD_DESC_BASE_VLSEG8E16FF_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg8e16ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLSEG8E16FF_V : MSA_MI10_FMT_VLSEG8E16FF_V <0b01, 0b1000>;
class LD_H_DESC_VLSEG8E16FF_V : LD_DESC_BASE_VLSEG8E16FF_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLSEG8E16FF_V : LD_H_ENC_VLSEG8E16FF_V , LD_H_DESC_VLSEG8E16FF_V , VLSEG8E16FF_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG2E16_V;
class MipsInst_VLSSEG2E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG2E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG2E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG2E16_V : MipsInst_VLSSEG2E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG2E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSSEG2E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG2E16_V ;
class LD_DESC_BASE_VLSSEG2E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg2e16.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLSSEG2E16_V : MSA_MI10_FMT_VLSSEG2E16_V <0b01, 0b1000>;
class LD_H_DESC_VLSSEG2E16_V : LD_DESC_BASE_VLSSEG2E16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLSSEG2E16_V : LD_H_ENC_VLSSEG2E16_V , LD_H_DESC_VLSSEG2E16_V , VLSSEG2E16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG3E16_V;
class MipsInst_VLSSEG3E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG3E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG3E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG3E16_V : MipsInst_VLSSEG3E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG3E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSSEG3E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG3E16_V ;
class LD_DESC_BASE_VLSSEG3E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg3e16.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLSSEG3E16_V : MSA_MI10_FMT_VLSSEG3E16_V <0b01, 0b1000>;
class LD_H_DESC_VLSSEG3E16_V : LD_DESC_BASE_VLSSEG3E16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLSSEG3E16_V : LD_H_ENC_VLSSEG3E16_V , LD_H_DESC_VLSSEG3E16_V , VLSSEG3E16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG4E16_V;
class MipsInst_VLSSEG4E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG4E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG4E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG4E16_V : MipsInst_VLSSEG4E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG4E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSSEG4E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG4E16_V ;
class LD_DESC_BASE_VLSSEG4E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg4e16.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLSSEG4E16_V : MSA_MI10_FMT_VLSSEG4E16_V <0b01, 0b1000>;
class LD_H_DESC_VLSSEG4E16_V : LD_DESC_BASE_VLSSEG4E16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLSSEG4E16_V : LD_H_ENC_VLSSEG4E16_V , LD_H_DESC_VLSSEG4E16_V , VLSSEG4E16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG5E16_V;
class MipsInst_VLSSEG5E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG5E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG5E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG5E16_V : MipsInst_VLSSEG5E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG5E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSSEG5E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG5E16_V ;
class LD_DESC_BASE_VLSSEG5E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg5e16.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLSSEG5E16_V : MSA_MI10_FMT_VLSSEG5E16_V <0b01, 0b1000>;
class LD_H_DESC_VLSSEG5E16_V : LD_DESC_BASE_VLSSEG5E16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLSSEG5E16_V : LD_H_ENC_VLSSEG5E16_V , LD_H_DESC_VLSSEG5E16_V , VLSSEG5E16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG6E16_V;
class MipsInst_VLSSEG6E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG6E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG6E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG6E16_V : MipsInst_VLSSEG6E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG6E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSSEG6E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG6E16_V ;
class LD_DESC_BASE_VLSSEG6E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg6e16.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLSSEG6E16_V : MSA_MI10_FMT_VLSSEG6E16_V <0b01, 0b1000>;
class LD_H_DESC_VLSSEG6E16_V : LD_DESC_BASE_VLSSEG6E16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLSSEG6E16_V : LD_H_ENC_VLSSEG6E16_V , LD_H_DESC_VLSSEG6E16_V , VLSSEG6E16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG7E16_V;
class MipsInst_VLSSEG7E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG7E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG7E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG7E16_V : MipsInst_VLSSEG7E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG7E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSSEG7E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG7E16_V ;
class LD_DESC_BASE_VLSSEG7E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg7e16.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLSSEG7E16_V : MSA_MI10_FMT_VLSSEG7E16_V <0b01, 0b1000>;
class LD_H_DESC_VLSSEG7E16_V : LD_DESC_BASE_VLSSEG7E16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLSSEG7E16_V : LD_H_ENC_VLSSEG7E16_V , LD_H_DESC_VLSSEG7E16_V , VLSSEG7E16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG8E16_V;
class MipsInst_VLSSEG8E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG8E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG8E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG8E16_V : MipsInst_VLSSEG8E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG8E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSSEG8E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG8E16_V ;
class LD_DESC_BASE_VLSSEG8E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg8e16.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLSSEG8E16_V : MSA_MI10_FMT_VLSSEG8E16_V <0b01, 0b1000>;
class LD_H_DESC_VLSSEG8E16_V : LD_DESC_BASE_VLSSEG8E16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLSSEG8E16_V : LD_H_ENC_VLSSEG8E16_V , LD_H_DESC_VLSSEG8E16_V , VLSSEG8E16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG2EI16_V;
class MipsInst_VLUXSEG2EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG2EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG2EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG2EI16_V : MipsInst_VLUXSEG2EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG2EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLUXSEG2EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG2EI16_V ;
class LD_DESC_BASE_VLUXSEG2EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg2ei16.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLUXSEG2EI16_V : MSA_MI10_FMT_VLUXSEG2EI16_V <0b01, 0b1000>;
class LD_H_DESC_VLUXSEG2EI16_V : LD_DESC_BASE_VLUXSEG2EI16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLUXSEG2EI16_V : LD_H_ENC_VLUXSEG2EI16_V , LD_H_DESC_VLUXSEG2EI16_V , VLUXSEG2EI16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG3EI16_V;
class MipsInst_VLUXSEG3EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG3EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG3EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG3EI16_V : MipsInst_VLUXSEG3EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG3EI16_V {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VLUXSEG3EI16_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg3ei16.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VLUXSEG3EI16_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLUXSEG3EI16_V ;
class LDI_H_DESC_VLUXSEG3EI16_V : MSA_I10_LDI_DESC_BASE_VLUXSEG3EI16_V <"ldi.h", ?>;
class LDI_H_ENC_VLUXSEG3EI16_V : MSA_I10_FMT_VLUXSEG3EI16_V <0b110, 0b01, 0b000111>;
def VLUXSEG3EI16_V : LDI_H_ENC_VLUXSEG3EI16_V , LDI_H_DESC_VLUXSEG3EI16_V , VLUXSEG3EI16_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG4EI16_V;
class MipsInst_VLUXSEG4EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG4EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG4EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG4EI16_V : MipsInst_VLUXSEG4EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG4EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLUXSEG4EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG4EI16_V ;
class LD_DESC_BASE_VLUXSEG4EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg4ei16.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLUXSEG4EI16_V : MSA_MI10_FMT_VLUXSEG4EI16_V <0b01, 0b1000>;
class LD_H_DESC_VLUXSEG4EI16_V : LD_DESC_BASE_VLUXSEG4EI16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLUXSEG4EI16_V : LD_H_ENC_VLUXSEG4EI16_V , LD_H_DESC_VLUXSEG4EI16_V , VLUXSEG4EI16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG5EI16_V;
class MipsInst_VLUXSEG5EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG5EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG5EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG5EI16_V : MipsInst_VLUXSEG5EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG5EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLUXSEG5EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG5EI16_V ;
class LD_DESC_BASE_VLUXSEG5EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg5ei16.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLUXSEG5EI16_V : MSA_MI10_FMT_VLUXSEG5EI16_V <0b01, 0b1000>;
class LD_H_DESC_VLUXSEG5EI16_V : LD_DESC_BASE_VLUXSEG5EI16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLUXSEG5EI16_V : LD_H_ENC_VLUXSEG5EI16_V , LD_H_DESC_VLUXSEG5EI16_V , VLUXSEG5EI16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG6EI16_V;
class MipsInst_VLUXSEG6EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG6EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG6EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG6EI16_V : MipsInst_VLUXSEG6EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG6EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLUXSEG6EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG6EI16_V ;
class LD_DESC_BASE_VLUXSEG6EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg6ei16.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLUXSEG6EI16_V : MSA_MI10_FMT_VLUXSEG6EI16_V <0b01, 0b1000>;
class LD_H_DESC_VLUXSEG6EI16_V : LD_DESC_BASE_VLUXSEG6EI16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLUXSEG6EI16_V : LD_H_ENC_VLUXSEG6EI16_V , LD_H_DESC_VLUXSEG6EI16_V , VLUXSEG6EI16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG7EI16_V;
class MipsInst_VLUXSEG7EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG7EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG7EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG7EI16_V : MipsInst_VLUXSEG7EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG7EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLUXSEG7EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG7EI16_V ;
class LD_DESC_BASE_VLUXSEG7EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg7ei16.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLUXSEG7EI16_V : MSA_MI10_FMT_VLUXSEG7EI16_V <0b01, 0b1000>;
class LD_H_DESC_VLUXSEG7EI16_V : LD_DESC_BASE_VLUXSEG7EI16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLUXSEG7EI16_V : LD_H_ENC_VLUXSEG7EI16_V , LD_H_DESC_VLUXSEG7EI16_V , VLUXSEG7EI16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG8EI16_V;
class MipsInst_VLUXSEG8EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG8EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG8EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG8EI16_V : MipsInst_VLUXSEG8EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG8EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLUXSEG8EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG8EI16_V ;
class LD_DESC_BASE_VLUXSEG8EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg8ei16.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLUXSEG8EI16_V : MSA_MI10_FMT_VLUXSEG8EI16_V <0b01, 0b1000>;
class LD_H_DESC_VLUXSEG8EI16_V : LD_DESC_BASE_VLUXSEG8EI16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLUXSEG8EI16_V : LD_H_ENC_VLUXSEG8EI16_V , LD_H_DESC_VLUXSEG8EI16_V , VLUXSEG8EI16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG2EI16_V;
class MipsInst_VLOXSEG2EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG2EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG2EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG2EI16_V : MipsInst_VLOXSEG2EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG2EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLOXSEG2EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG2EI16_V ;
class LD_DESC_BASE_VLOXSEG2EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg2ei16.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLOXSEG2EI16_V : MSA_MI10_FMT_VLOXSEG2EI16_V <0b01, 0b1000>;
class LD_H_DESC_VLOXSEG2EI16_V : LD_DESC_BASE_VLOXSEG2EI16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLOXSEG2EI16_V : LD_H_ENC_VLOXSEG2EI16_V , LD_H_DESC_VLOXSEG2EI16_V , VLOXSEG2EI16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG3EI16_V;
class MipsInst_VLOXSEG3EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG3EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG3EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG3EI16_V : MipsInst_VLOXSEG3EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG3EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLOXSEG3EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG3EI16_V ;
class LD_DESC_BASE_VLOXSEG3EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg3ei16.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLOXSEG3EI16_V : MSA_MI10_FMT_VLOXSEG3EI16_V <0b01, 0b1000>;
class LD_H_DESC_VLOXSEG3EI16_V : LD_DESC_BASE_VLOXSEG3EI16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLOXSEG3EI16_V : LD_H_ENC_VLOXSEG3EI16_V , LD_H_DESC_VLOXSEG3EI16_V , VLOXSEG3EI16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG4EI16_V;
class MipsInst_VLOXSEG4EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG4EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG4EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG4EI16_V : MipsInst_VLOXSEG4EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG4EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLOXSEG4EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG4EI16_V ;
class LD_DESC_BASE_VLOXSEG4EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg4ei16.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLOXSEG4EI16_V : MSA_MI10_FMT_VLOXSEG4EI16_V <0b01, 0b1000>;
class LD_H_DESC_VLOXSEG4EI16_V : LD_DESC_BASE_VLOXSEG4EI16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLOXSEG4EI16_V : LD_H_ENC_VLOXSEG4EI16_V , LD_H_DESC_VLOXSEG4EI16_V , VLOXSEG4EI16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG5EI16_V;
class MipsInst_VLOXSEG5EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG5EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG5EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG5EI16_V : MipsInst_VLOXSEG5EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG5EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLOXSEG5EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG5EI16_V ;
class LD_DESC_BASE_VLOXSEG5EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg5ei16.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLOXSEG5EI16_V : MSA_MI10_FMT_VLOXSEG5EI16_V <0b01, 0b1000>;
class LD_H_DESC_VLOXSEG5EI16_V : LD_DESC_BASE_VLOXSEG5EI16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLOXSEG5EI16_V : LD_H_ENC_VLOXSEG5EI16_V , LD_H_DESC_VLOXSEG5EI16_V , VLOXSEG5EI16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG6EI16_V;
class MipsInst_VLOXSEG6EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG6EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG6EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG6EI16_V : MipsInst_VLOXSEG6EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG6EI16_V {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VLOXSEG6EI16_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg6ei16.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VLOXSEG6EI16_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLOXSEG6EI16_V ;
class LDI_H_DESC_VLOXSEG6EI16_V : MSA_I10_LDI_DESC_BASE_VLOXSEG6EI16_V <"ldi.h", ?>;
class LDI_H_ENC_VLOXSEG6EI16_V : MSA_I10_FMT_VLOXSEG6EI16_V <0b110, 0b01, 0b000111>;
def VLOXSEG6EI16_V : LDI_H_ENC_VLOXSEG6EI16_V , LDI_H_DESC_VLOXSEG6EI16_V , VLOXSEG6EI16_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG7EI16_V;
class MipsInst_VLOXSEG7EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG7EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG7EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG7EI16_V : MipsInst_VLOXSEG7EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG7EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLOXSEG7EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG7EI16_V ;
class LD_DESC_BASE_VLOXSEG7EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg7ei16.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VLOXSEG7EI16_V : MSA_MI10_FMT_VLOXSEG7EI16_V <0b01, 0b1000>;
class LD_H_DESC_VLOXSEG7EI16_V : LD_DESC_BASE_VLOXSEG7EI16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VLOXSEG7EI16_V : LD_H_ENC_VLOXSEG7EI16_V , LD_H_DESC_VLOXSEG7EI16_V , VLOXSEG7EI16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG8EI16_V;
class MipsInst_VLOXSEG8EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG8EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG8EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG8EI16_V : MipsInst_VLOXSEG8EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG8EI16_V {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VLOXSEG8EI16_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg8ei16.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VLOXSEG8EI16_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLOXSEG8EI16_V ;
class LDI_H_DESC_VLOXSEG8EI16_V : MSA_I10_LDI_DESC_BASE_VLOXSEG8EI16_V <"ldi.h", ?>;
class LDI_H_ENC_VLOXSEG8EI16_V : MSA_I10_FMT_VLOXSEG8EI16_V <0b110, 0b01, 0b000111>;
def VLOXSEG8EI16_V : LDI_H_ENC_VLOXSEG8EI16_V , LDI_H_DESC_VLOXSEG8EI16_V , VLOXSEG8EI16_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VL1RE16_V;
class MipsInst_VL1RE16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VL1RE16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VL1RE16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VL1RE16_V : MipsInst_VL1RE16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VL1RE16_V {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VL1RE16_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1);
	string  AsmString="vl1re16.v	$vd, (${rs1})";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VL1RE16_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VL1RE16_V ;
class LDI_H_DESC_VL1RE16_V : MSA_I10_LDI_DESC_BASE_VL1RE16_V <"ldi.h", ?>;
class LDI_H_ENC_VL1RE16_V : MSA_I10_FMT_VL1RE16_V <0b110, 0b01, 0b000111>;
def VL1RE16_V : LDI_H_ENC_VL1RE16_V , LDI_H_DESC_VL1RE16_V , VL1RE16_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VL2RE16_V;
class MipsInst_VL2RE16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VL2RE16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VL2RE16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VL2RE16_V : MipsInst_VL2RE16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VL2RE16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VL2RE16_V<bits<2>  df, bits<4>  minor> : MSAInst_VL2RE16_V ;
class LD_DESC_BASE_VL2RE16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1);
	string  AsmString="vl2re16.v	$vd, (${rs1})";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VL2RE16_V : MSA_MI10_FMT_VL2RE16_V <0b01, 0b1000>;
class LD_H_DESC_VL2RE16_V : LD_DESC_BASE_VL2RE16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VL2RE16_V : LD_H_ENC_VL2RE16_V , LD_H_DESC_VL2RE16_V , VL2RE16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VL4RE16_V;
class MipsInst_VL4RE16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VL4RE16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VL4RE16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VL4RE16_V : MipsInst_VL4RE16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VL4RE16_V {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VL4RE16_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1);
	string  AsmString="vl4re16.v	$vd, (${rs1})";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VL4RE16_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VL4RE16_V ;
class LDI_H_DESC_VL4RE16_V : MSA_I10_LDI_DESC_BASE_VL4RE16_V <"ldi.h", ?>;
class LDI_H_ENC_VL4RE16_V : MSA_I10_FMT_VL4RE16_V <0b110, 0b01, 0b000111>;
def VL4RE16_V : LDI_H_ENC_VL4RE16_V , LDI_H_DESC_VL4RE16_V , VL4RE16_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VL8RE16_V;
class MipsInst_VL8RE16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VL8RE16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VL8RE16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VL8RE16_V : MipsInst_VL8RE16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VL8RE16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VL8RE16_V<bits<2>  df, bits<4>  minor> : MSAInst_VL8RE16_V ;
class LD_DESC_BASE_VL8RE16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1);
	string  AsmString="vl8re16.v	$vd, (${rs1})";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_H_ENC_VL8RE16_V : MSA_MI10_FMT_VL8RE16_V <0b01, 0b1000>;
class LD_H_DESC_VL8RE16_V : LD_DESC_BASE_VL8RE16_V <"ld.h", null_frag, ?, ?, ?, addr>;
def VL8RE16_V : LD_H_ENC_VL8RE16_V , LD_H_DESC_VL8RE16_V , VL8RE16_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLE32_V;
class MipsInst_VLE32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLE32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLE32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLE32_V : MipsInst_VLE32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLE32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLE32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLE32_V ;
class LD_DESC_BASE_VLE32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vle32.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLE32_V : MSA_MI10_FMT_VLE32_V <0b10, 0b1000>;
class LD_W_DESC_VLE32_V : LD_DESC_BASE_VLE32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLE32_V : LD_W_ENC_VLE32_V , LD_W_DESC_VLE32_V , VLE32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLSE32_V;
class MipsInst_VLSE32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSE32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSE32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSE32_V : MipsInst_VLSE32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSE32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSE32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSE32_V ;
class LD_DESC_BASE_VLSE32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlse32.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLSE32_V : MSA_MI10_FMT_VLSE32_V <0b10, 0b1000>;
class LD_W_DESC_VLSE32_V : LD_DESC_BASE_VLSE32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLSE32_V : LD_W_ENC_VLSE32_V , LD_W_DESC_VLSE32_V , VLSE32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLUXEI32_V;
class MipsInst_VLUXEI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXEI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXEI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXEI32_V : MipsInst_VLUXEI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXEI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLUXEI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXEI32_V ;
class LD_DESC_BASE_VLUXEI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxei32.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLUXEI32_V : MSA_MI10_FMT_VLUXEI32_V <0b10, 0b1000>;
class LD_W_DESC_VLUXEI32_V : LD_DESC_BASE_VLUXEI32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLUXEI32_V : LD_W_ENC_VLUXEI32_V , LD_W_DESC_VLUXEI32_V , VLUXEI32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLOXEI32_V;
class MipsInst_VLOXEI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXEI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXEI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXEI32_V : MipsInst_VLOXEI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXEI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLOXEI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXEI32_V ;
class LD_DESC_BASE_VLOXEI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxei32.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLOXEI32_V : MSA_MI10_FMT_VLOXEI32_V <0b10, 0b1000>;
class LD_W_DESC_VLOXEI32_V : LD_DESC_BASE_VLOXEI32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLOXEI32_V : LD_W_ENC_VLOXEI32_V , LD_W_DESC_VLOXEI32_V , VLOXEI32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLE32FF_V;
class MipsInst_VLE32FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLE32FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLE32FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLE32FF_V : MipsInst_VLE32FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLE32FF_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLE32FF_V<bits<2>  df, bits<4>  minor> : MSAInst_VLE32FF_V ;
class LD_DESC_BASE_VLE32FF_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vle32ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLE32FF_V : MSA_MI10_FMT_VLE32FF_V <0b10, 0b1000>;
class LD_W_DESC_VLE32FF_V : LD_DESC_BASE_VLE32FF_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLE32FF_V : LD_W_ENC_VLE32FF_V , LD_W_DESC_VLE32FF_V , VLE32FF_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VLSEG2E32_V;
class MipsInst_VLSEG2E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG2E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG2E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG2E32_V : MipsInst_VLSEG2E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG2E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG2E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG2E32_V ;
class LD_DESC_BASE_VLSEG2E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg2e32.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLSEG2E32_V : MSA_MI10_FMT_VLSEG2E32_V <0b10, 0b1000>;
class LD_W_DESC_VLSEG2E32_V : LD_DESC_BASE_VLSEG2E32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLSEG2E32_V : LD_W_ENC_VLSEG2E32_V , LD_W_DESC_VLSEG2E32_V , VLSEG2E32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG3E32_V;
class MipsInst_VLSEG3E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG3E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG3E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG3E32_V : MipsInst_VLSEG3E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG3E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG3E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG3E32_V ;
class LD_DESC_BASE_VLSEG3E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg3e32.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLSEG3E32_V : MSA_MI10_FMT_VLSEG3E32_V <0b10, 0b1000>;
class LD_W_DESC_VLSEG3E32_V : LD_DESC_BASE_VLSEG3E32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLSEG3E32_V : LD_W_ENC_VLSEG3E32_V , LD_W_DESC_VLSEG3E32_V , VLSEG3E32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG4E32_V;
class MipsInst_VLSEG4E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG4E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG4E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG4E32_V : MipsInst_VLSEG4E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG4E32_V {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VLSEG4E32_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg4e32.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VLSEG4E32_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG4E32_V ;
class LDI_W_DESC_VLSEG4E32_V : MSA_I10_LDI_DESC_BASE_VLSEG4E32_V <"ldi.w", ?>;
class LDI_W_ENC_VLSEG4E32_V : MSA_I10_FMT_VLSEG4E32_V <0b110, 0b10, 0b000111>;
def VLSEG4E32_V : LDI_W_ENC_VLSEG4E32_V , LDI_W_DESC_VLSEG4E32_V , VLSEG4E32_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG5E32_V;
class MipsInst_VLSEG5E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG5E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG5E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG5E32_V : MipsInst_VLSEG5E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG5E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG5E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG5E32_V ;
class LD_DESC_BASE_VLSEG5E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg5e32.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLSEG5E32_V : MSA_MI10_FMT_VLSEG5E32_V <0b10, 0b1000>;
class LD_W_DESC_VLSEG5E32_V : LD_DESC_BASE_VLSEG5E32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLSEG5E32_V : LD_W_ENC_VLSEG5E32_V , LD_W_DESC_VLSEG5E32_V , VLSEG5E32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG6E32_V;
class MipsInst_VLSEG6E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG6E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG6E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG6E32_V : MipsInst_VLSEG6E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG6E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG6E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG6E32_V ;
class LD_DESC_BASE_VLSEG6E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg6e32.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLSEG6E32_V : MSA_MI10_FMT_VLSEG6E32_V <0b10, 0b1000>;
class LD_W_DESC_VLSEG6E32_V : LD_DESC_BASE_VLSEG6E32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLSEG6E32_V : LD_W_ENC_VLSEG6E32_V , LD_W_DESC_VLSEG6E32_V , VLSEG6E32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG7E32_V;
class MipsInst_VLSEG7E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG7E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG7E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG7E32_V : MipsInst_VLSEG7E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG7E32_V {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VLSEG7E32_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg7e32.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VLSEG7E32_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG7E32_V ;
class LDI_W_DESC_VLSEG7E32_V : MSA_I10_LDI_DESC_BASE_VLSEG7E32_V <"ldi.w", ?>;
class LDI_W_ENC_VLSEG7E32_V : MSA_I10_FMT_VLSEG7E32_V <0b110, 0b10, 0b000111>;
def VLSEG7E32_V : LDI_W_ENC_VLSEG7E32_V , LDI_W_DESC_VLSEG7E32_V , VLSEG7E32_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG8E32_V;
class MipsInst_VLSEG8E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG8E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG8E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG8E32_V : MipsInst_VLSEG8E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG8E32_V {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VLSEG8E32_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg8e32.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VLSEG8E32_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG8E32_V ;
class LDI_W_DESC_VLSEG8E32_V : MSA_I10_LDI_DESC_BASE_VLSEG8E32_V <"ldi.w", ?>;
class LDI_W_ENC_VLSEG8E32_V : MSA_I10_FMT_VLSEG8E32_V <0b110, 0b10, 0b000111>;
def VLSEG8E32_V : LDI_W_ENC_VLSEG8E32_V , LDI_W_DESC_VLSEG8E32_V , VLSEG8E32_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG2E32FF_V;
class MipsInst_VLSEG2E32FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG2E32FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG2E32FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG2E32FF_V : MipsInst_VLSEG2E32FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG2E32FF_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG2E32FF_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG2E32FF_V ;
class LD_DESC_BASE_VLSEG2E32FF_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg2e32ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLSEG2E32FF_V : MSA_MI10_FMT_VLSEG2E32FF_V <0b10, 0b1000>;
class LD_W_DESC_VLSEG2E32FF_V : LD_DESC_BASE_VLSEG2E32FF_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLSEG2E32FF_V : LD_W_ENC_VLSEG2E32FF_V , LD_W_DESC_VLSEG2E32FF_V , VLSEG2E32FF_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG3E32FF_V;
class MipsInst_VLSEG3E32FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG3E32FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG3E32FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG3E32FF_V : MipsInst_VLSEG3E32FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG3E32FF_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG3E32FF_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG3E32FF_V ;
class LD_DESC_BASE_VLSEG3E32FF_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg3e32ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLSEG3E32FF_V : MSA_MI10_FMT_VLSEG3E32FF_V <0b10, 0b1000>;
class LD_W_DESC_VLSEG3E32FF_V : LD_DESC_BASE_VLSEG3E32FF_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLSEG3E32FF_V : LD_W_ENC_VLSEG3E32FF_V , LD_W_DESC_VLSEG3E32FF_V , VLSEG3E32FF_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG4E32FF_V;
class MipsInst_VLSEG4E32FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG4E32FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG4E32FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG4E32FF_V : MipsInst_VLSEG4E32FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG4E32FF_V {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VLSEG4E32FF_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg4e32ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VLSEG4E32FF_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG4E32FF_V ;
class LDI_W_DESC_VLSEG4E32FF_V : MSA_I10_LDI_DESC_BASE_VLSEG4E32FF_V <"ldi.w", ?>;
class LDI_W_ENC_VLSEG4E32FF_V : MSA_I10_FMT_VLSEG4E32FF_V <0b110, 0b10, 0b000111>;
def VLSEG4E32FF_V : LDI_W_ENC_VLSEG4E32FF_V , LDI_W_DESC_VLSEG4E32FF_V , VLSEG4E32FF_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG5E32FF_V;
class MipsInst_VLSEG5E32FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG5E32FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG5E32FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG5E32FF_V : MipsInst_VLSEG5E32FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG5E32FF_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG5E32FF_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG5E32FF_V ;
class LD_DESC_BASE_VLSEG5E32FF_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg5e32ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLSEG5E32FF_V : MSA_MI10_FMT_VLSEG5E32FF_V <0b10, 0b1000>;
class LD_W_DESC_VLSEG5E32FF_V : LD_DESC_BASE_VLSEG5E32FF_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLSEG5E32FF_V : LD_W_ENC_VLSEG5E32FF_V , LD_W_DESC_VLSEG5E32FF_V , VLSEG5E32FF_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG6E32FF_V;
class MipsInst_VLSEG6E32FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG6E32FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG6E32FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG6E32FF_V : MipsInst_VLSEG6E32FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG6E32FF_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG6E32FF_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG6E32FF_V ;
class LD_DESC_BASE_VLSEG6E32FF_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg6e32ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLSEG6E32FF_V : MSA_MI10_FMT_VLSEG6E32FF_V <0b10, 0b1000>;
class LD_W_DESC_VLSEG6E32FF_V : LD_DESC_BASE_VLSEG6E32FF_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLSEG6E32FF_V : LD_W_ENC_VLSEG6E32FF_V , LD_W_DESC_VLSEG6E32FF_V , VLSEG6E32FF_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG7E32FF_V;
class MipsInst_VLSEG7E32FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG7E32FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG7E32FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG7E32FF_V : MipsInst_VLSEG7E32FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG7E32FF_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSEG7E32FF_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSEG7E32FF_V ;
class LD_DESC_BASE_VLSEG7E32FF_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg7e32ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLSEG7E32FF_V : MSA_MI10_FMT_VLSEG7E32FF_V <0b10, 0b1000>;
class LD_W_DESC_VLSEG7E32FF_V : LD_DESC_BASE_VLSEG7E32FF_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLSEG7E32FF_V : LD_W_ENC_VLSEG7E32FF_V , LD_W_DESC_VLSEG7E32FF_V , VLSEG7E32FF_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSEG8E32FF_V;
class MipsInst_VLSEG8E32FF_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSEG8E32FF_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSEG8E32FF_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSEG8E32FF_V : MipsInst_VLSEG8E32FF_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSEG8E32FF_V {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VLSEG8E32FF_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vlseg8e32ff.v	$vd, (${rs1})$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VLSEG8E32FF_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VLSEG8E32FF_V ;
class LDI_W_DESC_VLSEG8E32FF_V : MSA_I10_LDI_DESC_BASE_VLSEG8E32FF_V <"ldi.w", ?>;
class LDI_W_ENC_VLSEG8E32FF_V : MSA_I10_FMT_VLSEG8E32FF_V <0b110, 0b10, 0b000111>;
def VLSEG8E32FF_V : LDI_W_ENC_VLSEG8E32FF_V , LDI_W_DESC_VLSEG8E32FF_V , VLSEG8E32FF_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG2E32_V;
class MipsInst_VLSSEG2E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG2E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG2E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG2E32_V : MipsInst_VLSSEG2E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG2E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSSEG2E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG2E32_V ;
class LD_DESC_BASE_VLSSEG2E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg2e32.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLSSEG2E32_V : MSA_MI10_FMT_VLSSEG2E32_V <0b10, 0b1000>;
class LD_W_DESC_VLSSEG2E32_V : LD_DESC_BASE_VLSSEG2E32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLSSEG2E32_V : LD_W_ENC_VLSSEG2E32_V , LD_W_DESC_VLSSEG2E32_V , VLSSEG2E32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG3E32_V;
class MipsInst_VLSSEG3E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG3E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG3E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG3E32_V : MipsInst_VLSSEG3E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG3E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSSEG3E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG3E32_V ;
class LD_DESC_BASE_VLSSEG3E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg3e32.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLSSEG3E32_V : MSA_MI10_FMT_VLSSEG3E32_V <0b10, 0b1000>;
class LD_W_DESC_VLSSEG3E32_V : LD_DESC_BASE_VLSSEG3E32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLSSEG3E32_V : LD_W_ENC_VLSSEG3E32_V , LD_W_DESC_VLSSEG3E32_V , VLSSEG3E32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG4E32_V;
class MipsInst_VLSSEG4E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG4E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG4E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG4E32_V : MipsInst_VLSSEG4E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG4E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSSEG4E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG4E32_V ;
class LD_DESC_BASE_VLSSEG4E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg4e32.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLSSEG4E32_V : MSA_MI10_FMT_VLSSEG4E32_V <0b10, 0b1000>;
class LD_W_DESC_VLSSEG4E32_V : LD_DESC_BASE_VLSSEG4E32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLSSEG4E32_V : LD_W_ENC_VLSSEG4E32_V , LD_W_DESC_VLSSEG4E32_V , VLSSEG4E32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG5E32_V;
class MipsInst_VLSSEG5E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG5E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG5E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG5E32_V : MipsInst_VLSSEG5E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG5E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSSEG5E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG5E32_V ;
class LD_DESC_BASE_VLSSEG5E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg5e32.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLSSEG5E32_V : MSA_MI10_FMT_VLSSEG5E32_V <0b10, 0b1000>;
class LD_W_DESC_VLSSEG5E32_V : LD_DESC_BASE_VLSSEG5E32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLSSEG5E32_V : LD_W_ENC_VLSSEG5E32_V , LD_W_DESC_VLSSEG5E32_V , VLSSEG5E32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG6E32_V;
class MipsInst_VLSSEG6E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG6E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG6E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG6E32_V : MipsInst_VLSSEG6E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG6E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSSEG6E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG6E32_V ;
class LD_DESC_BASE_VLSSEG6E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg6e32.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLSSEG6E32_V : MSA_MI10_FMT_VLSSEG6E32_V <0b10, 0b1000>;
class LD_W_DESC_VLSSEG6E32_V : LD_DESC_BASE_VLSSEG6E32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLSSEG6E32_V : LD_W_ENC_VLSSEG6E32_V , LD_W_DESC_VLSSEG6E32_V , VLSSEG6E32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG7E32_V;
class MipsInst_VLSSEG7E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG7E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG7E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG7E32_V : MipsInst_VLSSEG7E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG7E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSSEG7E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG7E32_V ;
class LD_DESC_BASE_VLSSEG7E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg7e32.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLSSEG7E32_V : MSA_MI10_FMT_VLSSEG7E32_V <0b10, 0b1000>;
class LD_W_DESC_VLSSEG7E32_V : LD_DESC_BASE_VLSSEG7E32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLSSEG7E32_V : LD_W_ENC_VLSSEG7E32_V , LD_W_DESC_VLSSEG7E32_V , VLSSEG7E32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLSSEG8E32_V;
class MipsInst_VLSSEG8E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLSSEG8E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLSSEG8E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLSSEG8E32_V : MipsInst_VLSSEG8E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLSSEG8E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLSSEG8E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLSSEG8E32_V ;
class LD_DESC_BASE_VLSSEG8E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vlsseg8e32.v	$vd, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLSSEG8E32_V : MSA_MI10_FMT_VLSSEG8E32_V <0b10, 0b1000>;
class LD_W_DESC_VLSSEG8E32_V : LD_DESC_BASE_VLSSEG8E32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLSSEG8E32_V : LD_W_ENC_VLSSEG8E32_V , LD_W_DESC_VLSSEG8E32_V , VLSSEG8E32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG2EI32_V;
class MipsInst_VLUXSEG2EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG2EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG2EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG2EI32_V : MipsInst_VLUXSEG2EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG2EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLUXSEG2EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG2EI32_V ;
class LD_DESC_BASE_VLUXSEG2EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg2ei32.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLUXSEG2EI32_V : MSA_MI10_FMT_VLUXSEG2EI32_V <0b10, 0b1000>;
class LD_W_DESC_VLUXSEG2EI32_V : LD_DESC_BASE_VLUXSEG2EI32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLUXSEG2EI32_V : LD_W_ENC_VLUXSEG2EI32_V , LD_W_DESC_VLUXSEG2EI32_V , VLUXSEG2EI32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG3EI32_V;
class MipsInst_VLUXSEG3EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG3EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG3EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG3EI32_V : MipsInst_VLUXSEG3EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG3EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLUXSEG3EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG3EI32_V ;
class LD_DESC_BASE_VLUXSEG3EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg3ei32.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLUXSEG3EI32_V : MSA_MI10_FMT_VLUXSEG3EI32_V <0b10, 0b1000>;
class LD_W_DESC_VLUXSEG3EI32_V : LD_DESC_BASE_VLUXSEG3EI32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLUXSEG3EI32_V : LD_W_ENC_VLUXSEG3EI32_V , LD_W_DESC_VLUXSEG3EI32_V , VLUXSEG3EI32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG4EI32_V;
class MipsInst_VLUXSEG4EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG4EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG4EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG4EI32_V : MipsInst_VLUXSEG4EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG4EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLUXSEG4EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG4EI32_V ;
class LD_DESC_BASE_VLUXSEG4EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg4ei32.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLUXSEG4EI32_V : MSA_MI10_FMT_VLUXSEG4EI32_V <0b10, 0b1000>;
class LD_W_DESC_VLUXSEG4EI32_V : LD_DESC_BASE_VLUXSEG4EI32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLUXSEG4EI32_V : LD_W_ENC_VLUXSEG4EI32_V , LD_W_DESC_VLUXSEG4EI32_V , VLUXSEG4EI32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG5EI32_V;
class MipsInst_VLUXSEG5EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG5EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG5EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG5EI32_V : MipsInst_VLUXSEG5EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG5EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLUXSEG5EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG5EI32_V ;
class LD_DESC_BASE_VLUXSEG5EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg5ei32.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLUXSEG5EI32_V : MSA_MI10_FMT_VLUXSEG5EI32_V <0b10, 0b1000>;
class LD_W_DESC_VLUXSEG5EI32_V : LD_DESC_BASE_VLUXSEG5EI32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLUXSEG5EI32_V : LD_W_ENC_VLUXSEG5EI32_V , LD_W_DESC_VLUXSEG5EI32_V , VLUXSEG5EI32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG6EI32_V;
class MipsInst_VLUXSEG6EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG6EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG6EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG6EI32_V : MipsInst_VLUXSEG6EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG6EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLUXSEG6EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG6EI32_V ;
class LD_DESC_BASE_VLUXSEG6EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg6ei32.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLUXSEG6EI32_V : MSA_MI10_FMT_VLUXSEG6EI32_V <0b10, 0b1000>;
class LD_W_DESC_VLUXSEG6EI32_V : LD_DESC_BASE_VLUXSEG6EI32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLUXSEG6EI32_V : LD_W_ENC_VLUXSEG6EI32_V , LD_W_DESC_VLUXSEG6EI32_V , VLUXSEG6EI32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG7EI32_V;
class MipsInst_VLUXSEG7EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG7EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG7EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG7EI32_V : MipsInst_VLUXSEG7EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG7EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLUXSEG7EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG7EI32_V ;
class LD_DESC_BASE_VLUXSEG7EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg7ei32.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLUXSEG7EI32_V : MSA_MI10_FMT_VLUXSEG7EI32_V <0b10, 0b1000>;
class LD_W_DESC_VLUXSEG7EI32_V : LD_DESC_BASE_VLUXSEG7EI32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLUXSEG7EI32_V : LD_W_ENC_VLUXSEG7EI32_V , LD_W_DESC_VLUXSEG7EI32_V , VLUXSEG7EI32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLUXSEG8EI32_V;
class MipsInst_VLUXSEG8EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLUXSEG8EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLUXSEG8EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLUXSEG8EI32_V : MipsInst_VLUXSEG8EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLUXSEG8EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLUXSEG8EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLUXSEG8EI32_V ;
class LD_DESC_BASE_VLUXSEG8EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vluxseg8ei32.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLUXSEG8EI32_V : MSA_MI10_FMT_VLUXSEG8EI32_V <0b10, 0b1000>;
class LD_W_DESC_VLUXSEG8EI32_V : LD_DESC_BASE_VLUXSEG8EI32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLUXSEG8EI32_V : LD_W_ENC_VLUXSEG8EI32_V , LD_W_DESC_VLUXSEG8EI32_V , VLUXSEG8EI32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG2EI32_V;
class MipsInst_VLOXSEG2EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG2EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG2EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG2EI32_V : MipsInst_VLOXSEG2EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG2EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLOXSEG2EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG2EI32_V ;
class LD_DESC_BASE_VLOXSEG2EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg2ei32.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLOXSEG2EI32_V : MSA_MI10_FMT_VLOXSEG2EI32_V <0b10, 0b1000>;
class LD_W_DESC_VLOXSEG2EI32_V : LD_DESC_BASE_VLOXSEG2EI32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLOXSEG2EI32_V : LD_W_ENC_VLOXSEG2EI32_V , LD_W_DESC_VLOXSEG2EI32_V , VLOXSEG2EI32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG3EI32_V;
class MipsInst_VLOXSEG3EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG3EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG3EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG3EI32_V : MipsInst_VLOXSEG3EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG3EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLOXSEG3EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG3EI32_V ;
class LD_DESC_BASE_VLOXSEG3EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg3ei32.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLOXSEG3EI32_V : MSA_MI10_FMT_VLOXSEG3EI32_V <0b10, 0b1000>;
class LD_W_DESC_VLOXSEG3EI32_V : LD_DESC_BASE_VLOXSEG3EI32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLOXSEG3EI32_V : LD_W_ENC_VLOXSEG3EI32_V , LD_W_DESC_VLOXSEG3EI32_V , VLOXSEG3EI32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG4EI32_V;
class MipsInst_VLOXSEG4EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG4EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG4EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG4EI32_V : MipsInst_VLOXSEG4EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG4EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLOXSEG4EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG4EI32_V ;
class LD_DESC_BASE_VLOXSEG4EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg4ei32.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLOXSEG4EI32_V : MSA_MI10_FMT_VLOXSEG4EI32_V <0b10, 0b1000>;
class LD_W_DESC_VLOXSEG4EI32_V : LD_DESC_BASE_VLOXSEG4EI32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLOXSEG4EI32_V : LD_W_ENC_VLOXSEG4EI32_V , LD_W_DESC_VLOXSEG4EI32_V , VLOXSEG4EI32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG5EI32_V;
class MipsInst_VLOXSEG5EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG5EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG5EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG5EI32_V : MipsInst_VLOXSEG5EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG5EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLOXSEG5EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG5EI32_V ;
class LD_DESC_BASE_VLOXSEG5EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg5ei32.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLOXSEG5EI32_V : MSA_MI10_FMT_VLOXSEG5EI32_V <0b10, 0b1000>;
class LD_W_DESC_VLOXSEG5EI32_V : LD_DESC_BASE_VLOXSEG5EI32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLOXSEG5EI32_V : LD_W_ENC_VLOXSEG5EI32_V , LD_W_DESC_VLOXSEG5EI32_V , VLOXSEG5EI32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG6EI32_V;
class MipsInst_VLOXSEG6EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG6EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG6EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG6EI32_V : MipsInst_VLOXSEG6EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG6EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLOXSEG6EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG6EI32_V ;
class LD_DESC_BASE_VLOXSEG6EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg6ei32.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLOXSEG6EI32_V : MSA_MI10_FMT_VLOXSEG6EI32_V <0b10, 0b1000>;
class LD_W_DESC_VLOXSEG6EI32_V : LD_DESC_BASE_VLOXSEG6EI32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLOXSEG6EI32_V : LD_W_ENC_VLOXSEG6EI32_V , LD_W_DESC_VLOXSEG6EI32_V , VLOXSEG6EI32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG7EI32_V;
class MipsInst_VLOXSEG7EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG7EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG7EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG7EI32_V : MipsInst_VLOXSEG7EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG7EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLOXSEG7EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG7EI32_V ;
class LD_DESC_BASE_VLOXSEG7EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg7ei32.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLOXSEG7EI32_V : MSA_MI10_FMT_VLOXSEG7EI32_V <0b10, 0b1000>;
class LD_W_DESC_VLOXSEG7EI32_V : LD_DESC_BASE_VLOXSEG7EI32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLOXSEG7EI32_V : LD_W_ENC_VLOXSEG7EI32_V , LD_W_DESC_VLOXSEG7EI32_V , VLOXSEG7EI32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VLOXSEG8EI32_V;
class MipsInst_VLOXSEG8EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VLOXSEG8EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VLOXSEG8EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VLOXSEG8EI32_V : MipsInst_VLOXSEG8EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VLOXSEG8EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VLOXSEG8EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VLOXSEG8EI32_V ;
class LD_DESC_BASE_VLOXSEG8EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vloxseg8ei32.v	$vd, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VLOXSEG8EI32_V : MSA_MI10_FMT_VLOXSEG8EI32_V <0b10, 0b1000>;
class LD_W_DESC_VLOXSEG8EI32_V : LD_DESC_BASE_VLOXSEG8EI32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VLOXSEG8EI32_V : LD_W_ENC_VLOXSEG8EI32_V , LD_W_DESC_VLOXSEG8EI32_V , VLOXSEG8EI32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VL1RE32_V;
class MipsInst_VL1RE32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VL1RE32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VL1RE32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VL1RE32_V : MipsInst_VL1RE32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VL1RE32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VL1RE32_V<bits<2>  df, bits<4>  minor> : MSAInst_VL1RE32_V ;
class LD_DESC_BASE_VL1RE32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1);
	string  AsmString="vl1re32.v	$vd, (${rs1})";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VL1RE32_V : MSA_MI10_FMT_VL1RE32_V <0b10, 0b1000>;
class LD_W_DESC_VL1RE32_V : LD_DESC_BASE_VL1RE32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VL1RE32_V : LD_W_ENC_VL1RE32_V , LD_W_DESC_VL1RE32_V , VL1RE32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VL2RE32_V;
class MipsInst_VL2RE32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VL2RE32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VL2RE32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VL2RE32_V : MipsInst_VL2RE32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VL2RE32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VL2RE32_V<bits<2>  df, bits<4>  minor> : MSAInst_VL2RE32_V ;
class LD_DESC_BASE_VL2RE32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1);
	string  AsmString="vl2re32.v	$vd, (${rs1})";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VL2RE32_V : MSA_MI10_FMT_VL2RE32_V <0b10, 0b1000>;
class LD_W_DESC_VL2RE32_V : LD_DESC_BASE_VL2RE32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VL2RE32_V : LD_W_ENC_VL2RE32_V , LD_W_DESC_VL2RE32_V , VL2RE32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VL4RE32_V;
class MipsInst_VL4RE32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VL4RE32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VL4RE32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VL4RE32_V : MipsInst_VL4RE32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VL4RE32_V {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VL4RE32_V<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1);
	string  AsmString="vl4re32.v	$vd, (${rs1})";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VL4RE32_V<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VL4RE32_V ;
class LDI_W_DESC_VL4RE32_V : MSA_I10_LDI_DESC_BASE_VL4RE32_V <"ldi.w", ?>;
class LDI_W_ENC_VL4RE32_V : MSA_I10_FMT_VL4RE32_V <0b110, 0b10, 0b000111>;
def VL4RE32_V : LDI_W_ENC_VL4RE32_V , LDI_W_DESC_VL4RE32_V , VL4RE32_V_AUX {
	  	let mayLoad = 1;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VL8RE32_V;
class MipsInst_VL8RE32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VL8RE32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VL8RE32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VL8RE32_V : MipsInst_VL8RE32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VL8RE32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VL8RE32_V<bits<2>  df, bits<4>  minor> : MSAInst_VL8RE32_V ;
class LD_DESC_BASE_VL8RE32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1);
	string  AsmString="vl8re32.v	$vd, (${rs1})";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class LD_W_ENC_VL8RE32_V : MSA_MI10_FMT_VL8RE32_V <0b10, 0b1000>;
class LD_W_DESC_VL8RE32_V : LD_DESC_BASE_VL8RE32_V <"ld.w", null_frag, ?, ?, ?, addr>;
def VL8RE32_V : LD_W_ENC_VL8RE32_V , LD_W_DESC_VL8RE32_V , VL8RE32_V_AUX {
	  	let mayLoad = 1;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMACC_VV;
class MipsInst_VMACC_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMACC_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMACC_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMACC_VV : MipsInst_VMACC_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMACC_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VMACC_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMACC_VV ;
class MSA_3R_4R_DESC_BASE_VMACC_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vmacc.vv	$vd, $vs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="";
}
class DPSUB_S_W_ENC_VMACC_VV : MSA_3R_FMT_VMACC_VV <0b100, 0b10, 0b010011>;
class DPSUB_S_W_DESC_VMACC_VV : MSA_3R_4R_DESC_BASE_VMACC_VV <"dpsub_s.w", null_frag, ?, ?, ?>;
def VMACC_VV : DPSUB_S_W_ENC_VMACC_VV , DPSUB_S_W_DESC_VMACC_VV , VMACC_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWMACCU_VV;
class MipsInst_VWMACCU_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWMACCU_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWMACCU_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWMACCU_VV : MipsInst_VWMACCU_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWMACCU_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VWMACCU_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vwmaccu.vv	$vd, $vs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VWMACCU_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWMACCU_VV ;
class HSUB_U_W_DESC_VWMACCU_VV : MSA_3R_DESC_BASE_VWMACCU_VV <"hsub_u.w", null_frag, ?, ?, ?>;
class HSUB_U_W_ENC_VWMACCU_VV : MSA_3R_FMT_VWMACCU_VV <0b111, 0b10, 0b010101>;
def VWMACCU_VV : HSUB_U_W_ENC_VWMACCU_VV , HSUB_U_W_DESC_VWMACCU_VV , VWMACCU_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWMACC_VV;
class MipsInst_VWMACC_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWMACC_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWMACC_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWMACC_VV : MipsInst_VWMACC_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWMACC_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VWMACC_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWMACC_VV ;
class MSA_3R_4R_DESC_BASE_VWMACC_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vwmacc.vv	$vd, $vs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="@earlyclobber $vd";
}
class DPSUB_U_W_ENC_VWMACC_VV : MSA_3R_FMT_VWMACC_VV <0b101, 0b10, 0b010011>;
class DPSUB_U_W_DESC_VWMACC_VV : MSA_3R_4R_DESC_BASE_VWMACC_VV <"dpsub_u.w", null_frag, ?, ?, ?>;
def VWMACC_VV : DPSUB_U_W_ENC_VWMACC_VV , DPSUB_U_W_DESC_VWMACC_VV , VWMACC_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWMACCSU_VV;
class MipsInst_VWMACCSU_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWMACCSU_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWMACCSU_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWMACCSU_VV : MipsInst_VWMACCSU_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWMACCSU_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VWMACCSU_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vwmaccsu.vv	$vd, $vs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VWMACCSU_VV{
	bit  isCommutable=false;
}
class MSA_3R_FMT_VWMACCSU_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWMACCSU_VV ;
class DOTP_U_W_DESC_VWMACCSU_VV : MSA_3R_DESC_BASE_VWMACCSU_VV <"dotp_u.w", null_frag, ?, ?, ?>, IsCommutable_VWMACCSU_VV ;
class DOTP_U_W_ENC_VWMACCSU_VV : MSA_3R_FMT_VWMACCSU_VV <0b001, 0b10, 0b010011>;
def VWMACCSU_VV : DOTP_U_W_ENC_VWMACCSU_VV , DOTP_U_W_DESC_VWMACCSU_VV , VWMACCSU_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMADD_VX;
class MipsInst_VMADD_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMADD_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMADD_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_4R_DESC_BASE_VMADD_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vmadd.vx	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="";
}
class MSAInst_VMADD_VX : MipsInst_VMADD_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMADD_VX {
	let  EncodingPredicates=[];
}
class MSA_3RF_4RF_DESC_BASE_VMADD_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_4R_DESC_BASE_VMADD_VX <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VMADD_VX<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMADD_VX ;
class MSUB_Q_W_DESC_VMADD_VX : MSA_3RF_4RF_DESC_BASE_VMADD_VX <"msub_q.w", null_frag, ?>;
class MSUB_Q_W_ENC_VMADD_VX : MSA_3RF_FMT_VMADD_VX <0b0110, 0b1, 0b011100>;
def VMADD_VX : MSUB_Q_W_ENC_VMADD_VX , MSUB_Q_W_DESC_VMADD_VX , VMADD_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMACC_VX;
class MipsInst_VMACC_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMACC_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMACC_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMACC_VX : MipsInst_VMACC_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMACC_VX {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VMACC_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vmacc.vx	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VMACC_VX<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMACC_VX ;
class FSQRT_W_DESC_VMACC_VX : MSA_2RF_DESC_BASE_VMACC_VX <"fsqrt.w", null_frag, ?>;
class FSQRT_W_ENC_VMACC_VX : MSA_2RF_FMT_VMACC_VX <0b110010011, 0b0, 0b011110>;
def VMACC_VX : FSQRT_W_ENC_VMACC_VX , FSQRT_W_DESC_VMACC_VX , VMACC_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWMACCU_VX;
class MipsInst_VWMACCU_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWMACCU_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWMACCU_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWMACCU_VX : MipsInst_VWMACCU_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWMACCU_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VWMACCU_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWMACCU_VX ;
class MSA_3R_DESC_BASE_VWMACCU_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vwmaccu.vx	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VWMACCU_VX{
	bit  isCommutable=false;
}
class ADDV_W_ENC_VWMACCU_VX : MSA_3R_FMT_VWMACCU_VX <0b000, 0b10, 0b001110>;
class ADDV_W_DESC_VWMACCU_VX : MSA_3R_DESC_BASE_VWMACCU_VX <"addv.w", null_frag, ?>, IsCommutable_VWMACCU_VX ;
def VWMACCU_VX : ADDV_W_ENC_VWMACCU_VX , ADDV_W_DESC_VWMACCU_VX , VWMACCU_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWMACC_VX;
class MipsInst_VWMACC_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWMACC_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWMACC_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWMACC_VX : MipsInst_VWMACC_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWMACC_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VWMACC_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWMACC_VX ;
class MSA_3R_DESC_BASE_VWMACC_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vwmacc.vx	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VWMACC_VX{
	bit  isCommutable=false;
}
class AVE_U_W_ENC_VWMACC_VX : MSA_3R_FMT_VWMACC_VX <0b101, 0b10, 0b010000>;
class AVE_U_W_DESC_VWMACC_VX : MSA_3R_DESC_BASE_VWMACC_VX <"ave_u.w", null_frag, ?>, IsCommutable_VWMACC_VX ;
def VWMACC_VX : AVE_U_W_ENC_VWMACC_VX , AVE_U_W_DESC_VWMACC_VX , VWMACC_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWMACCSU_VX;
class MipsInst_VWMACCSU_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWMACCSU_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWMACCSU_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VWMACCSU_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vwmaccsu.vx	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VWMACCSU_VX : MipsInst_VWMACCSU_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWMACCSU_VX {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VWMACCSU_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VWMACCSU_VX <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VWMACCSU_VX<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VWMACCSU_VX ;
class MULR_Q_W_DESC_VWMACCSU_VX : MSA_3RF_DESC_BASE_VWMACCSU_VX <"mulr_q.w", null_frag, ?>;
class MULR_Q_W_ENC_VWMACCSU_VX : MSA_3RF_FMT_VWMACCSU_VX <0b1100, 0b1, 0b011100>;
def VWMACCSU_VX : MULR_Q_W_ENC_VWMACCSU_VX , MULR_Q_W_DESC_VWMACCSU_VX , VWMACCSU_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMADC_VVM;
class MipsInst_VMADC_VVM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMADC_VVM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMADC_VVM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMADC_VVM : MipsInst_VMADC_VVM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMADC_VVM {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMADC_VVM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMV0:$v0);
	string  AsmString="vmadc.vvm	$vd, $vs2, $vs1, v0";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VMADC_VVM<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMADC_VVM ;
class ASUB_S_W_DESC_VMADC_VVM : MSA_3R_DESC_BASE_VMADC_VVM <"asub_s.w", null_frag, ?>;
class ASUB_S_W_ENC_VMADC_VVM : MSA_3R_FMT_VMADC_VVM <0b100, 0b10, 0b010001>;
def VMADC_VVM : ASUB_S_W_ENC_VMADC_VVM , ASUB_S_W_DESC_VMADC_VVM , VMADC_VVM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMADC_VXM;
class MipsInst_VMADC_VXM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMADC_VXM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMADC_VXM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMADC_VXM : MipsInst_VMADC_VXM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMADC_VXM {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VMADC_VXM<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMADC_VXM ;
class MSA_3R_DESC_BASE_VMADC_VXM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMV0:$v0);
	string  AsmString="vmadc.vxm	$vd, $vs2, $rs1, v0";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VMADC_VXM{
	bit  isCommutable=false;
}
class ADDS_S_W_ENC_VMADC_VXM : MSA_3R_FMT_VMADC_VXM <0b010, 0b10, 0b010000>;
class ADDS_S_W_DESC_VMADC_VXM : MSA_3R_DESC_BASE_VMADC_VXM <"adds_s.w", null_frag, ?>, IsCommutable_VMADC_VXM ;
def VMADC_VXM : ADDS_S_W_ENC_VMADC_VXM , ADDS_S_W_DESC_VMADC_VXM , VMADC_VXM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMADC_VIM;
class MipsInst_VMADC_VIM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMADC_VIM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMADC_VIM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMADC_VIM : MipsInst_VMADC_VIM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMADC_VIM {
	let  EncodingPredicates=[];
}
class MSA_3R_4R_DESC_BASE_VMADC_VIM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, simm5:$imm, VMV0:$v0);
	string  AsmString="vmadc.vim	$vd, $vs2, $imm, v0";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="@earlyclobber $vd";
}
class MSA_3R_FMT_VMADC_VIM<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMADC_VIM ;
class MADDV_W_DESC_VMADC_VIM : MSA_3R_4R_DESC_BASE_VMADC_VIM <"maddv.w", null_frag, ?>;
class MADDV_W_ENC_VMADC_VIM : MSA_3R_FMT_VMADC_VIM <0b001, 0b10, 0b010010>;
def VMADC_VIM : MADDV_W_ENC_VMADC_VIM , MADDV_W_DESC_VMADC_VIM , VMADC_VIM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMADC_VV;
class MipsInst_VMADC_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMADC_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMADC_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMADC_VV : MipsInst_VMADC_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMADC_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMADC_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1);
	string  AsmString="vmadc.vv	$vd, $vs2, $vs1";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VMADC_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMADC_VV ;
class ASUB_S_W_DESC_VMADC_VV : MSA_3R_DESC_BASE_VMADC_VV <"asub_s.w", null_frag, ?>;
class ASUB_S_W_ENC_VMADC_VV : MSA_3R_FMT_VMADC_VV <0b100, 0b10, 0b010001>;
def VMADC_VV : ASUB_S_W_ENC_VMADC_VV , ASUB_S_W_DESC_VMADC_VV , VMADC_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMADC_VX;
class MipsInst_VMADC_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMADC_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMADC_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMADC_VX : MipsInst_VMADC_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMADC_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMADC_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1);
	string  AsmString="vmadc.vx	$vd, $vs2, $rs1";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VMADC_VX<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMADC_VX ;
class MSA_3RF_DESC_BASE_VMADC_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMADC_VX <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FEXP2_W_ENC_VMADC_VX : MSA_3RF_FMT_VMADC_VX <0b0111, 0b0, 0b011011>;
class FEXP2_W_DESC_VMADC_VX : MSA_3RF_DESC_BASE_VMADC_VX <"fexp2.w", null_frag, ?>;
def VMADC_VX : FEXP2_W_ENC_VMADC_VX , FEXP2_W_DESC_VMADC_VX , VMADC_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMADD_VV;
class MipsInst_VMADD_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMADD_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMADD_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMADD_VV : MipsInst_VMADD_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMADD_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VMADD_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMADD_VV ;
class MSA_3R_DESC_BASE_VMADD_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vmadd.vv	$vd, $vs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MULV_W_ENC_VMADD_VV : MSA_3R_FMT_VMADD_VV <0b000, 0b10, 0b010010>;
class MULV_W_DESC_VMADD_VV : MSA_3R_DESC_BASE_VMADD_VV <"mulv.w", null_frag, ?>;
def VMADD_VV : MULV_W_ENC_VMADD_VV , MULV_W_DESC_VMADD_VV , VMADD_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VREDMAXU_VS;
class MipsInst_VREDMAXU_VS<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VREDMAXU_VS {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VREDMAXU_VS{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VREDMAXU_VS : MipsInst_VREDMAXU_VS <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VREDMAXU_VS {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VREDMAXU_VS<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vredmaxu.vs	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VREDMAXU_VS<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VREDMAXU_VS ;
class LDI_W_DESC_VREDMAXU_VS : MSA_I10_LDI_DESC_BASE_VREDMAXU_VS <"ldi.w", ?>;
class LDI_W_ENC_VREDMAXU_VS : MSA_I10_FMT_VREDMAXU_VS <0b110, 0b10, 0b000111>;
def VREDMAXU_VS : LDI_W_ENC_VREDMAXU_VS , LDI_W_DESC_VREDMAXU_VS , VREDMAXU_VS_AUX {
	  	let mayLoad = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VREDMAX_VS;
class MipsInst_VREDMAX_VS<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VREDMAX_VS {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VREDMAX_VS{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VREDMAX_VS : MipsInst_VREDMAX_VS <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VREDMAX_VS {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VREDMAX_VS<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vredmax.vs	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VREDMAX_VS<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VREDMAX_VS ;
class LDI_W_DESC_VREDMAX_VS : MSA_I10_LDI_DESC_BASE_VREDMAX_VS <"ldi.w", ?>;
class LDI_W_ENC_VREDMAX_VS : MSA_I10_FMT_VREDMAX_VS <0b110, 0b10, 0b000111>;
def VREDMAX_VS : LDI_W_ENC_VREDMAX_VS , LDI_W_DESC_VREDMAX_VS , VREDMAX_VS_AUX {
	  	let mayLoad = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VFREDMAX_VS;
class MipsInst_VFREDMAX_VS<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFREDMAX_VS {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFREDMAX_VS{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFREDMAX_VS : MipsInst_VFREDMAX_VS <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFREDMAX_VS {
	let  EncodingPredicates=[];
}
class MSA_I5_DESC_BASE_VFREDMAX_VS<string  instr_asm, SDPatternOperator  OpNode, ComplexPattern  SplatImm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vfredmax.vs	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_I5_FMT_VFREDMAX_VS<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFREDMAX_VS ;
class CLTI_S_W_DESC_VFREDMAX_VS : MSA_I5_DESC_BASE_VFREDMAX_VS <"clti_s.w", null_frag, ?, ?>;
class CLTI_S_W_ENC_VFREDMAX_VS : MSA_I5_FMT_VFREDMAX_VS <0b010, 0b10, 0b000111>;
def VFREDMAX_VS : CLTI_S_W_ENC_VFREDMAX_VS , CLTI_S_W_DESC_VFREDMAX_VS , VFREDMAX_VS_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VMAX_VV;
class MipsInst_VMAX_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMAX_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMAX_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMAX_VV : MipsInst_VMAX_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMAX_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VMAX_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMAX_VV ;
class MSA_3R_DESC_BASE_VMAX_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vmax.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MAX_S_W_ENC_VMAX_VV : MSA_3R_FMT_VMAX_VV <0b010, 0b10, 0b001110>;
class MAX_S_W_DESC_VMAX_VV : MSA_3R_DESC_BASE_VMAX_VV <"max_s.w", null_frag, ?>;
def VMAX_VV : MAX_S_W_ENC_VMAX_VV , MAX_S_W_DESC_VMAX_VV , VMAX_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMAX_VX;
class MipsInst_VMAX_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMAX_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMAX_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMAX_VX : MipsInst_VMAX_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMAX_VX {
	let  EncodingPredicates=[];
}
class MSA_I5_DESC_BASE_VMAX_VX<string  instr_asm, SDPatternOperator  OpNode, ComplexPattern  SplatImm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vmax.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_I5_FMT_VMAX_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMAX_VX ;
class MAXI_U_W_DESC_VMAX_VX : MSA_I5_DESC_BASE_VMAX_VX <"maxi_u.w", null_frag, ?, ?>;
class MAXI_U_W_ENC_VMAX_VX : MSA_I5_FMT_VMAX_VX <0b011, 0b10, 0b000110>;
def VMAX_VX : MAXI_U_W_ENC_VMAX_VX , MAXI_U_W_DESC_VMAX_VX , VMAX_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMAXU_VV;
class MipsInst_VMAXU_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMAXU_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMAXU_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMAXU_VV : MipsInst_VMAXU_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMAXU_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VMAXU_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMAXU_VV ;
class MSA_3R_DESC_BASE_VMAXU_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vmaxu.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MAX_S_W_ENC_VMAXU_VV : MSA_3R_FMT_VMAXU_VV <0b010, 0b10, 0b001110>;
class MAX_S_W_DESC_VMAXU_VV : MSA_3R_DESC_BASE_VMAXU_VV <"max_s.w", null_frag, ?>;
def VMAXU_VV : MAX_S_W_ENC_VMAXU_VV , MAX_S_W_DESC_VMAXU_VV , VMAXU_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMAXU_VX;
class MipsInst_VMAXU_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMAXU_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMAXU_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMAXU_VX : MipsInst_VMAXU_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMAXU_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VMAXU_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMAXU_VX ;
class MSA_3R_DESC_BASE_VMAXU_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vmaxu.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MIN_S_W_ENC_VMAXU_VX : MSA_3R_FMT_VMAXU_VX <0b100, 0b10, 0b001110>;
class MIN_S_W_DESC_VMAXU_VX : MSA_3R_DESC_BASE_VMAXU_VX <"min_s.w", null_frag, ?>;
def VMAXU_VX : MIN_S_W_ENC_VMAXU_VX , MIN_S_W_DESC_VMAXU_VX , VMAXU_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VREDMINU_VS;
class MipsInst_VREDMINU_VS<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VREDMINU_VS {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VREDMINU_VS{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VREDMINU_VS : MipsInst_VREDMINU_VS <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VREDMINU_VS {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VREDMINU_VS<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vredminu.vs	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VREDMINU_VS<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VREDMINU_VS ;
class LDI_W_DESC_VREDMINU_VS : MSA_I10_LDI_DESC_BASE_VREDMINU_VS <"ldi.w", ?>;
class LDI_W_ENC_VREDMINU_VS : MSA_I10_FMT_VREDMINU_VS <0b110, 0b10, 0b000111>;
def VREDMINU_VS : LDI_W_ENC_VREDMINU_VS , LDI_W_DESC_VREDMINU_VS , VREDMINU_VS_AUX {
	  	let mayLoad = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VREDMIN_VS;
class MipsInst_VREDMIN_VS<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VREDMIN_VS {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VREDMIN_VS{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VREDMIN_VS : MipsInst_VREDMIN_VS <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VREDMIN_VS {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VREDMIN_VS<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vredmin.vs	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VREDMIN_VS<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VREDMIN_VS ;
class LDI_W_DESC_VREDMIN_VS : MSA_I10_LDI_DESC_BASE_VREDMIN_VS <"ldi.w", ?>;
class LDI_W_ENC_VREDMIN_VS : MSA_I10_FMT_VREDMIN_VS <0b110, 0b10, 0b000111>;
def VREDMIN_VS : LDI_W_ENC_VREDMIN_VS , LDI_W_DESC_VREDMIN_VS , VREDMIN_VS_AUX {
	  	let mayLoad = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VFREDMIN_VS;
class MipsInst_VFREDMIN_VS<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFREDMIN_VS {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFREDMIN_VS{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFREDMIN_VS : MipsInst_VFREDMIN_VS <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFREDMIN_VS {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFREDMIN_VS<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vfredmin.vs	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VFREDMIN_VS<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFREDMIN_VS ;
class MSA_3RF_DESC_BASE_VFREDMIN_VS<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VFREDMIN_VS <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FCLE_W_ENC_VFREDMIN_VS : MSA_3RF_FMT_VFREDMIN_VS <0b0110, 0b0, 0b011010>;
class FCLE_W_DESC_VFREDMIN_VS : MSA_3RF_DESC_BASE_VFREDMIN_VS <"fcle.w", null_frag, ?>;
def VFREDMIN_VS : FCLE_W_ENC_VFREDMIN_VS , FCLE_W_DESC_VFREDMIN_VS , VFREDMIN_VS_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VMIN_VV;
class MipsInst_VMIN_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMIN_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMIN_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMIN_VV : MipsInst_VMIN_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMIN_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMIN_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vmin.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3RF_FMT_VMIN_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMIN_VV ;
class MSA_3RF_DESC_BASE_VMIN_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VMIN_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class FSNE_W_ENC_VMIN_VV : MSA_3RF_FMT_VMIN_VV <0b1011, 0b0, 0b011100>;
class FSNE_W_DESC_VMIN_VV : MSA_3RF_DESC_BASE_VMIN_VV <"fsne.w", null_frag, ?>;
def VMIN_VV : FSNE_W_ENC_VMIN_VV , FSNE_W_DESC_VMIN_VV , VMIN_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMIN_VX;
class MipsInst_VMIN_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMIN_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMIN_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMIN_VX : MipsInst_VMIN_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMIN_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMIN_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vmin.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VMIN_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMIN_VX ;
class CLT_U_W_DESC_VMIN_VX : MSA_3R_DESC_BASE_VMIN_VX <"clt_u.w", null_frag, ?>;
class CLT_U_W_ENC_VMIN_VX : MSA_3R_FMT_VMIN_VX <0b011, 0b10, 0b001111>;
def VMIN_VX : CLT_U_W_ENC_VMIN_VX , CLT_U_W_DESC_VMIN_VX , VMIN_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMINU_VV;
class MipsInst_VMINU_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMINU_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMINU_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMINU_VV : MipsInst_VMINU_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMINU_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VMINU_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMINU_VV ;
class MSA_3R_DESC_BASE_VMINU_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vminu.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MAX_S_W_ENC_VMINU_VV : MSA_3R_FMT_VMINU_VV <0b010, 0b10, 0b001110>;
class MAX_S_W_DESC_VMINU_VV : MSA_3R_DESC_BASE_VMINU_VV <"max_s.w", null_frag, ?>;
def VMINU_VV : MAX_S_W_ENC_VMINU_VV , MAX_S_W_DESC_VMINU_VV , VMINU_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMINU_VX;
class MipsInst_VMINU_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMINU_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMINU_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMINU_VX : MipsInst_VMINU_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMINU_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VMINU_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMINU_VX ;
class MSA_3R_DESC_BASE_VMINU_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vminu.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MAX_S_W_ENC_VMINU_VX : MSA_3R_FMT_VMINU_VX <0b010, 0b10, 0b001110>;
class MAX_S_W_DESC_VMINU_VX : MSA_3R_DESC_BASE_VMINU_VX <"max_s.w", null_frag, ?>;
def VMINU_VX : MAX_S_W_ENC_VMINU_VX , MAX_S_W_DESC_VMINU_VX , VMINU_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VREM_VV;
class MipsInst_VREM_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VREM_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VREM_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VREM_VV : MipsInst_VREM_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VREM_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_4R_DESC_BASE_VREM_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vrem.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="";
}
class MSA_3R_FMT_VREM_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VREM_VV ;
class MSUBV_W_DESC_VREM_VV : MSA_3R_4R_DESC_BASE_VREM_VV <"msubv.w", null_frag, ?>;
class MSUBV_W_ENC_VREM_VV : MSA_3R_FMT_VREM_VV <0b010, 0b10, 0b010010>;
def VREM_VV : MSUBV_W_ENC_VREM_VV , MSUBV_W_DESC_VREM_VV , VREM_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VREM_VX;
class MipsInst_VREM_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VREM_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VREM_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VREM_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vrem.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VREM_VX : MipsInst_VREM_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VREM_VX {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VREM_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VREM_VX <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VREM_VX<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VREM_VX ;
class MUL_Q_W_DESC_VREM_VX : MSA_3RF_DESC_BASE_VREM_VX <"mul_q.w", null_frag, ?>;
class MUL_Q_W_ENC_VREM_VX : MSA_3RF_FMT_VREM_VX <0b0100, 0b1, 0b011100>;
def VREM_VX : MUL_Q_W_ENC_VREM_VX , MUL_Q_W_DESC_VREM_VX , VREM_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VREMU_VV;
class MipsInst_VREMU_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VREMU_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VREMU_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VREMU_VV : MipsInst_VREMU_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VREMU_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VREMU_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VREMU_VV ;
class MSA_3R_DESC_BASE_VREMU_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vremu.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VREMU_VV{
	bit  isCommutable=false;
}
class ADDV_W_ENC_VREMU_VV : MSA_3R_FMT_VREMU_VV <0b000, 0b10, 0b001110>;
class ADDV_W_DESC_VREMU_VV : MSA_3R_DESC_BASE_VREMU_VV <"addv.w", null_frag, ?>, IsCommutable_VREMU_VV ;
def VREMU_VV : ADDV_W_ENC_VREMU_VV , ADDV_W_DESC_VREMU_VV , VREMU_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VREMU_VX;
class MipsInst_VREMU_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VREMU_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VREMU_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VREMU_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vremu.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VREMU_VX : MipsInst_VREMU_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VREMU_VX {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VREMU_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VREMU_VX <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VREMU_VX<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VREMU_VX ;
class MULR_Q_W_DESC_VREMU_VX : MSA_3RF_DESC_BASE_VREMU_VX <"mulr_q.w", null_frag, ?>;
class MULR_Q_W_ENC_VREMU_VX : MSA_3RF_FMT_VREMU_VX <0b1100, 0b1, 0b011100>;
def VREMU_VX : MULR_Q_W_ENC_VREMU_VX , MULR_Q_W_DESC_VREMU_VX , VREMU_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMV_V_V;
class MipsInst_VMV_V_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMV_V_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMV_V_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMV_V_V : MipsInst_VMV_V_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMV_V_V {
	let  EncodingPredicates=[];
}
class MSA_ELM_FMT_VMV_V_V<bits<10>  major, bits<6>  minor> : MSAInst_VMV_V_V ;
class MOVE_V_DESC_VMV_V_V{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1);
	string  AsmString="vmv.v.v	$vd, $vs1";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=NoItinerary;
	bit  isMoveReg=false;
}
class MOVE_V_ENC_VMV_V_V : MSA_ELM_FMT_VMV_V_V <0b0010111110, 0b011001>;
def VMV_V_V : MOVE_V_ENC_VMV_V_V , MOVE_V_DESC_VMV_V_V , VMV_V_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMV_V_X;
class MipsInst_VMV_V_X<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMV_V_X {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMV_V_X{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMV_V_X : MipsInst_VMV_V_X <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMV_V_X {
	let  EncodingPredicates=[];
}
class MSA_2R_FILL_FMT_VMV_V_X<bits<8>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMV_V_X ;
class MSA_2R_FILL_DESC_BASE_VMV_V_X<string  instr_asm, ValueType  VT, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1);
	string  AsmString="vmv.v.x	$vd, $rs1";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FILL_W_ENC_VMV_V_X : MSA_2R_FILL_FMT_VMV_V_X <0b11000000, 0b10, 0b011110>;
class FILL_W_DESC_VMV_V_X : MSA_2R_FILL_DESC_BASE_VMV_V_X <"fill.w", ?, null_frag, ?, ?>;
def VMV_V_X : FILL_W_ENC_VMV_V_X , FILL_W_DESC_VMV_V_X , VMV_V_X_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMV_V_I;
class MipsInst_VMV_V_I<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMV_V_I {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMV_V_I{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMV_V_I : MipsInst_VMV_V_I <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMV_V_I {
	let  EncodingPredicates=[];
}
class MSA_2R_FILL_FMT_VMV_V_I<bits<8>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMV_V_I ;
class MSA_2R_FILL_DESC_BASE_VMV_V_I<string  instr_asm, ValueType  VT, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins simm5:$imm);
	string  AsmString="vmv.v.i	$vd, $imm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FILL_W_ENC_VMV_V_I : MSA_2R_FILL_FMT_VMV_V_I <0b11000000, 0b10, 0b011110>;
class FILL_W_DESC_VMV_V_I : MSA_2R_FILL_DESC_BASE_VMV_V_I <"fill.w", ?, null_frag, ?, ?>;
def VMV_V_I : FILL_W_ENC_VMV_V_I , FILL_W_DESC_VMV_V_I , VMV_V_I_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VFMV_V_F;
class MipsInst_VFMV_V_F<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFMV_V_F {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFMV_V_F{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFMV_V_F : MipsInst_VFMV_V_F <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFMV_V_F {
	let  EncodingPredicates=[];
}
class MSA_ELM_FMT_VFMV_V_F<bits<10>  major, bits<6>  minor> : MSAInst_VFMV_V_F ;
class MOVE_V_DESC_VFMV_V_F{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins FPR32:$rs1);
	string  AsmString="vfmv.v.f	$vd, $rs1";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=NoItinerary;
	bit  isMoveReg=false;
}
class MOVE_V_ENC_VFMV_V_F : MSA_ELM_FMT_VFMV_V_F <0b0010111110, 0b011001>;
def VFMV_V_F : MOVE_V_ENC_VFMV_V_F , MOVE_V_DESC_VFMV_V_F , VFMV_V_F_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VMV_X_S;
class MipsInst_VMV_X_S<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMV_X_S {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMV_X_S{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMV_X_S : MipsInst_VMV_X_S <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMV_X_S {
	let  EncodingPredicates=[];
}
class MSA_ELM_FMT_VMV_X_S<bits<10>  major, bits<6>  minor> : MSAInst_VMV_X_S ;
class MOVE_V_DESC_VMV_X_S{
	dag  OutOperandList=(outs GPR:$vd);
	dag  InOperandList=(ins VR:$vs2);
	string  AsmString="vmv.x.s	$vd, $vs2";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=NoItinerary;
	bit  isMoveReg=false;
}
class MOVE_V_ENC_VMV_X_S : MSA_ELM_FMT_VMV_X_S <0b0010111110, 0b011001>;
def VMV_X_S : MOVE_V_ENC_VMV_X_S , MOVE_V_DESC_VMV_X_S , VMV_X_S_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMV_S_X;
class MipsInst_VMV_S_X<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMV_S_X {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMV_S_X{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMV_S_X : MipsInst_VMV_S_X <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMV_S_X {
	let  EncodingPredicates=[];
}
class MSA_2R_FILL_FMT_VMV_S_X<bits<8>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMV_S_X ;
class MSA_2R_FILL_DESC_BASE_VMV_S_X<string  instr_asm, ValueType  VT, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd_wb);
	dag  InOperandList=(ins VR:$vd, GPR:$rs1);
	string  AsmString="vmv.s.x	$vd, $rs1";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FILL_W_ENC_VMV_S_X : MSA_2R_FILL_FMT_VMV_S_X <0b11000000, 0b10, 0b011110>;
class FILL_W_DESC_VMV_S_X : MSA_2R_FILL_DESC_BASE_VMV_S_X <"fill.w", ?, null_frag, ?, ?>;
def VMV_S_X : FILL_W_ENC_VMV_S_X , FILL_W_DESC_VMV_S_X , VMV_S_X_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "$vd = $vd_wb";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VFMV_F_S;
class MipsInst_VFMV_F_S<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFMV_F_S {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFMV_F_S{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFMV_F_S : MipsInst_VFMV_F_S <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFMV_F_S {
	let  EncodingPredicates=[];
}
class MSA_ELM_CFCMSA_FMT_VFMV_F_S<bits<10>  major, bits<6>  minor> : MSAInst_VFMV_F_S ;
class CFCMSA_DESC_VFMV_F_S{
	dag  OutOperandList=(outs FPR32:$vd);
	dag  InOperandList=(ins VR:$vs2);
	string  AsmString="vfmv.f.s	$vd, $vs2";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=NoItinerary;
	bit  hasSideEffects=0;
	bit  isMoveReg=false;
}
class CFCMSA_ENC_VFMV_F_S : MSA_ELM_CFCMSA_FMT_VFMV_F_S <0b0001111110, 0b011001>;
def VFMV_F_S : CFCMSA_ENC_VFMV_F_S , CFCMSA_DESC_VFMV_F_S , VFMV_F_S_AUX {
	  	let mayLoad = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFMV_S_F;
class MipsInst_VFMV_S_F<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFMV_S_F {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFMV_S_F{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFMV_S_F : MipsInst_VFMV_S_F <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFMV_S_F {
	let  EncodingPredicates=[];
}
class MSA_ELM_COPY_W_FMT_VFMV_S_F<bits<4>  major, bits<6>  minor> : MSAInst_VFMV_S_F ;
class MSA_COPY_DESC_BASE_VFMV_S_F<string  instr_asm, SDPatternOperator  OpNode, ValueType  VecTy, Operand  ImmOp, ImmLeaf  Imm, RegisterOperand  ROD, RegisterOperand  ROWS, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd_wb);
	dag  InOperandList=(ins VR:$vd, FPR32:$rs1);
	string  AsmString="vfmv.s.f	$vd, $rs1";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class COPY_S_W_ENC_VFMV_S_F : MSA_ELM_COPY_W_FMT_VFMV_S_F <0b0010, 0b011001>;
class COPY_S_W_DESC_VFMV_S_F : MSA_COPY_DESC_BASE_VFMV_S_F <"copy_s.w", null_frag, ?, ?, ?, ?, ?>;
def VFMV_S_F : COPY_S_W_ENC_VFMV_S_F , COPY_S_W_DESC_VFMV_S_F , VFMV_S_F_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "$vd = $vd_wb";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VMV1R_V;
class MipsInst_VMV1R_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMV1R_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMV1R_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMV1R_V : MipsInst_VMV1R_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMV1R_V {
	let  EncodingPredicates=[];
}
class MSA_2R_FILL_FMT_VMV1R_V<bits<8>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMV1R_V ;
class MSA_2R_FILL_DESC_BASE_VMV1R_V<string  instr_asm, ValueType  VT, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2);
	string  AsmString="vmv1r.v	$vd, $vs2";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FILL_W_ENC_VMV1R_V : MSA_2R_FILL_FMT_VMV1R_V <0b11000000, 0b10, 0b011110>;
class FILL_W_DESC_VMV1R_V : MSA_2R_FILL_DESC_BASE_VMV1R_V <"fill.w", ?, null_frag, ?, ?>;
def VMV1R_V : FILL_W_ENC_VMV1R_V , FILL_W_DESC_VMV1R_V , VMV1R_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMV2R_V;
class MipsInst_VMV2R_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMV2R_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMV2R_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMV2R_V : MipsInst_VMV2R_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMV2R_V {
	let  EncodingPredicates=[];
}
class MSA_ELM_FMT_VMV2R_V<bits<10>  major, bits<6>  minor> : MSAInst_VMV2R_V ;
class MOVE_V_DESC_VMV2R_V{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2);
	string  AsmString="vmv2r.v	$vd, $vs2";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=NoItinerary;
	bit  isMoveReg=false;
}
class MOVE_V_ENC_VMV2R_V : MSA_ELM_FMT_VMV2R_V <0b0010111110, 0b011001>;
def VMV2R_V : MOVE_V_ENC_VMV2R_V , MOVE_V_DESC_VMV2R_V , VMV2R_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMV4R_V;
class MipsInst_VMV4R_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMV4R_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMV4R_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMV4R_V : MipsInst_VMV4R_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMV4R_V {
	let  EncodingPredicates=[];
}
class MSA_ELM_FMT_VMV4R_V<bits<10>  major, bits<6>  minor> : MSAInst_VMV4R_V ;
class MOVE_V_DESC_VMV4R_V{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2);
	string  AsmString="vmv4r.v	$vd, $vs2";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=NoItinerary;
	bit  isMoveReg=false;
}
class MOVE_V_ENC_VMV4R_V : MSA_ELM_FMT_VMV4R_V <0b0010111110, 0b011001>;
def VMV4R_V : MOVE_V_ENC_VMV4R_V , MOVE_V_DESC_VMV4R_V , VMV4R_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMV8R_V;
class MipsInst_VMV8R_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMV8R_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMV8R_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMV8R_V : MipsInst_VMV8R_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMV8R_V {
	let  EncodingPredicates=[];
}
class MSA_ELM_FMT_VMV8R_V<bits<10>  major, bits<6>  minor> : MSAInst_VMV8R_V ;
class MOVE_V_DESC_VMV8R_V{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2);
	string  AsmString="vmv8r.v	$vd, $vs2";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=NoItinerary;
	bit  isMoveReg=false;
}
class MOVE_V_ENC_VMV8R_V : MSA_ELM_FMT_VMV8R_V <0b0010111110, 0b011001>;
def VMV8R_V : MOVE_V_ENC_VMV8R_V , MOVE_V_DESC_VMV8R_V , VMV8R_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VNMSAC_VV;
class MipsInst_VNMSAC_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VNMSAC_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VNMSAC_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VNMSAC_VV : MipsInst_VNMSAC_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VNMSAC_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VNMSAC_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VNMSAC_VV ;
class MSA_3R_DESC_BASE_VNMSAC_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vnmsac.vv	$vd, $vs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VNMSAC_VV{
	bit  isCommutable=false;
}
class ADDV_W_ENC_VNMSAC_VV : MSA_3R_FMT_VNMSAC_VV <0b000, 0b10, 0b001110>;
class ADDV_W_DESC_VNMSAC_VV : MSA_3R_DESC_BASE_VNMSAC_VV <"addv.w", null_frag, ?>, IsCommutable_VNMSAC_VV ;
def VNMSAC_VV : ADDV_W_ENC_VNMSAC_VV , ADDV_W_DESC_VNMSAC_VV , VNMSAC_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VNMSUB_VX;
class MipsInst_VNMSUB_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VNMSUB_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VNMSUB_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VNMSUB_VX : MipsInst_VNMSUB_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VNMSUB_VX {
	let  EncodingPredicates=[];
}
class MSA_I5_DESC_BASE_VNMSUB_VX<string  instr_asm, SDPatternOperator  OpNode, ComplexPattern  SplatImm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vnmsub.vx	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_I5_FMT_VNMSUB_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VNMSUB_VX ;
class ADDVI_W_DESC_VNMSUB_VX : MSA_I5_DESC_BASE_VNMSUB_VX <"addvi.w", null_frag, ?, ?>;
class ADDVI_W_ENC_VNMSUB_VX : MSA_I5_FMT_VNMSUB_VX <0b000, 0b10, 0b000110>;
def VNMSUB_VX : ADDVI_W_ENC_VNMSUB_VX , ADDVI_W_DESC_VNMSUB_VX , VNMSUB_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VNMSAC_VX;
class MipsInst_VNMSAC_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VNMSAC_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VNMSAC_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VNMSAC_VX : MipsInst_VNMSAC_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VNMSAC_VX {
	let  EncodingPredicates=[];
}
class MSA_I5_DESC_BASE_VNMSAC_VX<string  instr_asm, SDPatternOperator  OpNode, ComplexPattern  SplatImm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vnmsac.vx	$vd, $rs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_I5_FMT_VNMSAC_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VNMSAC_VX ;
class ADDVI_W_DESC_VNMSAC_VX : MSA_I5_DESC_BASE_VNMSAC_VX <"addvi.w", null_frag, ?, ?>;
class ADDVI_W_ENC_VNMSAC_VX : MSA_I5_FMT_VNMSAC_VX <0b000, 0b10, 0b000110>;
def VNMSAC_VX : ADDVI_W_ENC_VNMSAC_VX , ADDVI_W_DESC_VNMSAC_VX , VNMSAC_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VNMSUB_VV;
class MipsInst_VNMSUB_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VNMSUB_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VNMSUB_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VNMSUB_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vnmsub.vv	$vd, $vs1, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VNMSUB_VV : MipsInst_VNMSUB_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VNMSUB_VV {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VNMSUB_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VNMSUB_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VNMSUB_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VNMSUB_VV ;
class MULR_Q_W_DESC_VNMSUB_VV : MSA_3RF_DESC_BASE_VNMSUB_VV <"mulr_q.w", null_frag, ?>;
class MULR_Q_W_ENC_VNMSUB_VV : MSA_3RF_FMT_VNMSUB_VV <0b1100, 0b1, 0b011100>;
def VNMSUB_VV : MULR_Q_W_ENC_VNMSUB_VV , MULR_Q_W_DESC_VNMSUB_VV , VNMSUB_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMUL_VV;
class MipsInst_VMUL_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMUL_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMUL_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_4R_DESC_BASE_VMUL_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vmul.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="";
}
class MSAInst_VMUL_VV : MipsInst_VMUL_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMUL_VV {
	let  EncodingPredicates=[];
}
class MSA_3RF_4RF_DESC_BASE_VMUL_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_4R_DESC_BASE_VMUL_VV <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VMUL_VV<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMUL_VV ;
class MSUB_Q_W_DESC_VMUL_VV : MSA_3RF_4RF_DESC_BASE_VMUL_VV <"msub_q.w", null_frag, ?>;
class MSUB_Q_W_ENC_VMUL_VV : MSA_3RF_FMT_VMUL_VV <0b0110, 0b1, 0b011100>;
def VMUL_VV : MSUB_Q_W_ENC_VMUL_VV , MSUB_Q_W_DESC_VMUL_VV , VMUL_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMULHU_VV;
class MipsInst_VMULHU_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMULHU_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMULHU_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMULHU_VV : MipsInst_VMULHU_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMULHU_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VMULHU_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMULHU_VV ;
class MSA_3R_DESC_BASE_VMULHU_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vmulhu.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MULV_W_ENC_VMULHU_VV : MSA_3R_FMT_VMULHU_VV <0b000, 0b10, 0b010010>;
class MULV_W_DESC_VMULHU_VV : MSA_3R_DESC_BASE_VMULHU_VV <"mulv.w", null_frag, ?>;
def VMULHU_VV : MULV_W_ENC_VMULHU_VV , MULV_W_DESC_VMULHU_VV , VMULHU_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWMUL_VV;
class MipsInst_VWMUL_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWMUL_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWMUL_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWMUL_VV : MipsInst_VWMUL_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWMUL_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VWMUL_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWMUL_VV ;
class MSA_3R_DESC_BASE_VWMUL_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vwmul.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VWMUL_VV{
	bit  isCommutable=false;
}
class AVER_S_D_ENC_VWMUL_VV : MSA_3R_FMT_VWMUL_VV <0b110, 0b11, 0b010000>;
class AVER_S_D_DESC_VWMUL_VV : MSA_3R_DESC_BASE_VWMUL_VV <"aver_s.d", null_frag, ?>, IsCommutable_VWMUL_VV ;
def VWMUL_VV : AVER_S_D_ENC_VWMUL_VV , AVER_S_D_DESC_VWMUL_VV , VWMUL_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWMULU_VV;
class MipsInst_VWMULU_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWMULU_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWMULU_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWMULU_VV : MipsInst_VWMULU_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWMULU_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VWMULU_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWMULU_VV ;
class MSA_3R_DESC_BASE_VWMULU_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vwmulu.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VWMULU_VV{
	bit  isCommutable=false;
}
class ADDS_U_D_ENC_VWMULU_VV : MSA_3R_FMT_VWMULU_VV <0b011, 0b11, 0b010000>;
class ADDS_U_D_DESC_VWMULU_VV : MSA_3R_DESC_BASE_VWMULU_VV <"adds_u.d", null_frag, ?>, IsCommutable_VWMULU_VV ;
def VWMULU_VV : ADDS_U_D_ENC_VWMULU_VV , ADDS_U_D_DESC_VWMULU_VV , VWMULU_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWMULSU_VV;
class MipsInst_VWMULSU_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWMULSU_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWMULSU_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWMULSU_VV : MipsInst_VWMULSU_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWMULSU_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VWMULSU_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vwmulsu.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VWMULSU_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWMULSU_VV ;
class SUBS_S_D_DESC_VWMULSU_VV : MSA_3R_DESC_BASE_VWMULSU_VV <"subs_s.d", null_frag, ?>;
class SUBS_S_D_ENC_VWMULSU_VV : MSA_3R_FMT_VWMULSU_VV <0b000, 0b11, 0b010001>;
def VWMULSU_VV : SUBS_S_D_ENC_VWMULSU_VV , SUBS_S_D_DESC_VWMULSU_VV , VWMULSU_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSMUL_VV;
class MipsInst_VSMUL_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSMUL_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSMUL_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSMUL_VV : MipsInst_VSMUL_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSMUL_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VSMUL_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSMUL_VV ;
class MSA_3R_DESC_BASE_VSMUL_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vsmul.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VSMUL_VV{
	bit  isCommutable=false;
}
class ADDV_W_ENC_VSMUL_VV : MSA_3R_FMT_VSMUL_VV <0b000, 0b10, 0b001110>;
class ADDV_W_DESC_VSMUL_VV : MSA_3R_DESC_BASE_VSMUL_VV <"addv.w", null_frag, ?>, IsCommutable_VSMUL_VV ;
def VSMUL_VV : ADDV_W_ENC_VSMUL_VV , ADDV_W_DESC_VSMUL_VV , VSMUL_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMULH_VX;
class MipsInst_VMULH_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMULH_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMULH_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMULH_VX : MipsInst_VMULH_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMULH_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMULH_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vmulh.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VMULH_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMULH_VX ;
class HSUB_U_W_DESC_VMULH_VX : MSA_3R_DESC_BASE_VMULH_VX <"hsub_u.w", null_frag, ?, ?, ?>;
class HSUB_U_W_ENC_VMULH_VX : MSA_3R_FMT_VMULH_VX <0b111, 0b10, 0b010101>;
def VMULH_VX : HSUB_U_W_ENC_VMULH_VX , HSUB_U_W_DESC_VMULH_VX , VMULH_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMULHSU_VX;
class MipsInst_VMULHSU_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMULHSU_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMULHSU_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMULHSU_VX : MipsInst_VMULHSU_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMULHSU_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VMULHSU_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMULHSU_VX ;
class MSA_3R_DESC_BASE_VMULHSU_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vmulhsu.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MULV_W_ENC_VMULHSU_VX : MSA_3R_FMT_VMULHSU_VX <0b000, 0b10, 0b010010>;
class MULV_W_DESC_VMULHSU_VX : MSA_3R_DESC_BASE_VMULHSU_VX <"mulv.w", null_frag, ?>;
def VMULHSU_VX : MULV_W_ENC_VMULHSU_VX , MULV_W_DESC_VMULHSU_VX , VMULHSU_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMUL_VX;
class MipsInst_VMUL_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMUL_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMUL_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMUL_VX : MipsInst_VMUL_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMUL_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMUL_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vmul.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VMUL_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMUL_VX ;
class HADD_S_W_DESC_VMUL_VX : MSA_3R_DESC_BASE_VMUL_VX <"hadd_s.w", null_frag, ?, ?, ?>;
class HADD_S_W_ENC_VMUL_VX : MSA_3R_FMT_VMUL_VX <0b100, 0b10, 0b010101>;
def VMUL_VX : HADD_S_W_ENC_VMUL_VX , HADD_S_W_DESC_VMUL_VX , VMUL_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMULHU_VX;
class MipsInst_VMULHU_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMULHU_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMULHU_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMULHU_VX : MipsInst_VMULHU_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMULHU_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VMULHU_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMULHU_VX ;
class MSA_3R_DESC_BASE_VMULHU_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vmulhu.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VMULHU_VX{
	bit  isCommutable=false;
}
class ADDV_W_ENC_VMULHU_VX : MSA_3R_FMT_VMULHU_VX <0b000, 0b10, 0b001110>;
class ADDV_W_DESC_VMULHU_VX : MSA_3R_DESC_BASE_VMULHU_VX <"addv.w", null_frag, ?>, IsCommutable_VMULHU_VX ;
def VMULHU_VX : ADDV_W_ENC_VMULHU_VX , ADDV_W_DESC_VMULHU_VX , VMULHU_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWMUL_VX;
class MipsInst_VWMUL_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWMUL_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWMUL_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWMUL_VX : MipsInst_VWMUL_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWMUL_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VWMUL_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWMUL_VX ;
class MSA_3R_DESC_BASE_VWMUL_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vwmul.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VWMUL_VX{
	bit  isCommutable=false;
}
class ADDS_U_D_ENC_VWMUL_VX : MSA_3R_FMT_VWMUL_VX <0b011, 0b11, 0b010000>;
class ADDS_U_D_DESC_VWMUL_VX : MSA_3R_DESC_BASE_VWMUL_VX <"adds_u.d", null_frag, ?>, IsCommutable_VWMUL_VX ;
def VWMUL_VX : ADDS_U_D_ENC_VWMUL_VX , ADDS_U_D_DESC_VWMUL_VX , VWMUL_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWMULU_VX;
class MipsInst_VWMULU_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWMULU_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWMULU_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWMULU_VX : MipsInst_VWMULU_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWMULU_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VWMULU_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWMULU_VX ;
class MSA_3R_DESC_BASE_VWMULU_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vwmulu.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VWMULU_VX{
	bit  isCommutable=false;
}
class ADDS_U_D_ENC_VWMULU_VX : MSA_3R_FMT_VWMULU_VX <0b011, 0b11, 0b010000>;
class ADDS_U_D_DESC_VWMULU_VX : MSA_3R_DESC_BASE_VWMULU_VX <"adds_u.d", null_frag, ?>, IsCommutable_VWMULU_VX ;
def VWMULU_VX : ADDS_U_D_ENC_VWMULU_VX , ADDS_U_D_DESC_VWMULU_VX , VWMULU_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWMULSU_VX;
class MipsInst_VWMULSU_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWMULSU_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWMULSU_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWMULSU_VX : MipsInst_VWMULSU_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWMULSU_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VWMULSU_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vwmulsu.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VWMULSU_VX{
	bit  isCommutable=false;
}
class MSA_3R_FMT_VWMULSU_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWMULSU_VX ;
class AVE_S_D_DESC_VWMULSU_VX : MSA_3R_DESC_BASE_VWMULSU_VX <"ave_s.d", null_frag, ?>, IsCommutable_VWMULSU_VX ;
class AVE_S_D_ENC_VWMULSU_VX : MSA_3R_FMT_VWMULSU_VX <0b100, 0b11, 0b010000>;
def VWMULSU_VX : AVE_S_D_ENC_VWMULSU_VX , AVE_S_D_DESC_VWMULSU_VX , VWMULSU_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSMUL_VX;
class MipsInst_VSMUL_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSMUL_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSMUL_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSMUL_VX : MipsInst_VSMUL_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSMUL_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VSMUL_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSMUL_VX ;
class MSA_3R_DESC_BASE_VSMUL_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsmul.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VSMUL_VX{
	bit  isCommutable=false;
}
class ADDS_S_W_ENC_VSMUL_VX : MSA_3R_FMT_VSMUL_VX <0b010, 0b10, 0b010000>;
class ADDS_S_W_DESC_VSMUL_VX : MSA_3R_DESC_BASE_VSMUL_VX <"adds_s.w", null_frag, ?>, IsCommutable_VSMUL_VX ;
def VSMUL_VX : ADDS_S_W_ENC_VSMUL_VX , ADDS_S_W_DESC_VSMUL_VX , VSMUL_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMULH_VV;
class MipsInst_VMULH_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMULH_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMULH_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMULH_VV : MipsInst_VMULH_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMULH_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VMULH_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMULH_VV ;
class MSA_3R_DESC_BASE_VMULH_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vmulh.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VMULH_VV{
	bit  isCommutable=false;
}
class AVE_S_W_ENC_VMULH_VV : MSA_3R_FMT_VMULH_VV <0b100, 0b10, 0b010000>;
class AVE_S_W_DESC_VMULH_VV : MSA_3R_DESC_BASE_VMULH_VV <"ave_s.w", null_frag, ?>, IsCommutable_VMULH_VV ;
def VMULH_VV : AVE_S_W_ENC_VMULH_VV , AVE_S_W_DESC_VMULH_VV , VMULH_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMULHSU_VV;
class MipsInst_VMULHSU_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMULHSU_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMULHSU_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMULHSU_VV : MipsInst_VMULHSU_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMULHSU_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_4R_DESC_BASE_VMULHSU_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vmulhsu.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="";
}
class MSA_3R_FMT_VMULHSU_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMULHSU_VV ;
class MSUBV_W_DESC_VMULHSU_VV : MSA_3R_4R_DESC_BASE_VMULHSU_VV <"msubv.w", null_frag, ?>;
class MSUBV_W_ENC_VMULHSU_VV : MSA_3R_FMT_VMULHSU_VV <0b010, 0b10, 0b010010>;
def VMULHSU_VV : MSUBV_W_ENC_VMULHSU_VV , MSUBV_W_DESC_VMULHSU_VV , VMULHSU_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMSOF_M;
class MipsInst_VMSOF_M<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMSOF_M {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMSOF_M{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMSOF_M : MipsInst_VMSOF_M <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMSOF_M {
	let  EncodingPredicates=[];
}
class MSA_2R_FMT_VMSOF_M<bits<8>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMSOF_M ;
class MSA_2R_DESC_BASE_VMSOF_M<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vmsof.m	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class NLOC_W_ENC_VMSOF_M : MSA_2R_FMT_VMSOF_M <0b11000010, 0b10, 0b011110>;
class NLOC_W_DESC_VMSOF_M : MSA_2R_DESC_BASE_VMSOF_M <"nloc.w", null_frag, ?>;
def VMSOF_M : NLOC_W_ENC_VMSOF_M , NLOC_W_DESC_VMSOF_M , VMSOF_M_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VIOTA_M;
class MipsInst_VIOTA_M<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VIOTA_M {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VIOTA_M{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VIOTA_M : MipsInst_VIOTA_M <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VIOTA_M {
	let  EncodingPredicates=[];
}
class MSA_VEC_FMT_VIOTA_M<bits<5>  major, bits<6>  minor> : MSAInst_VIOTA_M ;
class BMNZ_V_DESC_VIOTA_M{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="viota.m	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=NoItinerary;
	string  Constraints="@earlyclobber $vd";
}
class BMNZ_V_ENC_VIOTA_M : MSA_VEC_FMT_VIOTA_M <0b00100, 0b011110>;
def VIOTA_M : BMNZ_V_ENC_VIOTA_M , BMNZ_V_DESC_VIOTA_M , VIOTA_M_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VOR_VV;
class MipsInst_VOR_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VOR_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VOR_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VOR_VV : MipsInst_VOR_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VOR_VV {
	let  EncodingPredicates=[];
}
class MSA_VEC_FMT_VOR_VV<bits<5>  major, bits<6>  minor> : MSAInst_VOR_VV ;
class BMZ_V_ENC_VOR_VV : MSA_VEC_FMT_VOR_VV <0b00101, 0b011110>;
class BMZ_V_DESC_VOR_VV{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vor.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=NoItinerary;
	string  Constraints="";
}
def VOR_VV : BMZ_V_ENC_VOR_VV , BMZ_V_DESC_VOR_VV , VOR_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VOR_VX;
class MipsInst_VOR_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VOR_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VOR_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VOR_VX : MipsInst_VOR_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VOR_VX {
	let  EncodingPredicates=[];
}
class MSA_VEC_FMT_VOR_VX<bits<5>  major, bits<6>  minor> : MSAInst_VOR_VX ;
class MSA_VEC_DESC_BASE_VOR_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vor.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class OR_V_ENC_VOR_VX : MSA_VEC_FMT_VOR_VX <0b00001, 0b011110>;
class OR_V_DESC_VOR_VX : MSA_VEC_DESC_BASE_VOR_VX <"or.v", null_frag, ?>;
def VOR_VX : OR_V_ENC_VOR_VX , OR_V_DESC_VOR_VX , VOR_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VREDOR_VS;
class MipsInst_VREDOR_VS<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VREDOR_VS {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VREDOR_VS{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VREDOR_VS : MipsInst_VREDOR_VS <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VREDOR_VS {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VREDOR_VS<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vredor.vs	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VREDOR_VS<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VREDOR_VS ;
class LDI_W_DESC_VREDOR_VS : MSA_I10_LDI_DESC_BASE_VREDOR_VS <"ldi.w", ?>;
class LDI_W_ENC_VREDOR_VS : MSA_I10_FMT_VREDOR_VS <0b110, 0b10, 0b000111>;
def VREDOR_VS : LDI_W_ENC_VREDOR_VS , LDI_W_DESC_VREDOR_VS , VREDOR_VS_AUX {
	  	let mayLoad = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMOR_MM;
class MipsInst_VMOR_MM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMOR_MM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMOR_MM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMOR_MM : MipsInst_VMOR_MM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMOR_MM {
	let  EncodingPredicates=[];
}
class MSA_3R_BINSX_DESC_BASE_VMOR_MM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1);
	string  AsmString="vmor.mm	$vd, $vs2, $vs1";
	list<dag>  Pattern=[];
	string  Constraints="";
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VMOR_MM<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMOR_MM ;
class BINSR_W_DESC_VMOR_MM : MSA_3R_BINSX_DESC_BASE_VMOR_MM <"binsr.w", null_frag, ?>;
class BINSR_W_ENC_VMOR_MM : MSA_3R_FMT_VMOR_MM <0b111, 0b10, 0b001101>;
def VMOR_MM : BINSR_W_ENC_VMOR_MM , BINSR_W_DESC_VMOR_MM , VMOR_MM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMNOR_MM;
class MipsInst_VMNOR_MM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMNOR_MM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMNOR_MM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMNOR_MM : MipsInst_VMNOR_MM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMNOR_MM {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VMNOR_MM<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMNOR_MM ;
class MSA_3R_DESC_BASE_VMNOR_MM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1);
	string  AsmString="vmnor.mm	$vd, $vs2, $vs1";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class BCLR_W_ENC_VMNOR_MM : MSA_3R_FMT_VMNOR_MM <0b011, 0b10, 0b001101>;
class BCLR_W_DESC_VMNOR_MM : MSA_3R_DESC_BASE_VMNOR_MM <"bclr.w", null_frag, ?>;
def VMNOR_MM : BCLR_W_ENC_VMNOR_MM , BCLR_W_DESC_VMNOR_MM , VMNOR_MM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMORNOT_MM;
class MipsInst_VMORNOT_MM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMORNOT_MM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMORNOT_MM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMORNOT_MM : MipsInst_VMORNOT_MM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMORNOT_MM {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VMORNOT_MM<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMORNOT_MM ;
class MSA_3R_DESC_BASE_VMORNOT_MM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1);
	string  AsmString="vmornot.mm	$vd, $vs2, $vs1";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class BCLR_W_ENC_VMORNOT_MM : MSA_3R_FMT_VMORNOT_MM <0b011, 0b10, 0b001101>;
class BCLR_W_DESC_VMORNOT_MM : MSA_3R_DESC_BASE_VMORNOT_MM <"bclr.w", null_frag, ?>;
def VMORNOT_MM : BCLR_W_ENC_VMORNOT_MM , BCLR_W_DESC_VMORNOT_MM , VMORNOT_MM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VOR_VI;
class MipsInst_VOR_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VOR_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VOR_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VOR_VI : MipsInst_VOR_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VOR_VI {
	let  EncodingPredicates=[];
}
class MSA_I8_FMT_VOR_VI<bits<2>  major, bits<6>  minor> : MSAInst_VOR_VI ;
class BSELI_B_DESC_VOR_VI{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, simm5:$imm, VMaskOp:$vm);
	string  AsmString="vor.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=NoItinerary;
	string  Constraints="";
}
class BSELI_B_ENC_VOR_VI : MSA_I8_FMT_VOR_VI <0b10, 0b000001>;
def VOR_VI : BSELI_B_ENC_VOR_VI , BSELI_B_DESC_VOR_VI , VOR_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VPOPC_M;
class MipsInst_VPOPC_M<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VPOPC_M {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VPOPC_M{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VPOPC_M : MipsInst_VPOPC_M <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VPOPC_M {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VPOPC_M<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs GPR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vpopc.m	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VPOPC_M<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VPOPC_M ;
class BSET_W_DESC_VPOPC_M : MSA_3R_DESC_BASE_VPOPC_M <"bset.w", null_frag, ?>;
class BSET_W_ENC_VPOPC_M : MSA_3R_FMT_VPOPC_M <0b100, 0b10, 0b001101>;
def VPOPC_M : BSET_W_ENC_VPOPC_M , BSET_W_DESC_VPOPC_M , VPOPC_M_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSLIDEUP_VX;
class MipsInst_VSLIDEUP_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSLIDEUP_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSLIDEUP_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSLIDEUP_VX : MipsInst_VSLIDEUP_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSLIDEUP_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VSLIDEUP_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSLIDEUP_VX ;
class MSA_3R_VSHF_DESC_BASE_VSLIDEUP_VX<string  instr_asm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vslideup.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	string  Constraints="@earlyclobber $vd";
	InstrItinClass  Itinerary=itin;
}
class VSHF_W_ENC_VSLIDEUP_VX : MSA_3R_FMT_VSLIDEUP_VX <0b000, 0b10, 0b010101>;
class VSHF_W_DESC_VSLIDEUP_VX : MSA_3R_VSHF_DESC_BASE_VSLIDEUP_VX <"vshf.w", ?>;
def VSLIDEUP_VX : VSHF_W_ENC_VSLIDEUP_VX , VSHF_W_DESC_VSLIDEUP_VX , VSLIDEUP_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSLIDEDOWN_VX;
class MipsInst_VSLIDEDOWN_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSLIDEDOWN_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSLIDEDOWN_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSLIDEDOWN_VX : MipsInst_VSLIDEDOWN_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSLIDEDOWN_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_SLD_DESC_BASE_VSLIDEDOWN_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vslidedown.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="";
}
class MSA_3R_INDEX_FMT_VSLIDEDOWN_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSLIDEDOWN_VX ;
class SLD_W_DESC_VSLIDEDOWN_VX : MSA_3R_SLD_DESC_BASE_VSLIDEDOWN_VX <"sld.w", null_frag, ?>;
class SLD_W_ENC_VSLIDEDOWN_VX : MSA_3R_INDEX_FMT_VSLIDEDOWN_VX <0b000, 0b10, 0b010100>;
def VSLIDEDOWN_VX : SLD_W_ENC_VSLIDEDOWN_VX , SLD_W_DESC_VSLIDEDOWN_VX , VSLIDEDOWN_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSLIDEUP_VI;
class MipsInst_VSLIDEUP_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSLIDEUP_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSLIDEUP_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSLIDEUP_VI : MipsInst_VSLIDEUP_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSLIDEUP_VI {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VSLIDEUP_VI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, uimm5:$imm, VMaskOp:$vm);
	string  AsmString="vslideup.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VSLIDEUP_VI<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSLIDEUP_VI ;
class ILVOD_W_DESC_VSLIDEUP_VI : MSA_3R_DESC_BASE_VSLIDEUP_VI <"ilvod.w", null_frag, ?>;
class ILVOD_W_ENC_VSLIDEUP_VI : MSA_3R_FMT_VSLIDEUP_VI <0b111, 0b10, 0b010100>;
def VSLIDEUP_VI : ILVOD_W_ENC_VSLIDEUP_VI , ILVOD_W_DESC_VSLIDEUP_VI , VSLIDEUP_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSLIDE1UP_VX;
class MipsInst_VSLIDE1UP_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSLIDE1UP_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSLIDE1UP_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSLIDE1UP_VX : MipsInst_VSLIDE1UP_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSLIDE1UP_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VSLIDE1UP_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSLIDE1UP_VX ;
class MSA_3R_DESC_BASE_VSLIDE1UP_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vslide1up.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class ILVEV_W_ENC_VSLIDE1UP_VX : MSA_3R_FMT_VSLIDE1UP_VX <0b110, 0b10, 0b010100>;
class ILVEV_W_DESC_VSLIDE1UP_VX : MSA_3R_DESC_BASE_VSLIDE1UP_VX <"ilvev.w", null_frag, ?>;
def VSLIDE1UP_VX : ILVEV_W_ENC_VSLIDE1UP_VX , ILVEV_W_DESC_VSLIDE1UP_VX , VSLIDE1UP_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSLIDEDOWN_VI;
class MipsInst_VSLIDEDOWN_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSLIDEDOWN_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSLIDEDOWN_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSLIDEDOWN_VI : MipsInst_VSLIDEDOWN_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSLIDEDOWN_VI {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VSLIDEDOWN_VI<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSLIDEDOWN_VI ;
class MSA_3R_DESC_BASE_VSLIDEDOWN_VI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, uimm5:$imm, VMaskOp:$vm);
	string  AsmString="vslidedown.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class ILVEV_W_ENC_VSLIDEDOWN_VI : MSA_3R_FMT_VSLIDEDOWN_VI <0b110, 0b10, 0b010100>;
class ILVEV_W_DESC_VSLIDEDOWN_VI : MSA_3R_DESC_BASE_VSLIDEDOWN_VI <"ilvev.w", null_frag, ?>;
def VSLIDEDOWN_VI : ILVEV_W_ENC_VSLIDEDOWN_VI , ILVEV_W_DESC_VSLIDEDOWN_VI , VSLIDEDOWN_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VFSLIDE1DOWN_VF;
class MipsInst_VFSLIDE1DOWN_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFSLIDE1DOWN_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFSLIDE1DOWN_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFSLIDE1DOWN_VF : MipsInst_VFSLIDE1DOWN_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFSLIDE1DOWN_VF {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VFSLIDE1DOWN_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vfslide1down.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VFSLIDE1DOWN_VF<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFSLIDE1DOWN_VF ;
class ILVR_W_DESC_VFSLIDE1DOWN_VF : MSA_3R_DESC_BASE_VFSLIDE1DOWN_VF <"ilvr.w", null_frag, ?>;
class ILVR_W_ENC_VFSLIDE1DOWN_VF : MSA_3R_FMT_VFSLIDE1DOWN_VF <0b101, 0b10, 0b010100>;
def VFSLIDE1DOWN_VF : ILVR_W_ENC_VFSLIDE1DOWN_VF , ILVR_W_DESC_VFSLIDE1DOWN_VF , VFSLIDE1DOWN_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VSLIDE1DOWN_VX;
class MipsInst_VSLIDE1DOWN_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSLIDE1DOWN_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSLIDE1DOWN_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSLIDE1DOWN_VX : MipsInst_VSLIDE1DOWN_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSLIDE1DOWN_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VSLIDE1DOWN_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSLIDE1DOWN_VX ;
class MSA_3R_DESC_BASE_VSLIDE1DOWN_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vslide1down.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class ILVEV_W_ENC_VSLIDE1DOWN_VX : MSA_3R_FMT_VSLIDE1DOWN_VX <0b110, 0b10, 0b010100>;
class ILVEV_W_DESC_VSLIDE1DOWN_VX : MSA_3R_DESC_BASE_VSLIDE1DOWN_VX <"ilvev.w", null_frag, ?>;
def VSLIDE1DOWN_VX : ILVEV_W_ENC_VSLIDE1DOWN_VX , ILVEV_W_DESC_VSLIDE1DOWN_VX , VSLIDE1DOWN_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VFSLIDE1UP_VF;
class MipsInst_VFSLIDE1UP_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFSLIDE1UP_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFSLIDE1UP_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFSLIDE1UP_VF : MipsInst_VFSLIDE1UP_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFSLIDE1UP_VF {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VFSLIDE1UP_VF<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFSLIDE1UP_VF ;
class MSA_3R_DESC_BASE_VFSLIDE1UP_VF<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vfslide1up.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class ILVL_W_ENC_VFSLIDE1UP_VF : MSA_3R_FMT_VFSLIDE1UP_VF <0b100, 0b10, 0b010100>;
class ILVL_W_DESC_VFSLIDE1UP_VF : MSA_3R_DESC_BASE_VFSLIDE1UP_VF <"ilvl.w", null_frag, ?>;
def VFSLIDE1UP_VF : ILVL_W_ENC_VFSLIDE1UP_VF , ILVL_W_DESC_VFSLIDE1UP_VF , VFSLIDE1UP_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VSLL_VV;
class MipsInst_VSLL_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSLL_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSLL_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSLL_VV : MipsInst_VSLL_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSLL_VV {
	let  EncodingPredicates=[];
}
class MSA_BIT_X_DESC_BASE_VSLL_VV<string  instr_asm, SDPatternOperator  OpNode, Operand  ImmOp, ImmLeaf  Imm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vsll.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_BIT_W_FMT_VSLL_VV<bits<3>  major, bits<6>  minor> : MSAInst_VSLL_VV ;
class SRARI_W_DESC_VSLL_VV : MSA_BIT_X_DESC_BASE_VSLL_VV <"srari.w", null_frag, ?, ?, ?>;
class SRARI_W_ENC_VSLL_VV : MSA_BIT_W_FMT_VSLL_VV <0b010, 0b001010>;
def VSLL_VV : SRARI_W_ENC_VSLL_VV , SRARI_W_DESC_VSLL_VV , VSLL_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSLL_VX;
class MipsInst_VSLL_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSLL_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSLL_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSLL_VX : MipsInst_VSLL_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSLL_VX {
	let  EncodingPredicates=[];
}
class MSA_BIT_W_FMT_VSLL_VX<bits<3>  major, bits<6>  minor> : MSAInst_VSLL_VX ;
class MSA_BIT_SPLAT_DESC_BASE_VSLL_VX<string  instr_asm, SDPatternOperator  OpNode, ComplexPattern  SplatImm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsll.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class SRAI_W_ENC_VSLL_VX : MSA_BIT_W_FMT_VSLL_VX <0b001, 0b001001>;
class SRAI_W_DESC_VSLL_VX : MSA_BIT_SPLAT_DESC_BASE_VSLL_VX <"srai.w", null_frag, ?, ?>;
def VSLL_VX : SRAI_W_ENC_VSLL_VX , SRAI_W_DESC_VSLL_VX , VSLL_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSLL_VI;
class MipsInst_VSLL_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSLL_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSLL_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSLL_VI : MipsInst_VSLL_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSLL_VI {
	let  EncodingPredicates=[];
}
class MSA_BIT_X_DESC_BASE_VSLL_VI<string  instr_asm, SDPatternOperator  OpNode, Operand  ImmOp, ImmLeaf  Imm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, uimm5:$imm, VMaskOp:$vm);
	string  AsmString="vsll.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_BIT_W_FMT_VSLL_VI<bits<3>  major, bits<6>  minor> : MSAInst_VSLL_VI ;
class SRARI_W_DESC_VSLL_VI : MSA_BIT_X_DESC_BASE_VSLL_VI <"srari.w", null_frag, ?, ?, ?>;
class SRARI_W_ENC_VSLL_VI : MSA_BIT_W_FMT_VSLL_VI <0b010, 0b001010>;
def VSLL_VI : SRARI_W_ENC_VSLL_VI , SRARI_W_DESC_VSLL_VI , VSLL_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VZEXT_VF2;
class MipsInst_VZEXT_VF2<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VZEXT_VF2 {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VZEXT_VF2{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VZEXT_VF2 : MipsInst_VZEXT_VF2 <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VZEXT_VF2 {
	let  EncodingPredicates=[];
}
class MSA_3R_SPLAT_DESC_BASE_VZEXT_VF2<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vzext.vf2	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_INDEX_FMT_VZEXT_VF2<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VZEXT_VF2 ;
class SPLAT_W_DESC_VZEXT_VF2 : MSA_3R_SPLAT_DESC_BASE_VZEXT_VF2 <"splat.w", null_frag, ?>;
class SPLAT_W_ENC_VZEXT_VF2 : MSA_3R_INDEX_FMT_VZEXT_VF2 <0b001, 0b10, 0b010100>;
def VZEXT_VF2 : SPLAT_W_ENC_VZEXT_VF2 , SPLAT_W_DESC_VZEXT_VF2 , VZEXT_VF2_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSEXT_VF2;
class MipsInst_VSEXT_VF2<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSEXT_VF2 {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSEXT_VF2{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSEXT_VF2 : MipsInst_VSEXT_VF2 <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSEXT_VF2 {
	let  EncodingPredicates=[];
}
class MSA_3R_SPLAT_DESC_BASE_VSEXT_VF2<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsext.vf2	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_INDEX_FMT_VSEXT_VF2<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSEXT_VF2 ;
class SPLAT_W_DESC_VSEXT_VF2 : MSA_3R_SPLAT_DESC_BASE_VSEXT_VF2 <"splat.w", null_frag, ?>;
class SPLAT_W_ENC_VSEXT_VF2 : MSA_3R_INDEX_FMT_VSEXT_VF2 <0b001, 0b10, 0b010100>;
def VSEXT_VF2 : SPLAT_W_ENC_VSEXT_VF2 , SPLAT_W_DESC_VSEXT_VF2 , VSEXT_VF2_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VZEXT_VF4;
class MipsInst_VZEXT_VF4<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VZEXT_VF4 {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VZEXT_VF4{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VZEXT_VF4 : MipsInst_VZEXT_VF4 <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VZEXT_VF4 {
	let  EncodingPredicates=[];
}
class MSA_3R_SPLAT_DESC_BASE_VZEXT_VF4<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vzext.vf4	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_INDEX_FMT_VZEXT_VF4<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VZEXT_VF4 ;
class SPLAT_W_DESC_VZEXT_VF4 : MSA_3R_SPLAT_DESC_BASE_VZEXT_VF4 <"splat.w", null_frag, ?>;
class SPLAT_W_ENC_VZEXT_VF4 : MSA_3R_INDEX_FMT_VZEXT_VF4 <0b001, 0b10, 0b010100>;
def VZEXT_VF4 : SPLAT_W_ENC_VZEXT_VF4 , SPLAT_W_DESC_VZEXT_VF4 , VZEXT_VF4_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSEXT_VF4;
class MipsInst_VSEXT_VF4<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSEXT_VF4 {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSEXT_VF4{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSEXT_VF4 : MipsInst_VSEXT_VF4 <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSEXT_VF4 {
	let  EncodingPredicates=[];
}
class MSA_3R_SPLAT_DESC_BASE_VSEXT_VF4<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsext.vf4	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_INDEX_FMT_VSEXT_VF4<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSEXT_VF4 ;
class SPLAT_W_DESC_VSEXT_VF4 : MSA_3R_SPLAT_DESC_BASE_VSEXT_VF4 <"splat.w", null_frag, ?>;
class SPLAT_W_ENC_VSEXT_VF4 : MSA_3R_INDEX_FMT_VSEXT_VF4 <0b001, 0b10, 0b010100>;
def VSEXT_VF4 : SPLAT_W_ENC_VSEXT_VF4 , SPLAT_W_DESC_VSEXT_VF4 , VSEXT_VF4_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VZEXT_VF8;
class MipsInst_VZEXT_VF8<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VZEXT_VF8 {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VZEXT_VF8{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VZEXT_VF8 : MipsInst_VZEXT_VF8 <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VZEXT_VF8 {
	let  EncodingPredicates=[];
}
class MSA_3R_SPLAT_DESC_BASE_VZEXT_VF8<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vzext.vf8	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_INDEX_FMT_VZEXT_VF8<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VZEXT_VF8 ;
class SPLAT_W_DESC_VZEXT_VF8 : MSA_3R_SPLAT_DESC_BASE_VZEXT_VF8 <"splat.w", null_frag, ?>;
class SPLAT_W_ENC_VZEXT_VF8 : MSA_3R_INDEX_FMT_VZEXT_VF8 <0b001, 0b10, 0b010100>;
def VZEXT_VF8 : SPLAT_W_ENC_VZEXT_VF8 , SPLAT_W_DESC_VZEXT_VF8 , VZEXT_VF8_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSEXT_VF8;
class MipsInst_VSEXT_VF8<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSEXT_VF8 {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSEXT_VF8{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSEXT_VF8 : MipsInst_VSEXT_VF8 <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSEXT_VF8 {
	let  EncodingPredicates=[];
}
class MSA_3R_SPLAT_DESC_BASE_VSEXT_VF8<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsext.vf8	$vd, $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_INDEX_FMT_VSEXT_VF8<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSEXT_VF8 ;
class SPLAT_W_DESC_VSEXT_VF8 : MSA_3R_SPLAT_DESC_BASE_VSEXT_VF8 <"splat.w", null_frag, ?>;
class SPLAT_W_ENC_VSEXT_VF8 : MSA_3R_INDEX_FMT_VSEXT_VF8 <0b001, 0b10, 0b010100>;
def VSEXT_VF8 : SPLAT_W_ENC_VSEXT_VF8 , SPLAT_W_DESC_VSEXT_VF8 , VSEXT_VF8_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSRA_VV;
class MipsInst_VSRA_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSRA_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSRA_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSRA_VV : MipsInst_VSRA_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSRA_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VSRA_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vsra.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VSRA_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSRA_VV ;
class SRAR_W_DESC_VSRA_VV : MSA_3R_DESC_BASE_VSRA_VV <"srar.w", null_frag, ?>;
class SRAR_W_ENC_VSRA_VV : MSA_3R_FMT_VSRA_VV <0b001, 0b10, 0b010101>;
def VSRA_VV : SRAR_W_ENC_VSRA_VV , SRAR_W_DESC_VSRA_VV , VSRA_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VNSRA_WX;
class MipsInst_VNSRA_WX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VNSRA_WX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VNSRA_WX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VNSRA_WX : MipsInst_VNSRA_WX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VNSRA_WX {
	let  EncodingPredicates=[];
}
class MSA_BIT_SPLAT_DESC_BASE_VNSRA_WX<string  instr_asm, SDPatternOperator  OpNode, ComplexPattern  SplatImm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vnsra.wx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_BIT_D_FMT_VNSRA_WX<bits<3>  major, bits<6>  minor> : MSAInst_VNSRA_WX ;
class SRLI_D_DESC_VNSRA_WX : MSA_BIT_SPLAT_DESC_BASE_VNSRA_WX <"srli.d", null_frag, ?, ?>;
class SRLI_D_ENC_VNSRA_WX : MSA_BIT_D_FMT_VNSRA_WX <0b010, 0b001001>;
def VNSRA_WX : SRLI_D_ENC_VNSRA_WX , SRLI_D_DESC_VNSRA_WX , VNSRA_WX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSRA_VX;
class MipsInst_VSRA_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSRA_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSRA_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSRA_VX : MipsInst_VSRA_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSRA_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VSRA_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSRA_VX ;
class MSA_3R_DESC_BASE_VSRA_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsra.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class SRL_W_ENC_VSRA_VX : MSA_3R_FMT_VSRA_VX <0b010, 0b10, 0b001101>;
class SRL_W_DESC_VSRA_VX : MSA_3R_DESC_BASE_VSRA_VX <"srl.w", null_frag, ?>;
def VSRA_VX : SRL_W_ENC_VSRA_VX , SRL_W_DESC_VSRA_VX , VSRA_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VNSRA_WV;
class MipsInst_VNSRA_WV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VNSRA_WV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VNSRA_WV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VNSRA_WV : MipsInst_VNSRA_WV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VNSRA_WV {
	let  EncodingPredicates=[];
}
class MSA_BIT_SPLAT_DESC_BASE_VNSRA_WV<string  instr_asm, SDPatternOperator  OpNode, ComplexPattern  SplatImm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vnsra.wv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_BIT_D_FMT_VNSRA_WV<bits<3>  major, bits<6>  minor> : MSAInst_VNSRA_WV ;
class SRLI_D_DESC_VNSRA_WV : MSA_BIT_SPLAT_DESC_BASE_VNSRA_WV <"srli.d", null_frag, ?, ?>;
class SRLI_D_ENC_VNSRA_WV : MSA_BIT_D_FMT_VNSRA_WV <0b010, 0b001001>;
def VNSRA_WV : SRLI_D_ENC_VNSRA_WV , SRLI_D_DESC_VNSRA_WV , VNSRA_WV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSRA_VI;
class MipsInst_VSRA_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSRA_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSRA_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSRA_VI : MipsInst_VSRA_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSRA_VI {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VSRA_VI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, uimm5:$imm, VMaskOp:$vm);
	string  AsmString="vsra.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VSRA_VI<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSRA_VI ;
class SRAR_W_DESC_VSRA_VI : MSA_3R_DESC_BASE_VSRA_VI <"srar.w", null_frag, ?>;
class SRAR_W_ENC_VSRA_VI : MSA_3R_FMT_VSRA_VI <0b001, 0b10, 0b010101>;
def VSRA_VI : SRAR_W_ENC_VSRA_VI , SRAR_W_DESC_VSRA_VI , VSRA_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VNSRA_WI;
class MipsInst_VNSRA_WI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VNSRA_WI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VNSRA_WI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VNSRA_WI : MipsInst_VNSRA_WI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VNSRA_WI {
	let  EncodingPredicates=[];
}
class MSA_BIT_X_DESC_BASE_VNSRA_WI<string  instr_asm, SDPatternOperator  OpNode, Operand  ImmOp, ImmLeaf  Imm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, uimm5:$imm, VMaskOp:$vm);
	string  AsmString="vnsra.wi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_BIT_D_FMT_VNSRA_WI<bits<3>  major, bits<6>  minor> : MSAInst_VNSRA_WI ;
class SRLRI_D_DESC_VNSRA_WI : MSA_BIT_X_DESC_BASE_VNSRA_WI <"srlri.d", null_frag, ?, ?, ?>;
class SRLRI_D_ENC_VNSRA_WI : MSA_BIT_D_FMT_VNSRA_WI <0b011, 0b001010>;
def VNSRA_WI : SRLRI_D_ENC_VNSRA_WI , SRLRI_D_DESC_VNSRA_WI , VNSRA_WI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSSRA_VV;
class MipsInst_VSSRA_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSRA_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSRA_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSRA_VV : MipsInst_VSSRA_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSRA_VV {
	let  EncodingPredicates=[];
}
class MSA_VEC_FMT_VSSRA_VV<bits<5>  major, bits<6>  minor> : MSAInst_VSSRA_VV ;
class MSA_VEC_DESC_BASE_VSSRA_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vssra.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class NOR_V_ENC_VSSRA_VV : MSA_VEC_FMT_VSSRA_VV <0b00010, 0b011110>;
class NOR_V_DESC_VSSRA_VV : MSA_VEC_DESC_BASE_VSSRA_VV <"nor.v", null_frag, ?>;
def VSSRA_VV : NOR_V_ENC_VSSRA_VV , NOR_V_DESC_VSSRA_VV , VSSRA_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSSRA_VX;
class MipsInst_VSSRA_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSRA_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSRA_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSRA_VX : MipsInst_VSSRA_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSRA_VX {
	let  EncodingPredicates=[];
}
class MSA_VEC_DESC_BASE_VSSRA_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vssra.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_VEC_FMT_VSSRA_VX<bits<5>  major, bits<6>  minor> : MSAInst_VSSRA_VX ;
class XOR_V_DESC_VSSRA_VX : MSA_VEC_DESC_BASE_VSSRA_VX <"xor.v", null_frag, ?>;
class XOR_V_ENC_VSSRA_VX : MSA_VEC_FMT_VSSRA_VX <0b00011, 0b011110>;
def VSSRA_VX : XOR_V_ENC_VSSRA_VX , XOR_V_DESC_VSSRA_VX , VSSRA_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSSRA_VI;
class MipsInst_VSSRA_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSRA_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSRA_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSRA_VI : MipsInst_VSSRA_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSRA_VI {
	let  EncodingPredicates=[];
}
class MSA_VEC_FMT_VSSRA_VI<bits<5>  major, bits<6>  minor> : MSAInst_VSSRA_VI ;
class BSEL_V_DESC_VSSRA_VI{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, uimm5:$imm, VMaskOp:$vm);
	string  AsmString="vssra.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=NoItinerary;
	string  Constraints="";
}
class BSEL_V_ENC_VSSRA_VI : MSA_VEC_FMT_VSSRA_VI <0b00110, 0b011110>;
def VSSRA_VI : BSEL_V_ENC_VSSRA_VI , BSEL_V_DESC_VSSRA_VI , VSSRA_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSRL_VV;
class MipsInst_VSRL_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSRL_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSRL_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSRL_VV : MipsInst_VSRL_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSRL_VV {
	let  EncodingPredicates=[];
}
class MSA_BIT_X_DESC_BASE_VSRL_VV<string  instr_asm, SDPatternOperator  OpNode, Operand  ImmOp, ImmLeaf  Imm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vsrl.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_BIT_W_FMT_VSRL_VV<bits<3>  major, bits<6>  minor> : MSAInst_VSRL_VV ;
class SRARI_W_DESC_VSRL_VV : MSA_BIT_X_DESC_BASE_VSRL_VV <"srari.w", null_frag, ?, ?, ?>;
class SRARI_W_ENC_VSRL_VV : MSA_BIT_W_FMT_VSRL_VV <0b010, 0b001010>;
def VSRL_VV : SRARI_W_ENC_VSRL_VV , SRARI_W_DESC_VSRL_VV , VSRL_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VNSRL_WX;
class MipsInst_VNSRL_WX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VNSRL_WX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VNSRL_WX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VNSRL_WX : MipsInst_VNSRL_WX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VNSRL_WX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VNSRL_WX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VNSRL_WX ;
class MSA_3R_DESC_BASE_VNSRL_WX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vnsrl.wx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class SRL_D_ENC_VNSRL_WX : MSA_3R_FMT_VNSRL_WX <0b010, 0b11, 0b001101>;
class SRL_D_DESC_VNSRL_WX : MSA_3R_DESC_BASE_VNSRL_WX <"srl.d", null_frag, ?>;
def VNSRL_WX : SRL_D_ENC_VNSRL_WX , SRL_D_DESC_VNSRL_WX , VNSRL_WX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSRL_VX;
class MipsInst_VSRL_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSRL_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSRL_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSRL_VX : MipsInst_VSRL_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSRL_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VSRL_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSRL_VX ;
class MSA_3R_DESC_BASE_VSRL_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsrl.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class SRLR_W_ENC_VSRL_VX : MSA_3R_FMT_VSRL_VX <0b010, 0b10, 0b010101>;
class SRLR_W_DESC_VSRL_VX : MSA_3R_DESC_BASE_VSRL_VX <"srlr.w", null_frag, ?>;
def VSRL_VX : SRLR_W_ENC_VSRL_VX , SRLR_W_DESC_VSRL_VX , VSRL_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VNSRL_WV;
class MipsInst_VNSRL_WV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VNSRL_WV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VNSRL_WV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VNSRL_WV : MipsInst_VNSRL_WV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VNSRL_WV {
	let  EncodingPredicates=[];
}
class MSA_BIT_SPLAT_DESC_BASE_VNSRL_WV<string  instr_asm, SDPatternOperator  OpNode, ComplexPattern  SplatImm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vnsrl.wv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_BIT_D_FMT_VNSRL_WV<bits<3>  major, bits<6>  minor> : MSAInst_VNSRL_WV ;
class SRLI_D_DESC_VNSRL_WV : MSA_BIT_SPLAT_DESC_BASE_VNSRL_WV <"srli.d", null_frag, ?, ?>;
class SRLI_D_ENC_VNSRL_WV : MSA_BIT_D_FMT_VNSRL_WV <0b010, 0b001001>;
def VNSRL_WV : SRLI_D_ENC_VNSRL_WV , SRLI_D_DESC_VNSRL_WV , VNSRL_WV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSRL_VI;
class MipsInst_VSRL_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSRL_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSRL_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSRL_VI : MipsInst_VSRL_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSRL_VI {
	let  EncodingPredicates=[];
}
class MSA_BIT_X_DESC_BASE_VSRL_VI<string  instr_asm, SDPatternOperator  OpNode, Operand  ImmOp, ImmLeaf  Imm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, uimm5:$imm, VMaskOp:$vm);
	string  AsmString="vsrl.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_BIT_W_FMT_VSRL_VI<bits<3>  major, bits<6>  minor> : MSAInst_VSRL_VI ;
class SRARI_W_DESC_VSRL_VI : MSA_BIT_X_DESC_BASE_VSRL_VI <"srari.w", null_frag, ?, ?, ?>;
class SRARI_W_ENC_VSRL_VI : MSA_BIT_W_FMT_VSRL_VI <0b010, 0b001010>;
def VSRL_VI : SRARI_W_ENC_VSRL_VI , SRARI_W_DESC_VSRL_VI , VSRL_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VNSRL_WI;
class MipsInst_VNSRL_WI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VNSRL_WI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VNSRL_WI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VNSRL_WI : MipsInst_VNSRL_WI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VNSRL_WI {
	let  EncodingPredicates=[];
}
class MSA_BIT_D_FMT_VNSRL_WI<bits<3>  major, bits<6>  minor> : MSAInst_VNSRL_WI ;
class MSA_BIT_SPLAT_DESC_BASE_VNSRL_WI<string  instr_asm, SDPatternOperator  OpNode, ComplexPattern  SplatImm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, uimm5:$imm, VMaskOp:$vm);
	string  AsmString="vnsrl.wi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class SRAI_D_ENC_VNSRL_WI : MSA_BIT_D_FMT_VNSRL_WI <0b001, 0b001001>;
class SRAI_D_DESC_VNSRL_WI : MSA_BIT_SPLAT_DESC_BASE_VNSRL_WI <"srai.d", null_frag, ?, ?>;
def VNSRL_WI : SRAI_D_ENC_VNSRL_WI , SRAI_D_DESC_VNSRL_WI , VNSRL_WI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSSRL_VV;
class MipsInst_VSSRL_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSRL_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSRL_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSRL_VV : MipsInst_VSSRL_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSRL_VV {
	let  EncodingPredicates=[];
}
class MSA_VEC_FMT_VSSRL_VV<bits<5>  major, bits<6>  minor> : MSAInst_VSSRL_VV ;
class BMNZ_V_DESC_VSSRL_VV{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vssrl.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=NoItinerary;
	string  Constraints="";
}
class BMNZ_V_ENC_VSSRL_VV : MSA_VEC_FMT_VSSRL_VV <0b00100, 0b011110>;
def VSSRL_VV : BMNZ_V_ENC_VSSRL_VV , BMNZ_V_DESC_VSSRL_VV , VSSRL_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSSRL_VX;
class MipsInst_VSSRL_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSRL_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSRL_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSRL_VX : MipsInst_VSSRL_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSRL_VX {
	let  EncodingPredicates=[];
}
class MSA_VEC_FMT_VSSRL_VX<bits<5>  major, bits<6>  minor> : MSAInst_VSSRL_VX ;
class MSA_VEC_DESC_BASE_VSSRL_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vssrl.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class NOR_V_ENC_VSSRL_VX : MSA_VEC_FMT_VSSRL_VX <0b00010, 0b011110>;
class NOR_V_DESC_VSSRL_VX : MSA_VEC_DESC_BASE_VSSRL_VX <"nor.v", null_frag, ?>;
def VSSRL_VX : NOR_V_ENC_VSSRL_VX , NOR_V_DESC_VSSRL_VX , VSSRL_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSSRL_VI;
class MipsInst_VSSRL_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSRL_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSRL_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_BIT_BINSXI_DESC_BASE_VSSRL_VI<string  instr_asm, ValueType  Ty, ComplexPattern  Mask, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, uimm5:$imm, VMaskOp:$vm);
	string  AsmString="vssrl.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="";
}
class MSAInst_VSSRL_VI : MipsInst_VSSRL_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSRL_VI {
	let  EncodingPredicates=[];
}
class MSA_BIT_BINSLI_DESC_BASE_VSSRL_VI<string  instr_asm, ValueType  Ty, ComplexPattern  ImmOp, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary> : MSA_BIT_BINSXI_DESC_BASE_VSSRL_VI <instr_asm, Ty, ImmOp, ROWD, ROWS, itin>;
class MSA_BIT_W_FMT_VSSRL_VI<bits<3>  major, bits<6>  minor> : MSAInst_VSSRL_VI ;
class BINSLI_W_DESC_VSSRL_VI : MSA_BIT_BINSLI_DESC_BASE_VSSRL_VI <"binsli.w", ?, ?, ?>;
class BINSLI_W_ENC_VSSRL_VI : MSA_BIT_W_FMT_VSSRL_VI <0b110, 0b001001>;
def VSSRL_VI : BINSLI_W_ENC_VSSRL_VI , BINSLI_W_DESC_VSSRL_VI , VSSRL_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSE8_V;
class MipsInst_VSE8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSE8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSE8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSE8_V : MipsInst_VSE8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSE8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSE8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSE8_V ;
class ST_DESC_BASE_VSE8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vse8.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSE8_V : MSA_MI10_FMT_VSE8_V <0b00, 0b1001>;
class ST_B_DESC_VSE8_V : ST_DESC_BASE_VSE8_V <"st.b", null_frag, ?, ?, ?>;
def VSE8_V : ST_B_ENC_VSE8_V , ST_B_DESC_VSE8_V , VSE8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSSE8_V;
class MipsInst_VSSE8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSE8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSE8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSE8_V : MipsInst_VSSE8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSE8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSE8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSE8_V ;
class ST_DESC_BASE_VSSE8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vsse8.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSSE8_V : MSA_MI10_FMT_VSSE8_V <0b00, 0b1001>;
class ST_B_DESC_VSSE8_V : ST_DESC_BASE_VSSE8_V <"st.b", null_frag, ?, ?, ?>;
def VSSE8_V : ST_B_ENC_VSSE8_V , ST_B_DESC_VSSE8_V , VSSE8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSUXEI8_V;
class MipsInst_VSUXEI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXEI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXEI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXEI8_V : MipsInst_VSUXEI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXEI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXEI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXEI8_V ;
class ST_DESC_BASE_VSUXEI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxei8.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSUXEI8_V : MSA_MI10_FMT_VSUXEI8_V <0b00, 0b1001>;
class ST_B_DESC_VSUXEI8_V : ST_DESC_BASE_VSUXEI8_V <"st.b", null_frag, ?, ?, ?>;
def VSUXEI8_V : ST_B_ENC_VSUXEI8_V , ST_B_DESC_VSUXEI8_V , VSUXEI8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSOXEI8_V;
class MipsInst_VSOXEI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXEI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXEI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXEI8_V : MipsInst_VSOXEI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXEI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXEI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXEI8_V ;
class ST_DESC_BASE_VSOXEI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxei8.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSOXEI8_V : MSA_MI10_FMT_VSOXEI8_V <0b00, 0b1001>;
class ST_B_DESC_VSOXEI8_V : ST_DESC_BASE_VSOXEI8_V <"st.b", null_frag, ?, ?, ?>;
def VSOXEI8_V : ST_B_ENC_VSOXEI8_V , ST_B_DESC_VSOXEI8_V , VSOXEI8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSSEG2E8_V;
class MipsInst_VSSEG2E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG2E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG2E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG2E8_V : MipsInst_VSSEG2E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG2E8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG2E8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG2E8_V ;
class ST_DESC_BASE_VSSEG2E8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg2e8.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSSEG2E8_V : MSA_MI10_FMT_VSSEG2E8_V <0b00, 0b1001>;
class ST_B_DESC_VSSEG2E8_V : ST_DESC_BASE_VSSEG2E8_V <"st.b", null_frag, ?, ?, ?>;
def VSSEG2E8_V : ST_B_ENC_VSSEG2E8_V , ST_B_DESC_VSSEG2E8_V , VSSEG2E8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG3E8_V;
class MipsInst_VSSEG3E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG3E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG3E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG3E8_V : MipsInst_VSSEG3E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG3E8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG3E8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG3E8_V ;
class ST_DESC_BASE_VSSEG3E8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg3e8.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSSEG3E8_V : MSA_MI10_FMT_VSSEG3E8_V <0b00, 0b1001>;
class ST_B_DESC_VSSEG3E8_V : ST_DESC_BASE_VSSEG3E8_V <"st.b", null_frag, ?, ?, ?>;
def VSSEG3E8_V : ST_B_ENC_VSSEG3E8_V , ST_B_DESC_VSSEG3E8_V , VSSEG3E8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG4E8_V;
class MipsInst_VSSEG4E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG4E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG4E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG4E8_V : MipsInst_VSSEG4E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG4E8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG4E8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG4E8_V ;
class ST_DESC_BASE_VSSEG4E8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg4e8.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSSEG4E8_V : MSA_MI10_FMT_VSSEG4E8_V <0b00, 0b1001>;
class ST_B_DESC_VSSEG4E8_V : ST_DESC_BASE_VSSEG4E8_V <"st.b", null_frag, ?, ?, ?>;
def VSSEG4E8_V : ST_B_ENC_VSSEG4E8_V , ST_B_DESC_VSSEG4E8_V , VSSEG4E8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG5E8_V;
class MipsInst_VSSEG5E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG5E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG5E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG5E8_V : MipsInst_VSSEG5E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG5E8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG5E8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG5E8_V ;
class ST_DESC_BASE_VSSEG5E8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg5e8.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSSEG5E8_V : MSA_MI10_FMT_VSSEG5E8_V <0b00, 0b1001>;
class ST_B_DESC_VSSEG5E8_V : ST_DESC_BASE_VSSEG5E8_V <"st.b", null_frag, ?, ?, ?>;
def VSSEG5E8_V : ST_B_ENC_VSSEG5E8_V , ST_B_DESC_VSSEG5E8_V , VSSEG5E8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG6E8_V;
class MipsInst_VSSEG6E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG6E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG6E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG6E8_V : MipsInst_VSSEG6E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG6E8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG6E8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG6E8_V ;
class ST_DESC_BASE_VSSEG6E8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg6e8.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSSEG6E8_V : MSA_MI10_FMT_VSSEG6E8_V <0b00, 0b1001>;
class ST_B_DESC_VSSEG6E8_V : ST_DESC_BASE_VSSEG6E8_V <"st.b", null_frag, ?, ?, ?>;
def VSSEG6E8_V : ST_B_ENC_VSSEG6E8_V , ST_B_DESC_VSSEG6E8_V , VSSEG6E8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG7E8_V;
class MipsInst_VSSEG7E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG7E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG7E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG7E8_V : MipsInst_VSSEG7E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG7E8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG7E8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG7E8_V ;
class ST_DESC_BASE_VSSEG7E8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg7e8.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSSEG7E8_V : MSA_MI10_FMT_VSSEG7E8_V <0b00, 0b1001>;
class ST_B_DESC_VSSEG7E8_V : ST_DESC_BASE_VSSEG7E8_V <"st.b", null_frag, ?, ?, ?>;
def VSSEG7E8_V : ST_B_ENC_VSSEG7E8_V , ST_B_DESC_VSSEG7E8_V , VSSEG7E8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG8E8_V;
class MipsInst_VSSEG8E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG8E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG8E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG8E8_V : MipsInst_VSSEG8E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG8E8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG8E8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG8E8_V ;
class ST_DESC_BASE_VSSEG8E8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg8e8.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSSEG8E8_V : MSA_MI10_FMT_VSSEG8E8_V <0b00, 0b1001>;
class ST_B_DESC_VSSEG8E8_V : ST_DESC_BASE_VSSEG8E8_V <"st.b", null_frag, ?, ?, ?>;
def VSSEG8E8_V : ST_B_ENC_VSSEG8E8_V , ST_B_DESC_VSSEG8E8_V , VSSEG8E8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG2E8_V;
class MipsInst_VSSSEG2E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG2E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG2E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG2E8_V : MipsInst_VSSSEG2E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG2E8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG2E8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG2E8_V ;
class ST_DESC_BASE_VSSSEG2E8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg2e8.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSSSEG2E8_V : MSA_MI10_FMT_VSSSEG2E8_V <0b00, 0b1001>;
class ST_B_DESC_VSSSEG2E8_V : ST_DESC_BASE_VSSSEG2E8_V <"st.b", null_frag, ?, ?, ?>;
def VSSSEG2E8_V : ST_B_ENC_VSSSEG2E8_V , ST_B_DESC_VSSSEG2E8_V , VSSSEG2E8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG3E8_V;
class MipsInst_VSSSEG3E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG3E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG3E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG3E8_V : MipsInst_VSSSEG3E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG3E8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG3E8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG3E8_V ;
class ST_DESC_BASE_VSSSEG3E8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg3e8.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSSSEG3E8_V : MSA_MI10_FMT_VSSSEG3E8_V <0b00, 0b1001>;
class ST_B_DESC_VSSSEG3E8_V : ST_DESC_BASE_VSSSEG3E8_V <"st.b", null_frag, ?, ?, ?>;
def VSSSEG3E8_V : ST_B_ENC_VSSSEG3E8_V , ST_B_DESC_VSSSEG3E8_V , VSSSEG3E8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG4E8_V;
class MipsInst_VSSSEG4E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG4E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG4E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG4E8_V : MipsInst_VSSSEG4E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG4E8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG4E8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG4E8_V ;
class ST_DESC_BASE_VSSSEG4E8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg4e8.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSSSEG4E8_V : MSA_MI10_FMT_VSSSEG4E8_V <0b00, 0b1001>;
class ST_B_DESC_VSSSEG4E8_V : ST_DESC_BASE_VSSSEG4E8_V <"st.b", null_frag, ?, ?, ?>;
def VSSSEG4E8_V : ST_B_ENC_VSSSEG4E8_V , ST_B_DESC_VSSSEG4E8_V , VSSSEG4E8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG5E8_V;
class MipsInst_VSSSEG5E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG5E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG5E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG5E8_V : MipsInst_VSSSEG5E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG5E8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG5E8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG5E8_V ;
class ST_DESC_BASE_VSSSEG5E8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg5e8.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSSSEG5E8_V : MSA_MI10_FMT_VSSSEG5E8_V <0b00, 0b1001>;
class ST_B_DESC_VSSSEG5E8_V : ST_DESC_BASE_VSSSEG5E8_V <"st.b", null_frag, ?, ?, ?>;
def VSSSEG5E8_V : ST_B_ENC_VSSSEG5E8_V , ST_B_DESC_VSSSEG5E8_V , VSSSEG5E8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG6E8_V;
class MipsInst_VSSSEG6E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG6E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG6E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG6E8_V : MipsInst_VSSSEG6E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG6E8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG6E8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG6E8_V ;
class ST_DESC_BASE_VSSSEG6E8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg6e8.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSSSEG6E8_V : MSA_MI10_FMT_VSSSEG6E8_V <0b00, 0b1001>;
class ST_B_DESC_VSSSEG6E8_V : ST_DESC_BASE_VSSSEG6E8_V <"st.b", null_frag, ?, ?, ?>;
def VSSSEG6E8_V : ST_B_ENC_VSSSEG6E8_V , ST_B_DESC_VSSSEG6E8_V , VSSSEG6E8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG7E8_V;
class MipsInst_VSSSEG7E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG7E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG7E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG7E8_V : MipsInst_VSSSEG7E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG7E8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG7E8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG7E8_V ;
class ST_DESC_BASE_VSSSEG7E8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg7e8.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSSSEG7E8_V : MSA_MI10_FMT_VSSSEG7E8_V <0b00, 0b1001>;
class ST_B_DESC_VSSSEG7E8_V : ST_DESC_BASE_VSSSEG7E8_V <"st.b", null_frag, ?, ?, ?>;
def VSSSEG7E8_V : ST_B_ENC_VSSSEG7E8_V , ST_B_DESC_VSSSEG7E8_V , VSSSEG7E8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG8E8_V;
class MipsInst_VSSSEG8E8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG8E8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG8E8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG8E8_V : MipsInst_VSSSEG8E8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG8E8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG8E8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG8E8_V ;
class ST_DESC_BASE_VSSSEG8E8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg8e8.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSSSEG8E8_V : MSA_MI10_FMT_VSSSEG8E8_V <0b00, 0b1001>;
class ST_B_DESC_VSSSEG8E8_V : ST_DESC_BASE_VSSSEG8E8_V <"st.b", null_frag, ?, ?, ?>;
def VSSSEG8E8_V : ST_B_ENC_VSSSEG8E8_V , ST_B_DESC_VSSSEG8E8_V , VSSSEG8E8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG2EI8_V;
class MipsInst_VSUXSEG2EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG2EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG2EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG2EI8_V : MipsInst_VSUXSEG2EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG2EI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG2EI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG2EI8_V ;
class ST_DESC_BASE_VSUXSEG2EI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg2ei8.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSUXSEG2EI8_V : MSA_MI10_FMT_VSUXSEG2EI8_V <0b00, 0b1001>;
class ST_B_DESC_VSUXSEG2EI8_V : ST_DESC_BASE_VSUXSEG2EI8_V <"st.b", null_frag, ?, ?, ?>;
def VSUXSEG2EI8_V : ST_B_ENC_VSUXSEG2EI8_V , ST_B_DESC_VSUXSEG2EI8_V , VSUXSEG2EI8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG3EI8_V;
class MipsInst_VSUXSEG3EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG3EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG3EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG3EI8_V : MipsInst_VSUXSEG3EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG3EI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG3EI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG3EI8_V ;
class ST_DESC_BASE_VSUXSEG3EI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg3ei8.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSUXSEG3EI8_V : MSA_MI10_FMT_VSUXSEG3EI8_V <0b00, 0b1001>;
class ST_B_DESC_VSUXSEG3EI8_V : ST_DESC_BASE_VSUXSEG3EI8_V <"st.b", null_frag, ?, ?, ?>;
def VSUXSEG3EI8_V : ST_B_ENC_VSUXSEG3EI8_V , ST_B_DESC_VSUXSEG3EI8_V , VSUXSEG3EI8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG4EI8_V;
class MipsInst_VSUXSEG4EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG4EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG4EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG4EI8_V : MipsInst_VSUXSEG4EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG4EI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG4EI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG4EI8_V ;
class ST_DESC_BASE_VSUXSEG4EI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg4ei8.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSUXSEG4EI8_V : MSA_MI10_FMT_VSUXSEG4EI8_V <0b00, 0b1001>;
class ST_B_DESC_VSUXSEG4EI8_V : ST_DESC_BASE_VSUXSEG4EI8_V <"st.b", null_frag, ?, ?, ?>;
def VSUXSEG4EI8_V : ST_B_ENC_VSUXSEG4EI8_V , ST_B_DESC_VSUXSEG4EI8_V , VSUXSEG4EI8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG5EI8_V;
class MipsInst_VSUXSEG5EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG5EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG5EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG5EI8_V : MipsInst_VSUXSEG5EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG5EI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG5EI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG5EI8_V ;
class ST_DESC_BASE_VSUXSEG5EI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg5ei8.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSUXSEG5EI8_V : MSA_MI10_FMT_VSUXSEG5EI8_V <0b00, 0b1001>;
class ST_B_DESC_VSUXSEG5EI8_V : ST_DESC_BASE_VSUXSEG5EI8_V <"st.b", null_frag, ?, ?, ?>;
def VSUXSEG5EI8_V : ST_B_ENC_VSUXSEG5EI8_V , ST_B_DESC_VSUXSEG5EI8_V , VSUXSEG5EI8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG6EI8_V;
class MipsInst_VSUXSEG6EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG6EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG6EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG6EI8_V : MipsInst_VSUXSEG6EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG6EI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG6EI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG6EI8_V ;
class ST_DESC_BASE_VSUXSEG6EI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg6ei8.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSUXSEG6EI8_V : MSA_MI10_FMT_VSUXSEG6EI8_V <0b00, 0b1001>;
class ST_B_DESC_VSUXSEG6EI8_V : ST_DESC_BASE_VSUXSEG6EI8_V <"st.b", null_frag, ?, ?, ?>;
def VSUXSEG6EI8_V : ST_B_ENC_VSUXSEG6EI8_V , ST_B_DESC_VSUXSEG6EI8_V , VSUXSEG6EI8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG7EI8_V;
class MipsInst_VSUXSEG7EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG7EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG7EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG7EI8_V : MipsInst_VSUXSEG7EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG7EI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG7EI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG7EI8_V ;
class ST_DESC_BASE_VSUXSEG7EI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg7ei8.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSUXSEG7EI8_V : MSA_MI10_FMT_VSUXSEG7EI8_V <0b00, 0b1001>;
class ST_B_DESC_VSUXSEG7EI8_V : ST_DESC_BASE_VSUXSEG7EI8_V <"st.b", null_frag, ?, ?, ?>;
def VSUXSEG7EI8_V : ST_B_ENC_VSUXSEG7EI8_V , ST_B_DESC_VSUXSEG7EI8_V , VSUXSEG7EI8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG8EI8_V;
class MipsInst_VSUXSEG8EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG8EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG8EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG8EI8_V : MipsInst_VSUXSEG8EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG8EI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG8EI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG8EI8_V ;
class ST_DESC_BASE_VSUXSEG8EI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg8ei8.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSUXSEG8EI8_V : MSA_MI10_FMT_VSUXSEG8EI8_V <0b00, 0b1001>;
class ST_B_DESC_VSUXSEG8EI8_V : ST_DESC_BASE_VSUXSEG8EI8_V <"st.b", null_frag, ?, ?, ?>;
def VSUXSEG8EI8_V : ST_B_ENC_VSUXSEG8EI8_V , ST_B_DESC_VSUXSEG8EI8_V , VSUXSEG8EI8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG2EI8_V;
class MipsInst_VSOXSEG2EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG2EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG2EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG2EI8_V : MipsInst_VSOXSEG2EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG2EI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG2EI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG2EI8_V ;
class ST_DESC_BASE_VSOXSEG2EI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg2ei8.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSOXSEG2EI8_V : MSA_MI10_FMT_VSOXSEG2EI8_V <0b00, 0b1001>;
class ST_B_DESC_VSOXSEG2EI8_V : ST_DESC_BASE_VSOXSEG2EI8_V <"st.b", null_frag, ?, ?, ?>;
def VSOXSEG2EI8_V : ST_B_ENC_VSOXSEG2EI8_V , ST_B_DESC_VSOXSEG2EI8_V , VSOXSEG2EI8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG3EI8_V;
class MipsInst_VSOXSEG3EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG3EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG3EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG3EI8_V : MipsInst_VSOXSEG3EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG3EI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG3EI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG3EI8_V ;
class ST_DESC_BASE_VSOXSEG3EI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg3ei8.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSOXSEG3EI8_V : MSA_MI10_FMT_VSOXSEG3EI8_V <0b00, 0b1001>;
class ST_B_DESC_VSOXSEG3EI8_V : ST_DESC_BASE_VSOXSEG3EI8_V <"st.b", null_frag, ?, ?, ?>;
def VSOXSEG3EI8_V : ST_B_ENC_VSOXSEG3EI8_V , ST_B_DESC_VSOXSEG3EI8_V , VSOXSEG3EI8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG4EI8_V;
class MipsInst_VSOXSEG4EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG4EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG4EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG4EI8_V : MipsInst_VSOXSEG4EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG4EI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG4EI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG4EI8_V ;
class ST_DESC_BASE_VSOXSEG4EI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg4ei8.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSOXSEG4EI8_V : MSA_MI10_FMT_VSOXSEG4EI8_V <0b00, 0b1001>;
class ST_B_DESC_VSOXSEG4EI8_V : ST_DESC_BASE_VSOXSEG4EI8_V <"st.b", null_frag, ?, ?, ?>;
def VSOXSEG4EI8_V : ST_B_ENC_VSOXSEG4EI8_V , ST_B_DESC_VSOXSEG4EI8_V , VSOXSEG4EI8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG5EI8_V;
class MipsInst_VSOXSEG5EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG5EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG5EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG5EI8_V : MipsInst_VSOXSEG5EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG5EI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG5EI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG5EI8_V ;
class ST_DESC_BASE_VSOXSEG5EI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg5ei8.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSOXSEG5EI8_V : MSA_MI10_FMT_VSOXSEG5EI8_V <0b00, 0b1001>;
class ST_B_DESC_VSOXSEG5EI8_V : ST_DESC_BASE_VSOXSEG5EI8_V <"st.b", null_frag, ?, ?, ?>;
def VSOXSEG5EI8_V : ST_B_ENC_VSOXSEG5EI8_V , ST_B_DESC_VSOXSEG5EI8_V , VSOXSEG5EI8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG6EI8_V;
class MipsInst_VSOXSEG6EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG6EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG6EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG6EI8_V : MipsInst_VSOXSEG6EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG6EI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG6EI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG6EI8_V ;
class ST_DESC_BASE_VSOXSEG6EI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg6ei8.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSOXSEG6EI8_V : MSA_MI10_FMT_VSOXSEG6EI8_V <0b00, 0b1001>;
class ST_B_DESC_VSOXSEG6EI8_V : ST_DESC_BASE_VSOXSEG6EI8_V <"st.b", null_frag, ?, ?, ?>;
def VSOXSEG6EI8_V : ST_B_ENC_VSOXSEG6EI8_V , ST_B_DESC_VSOXSEG6EI8_V , VSOXSEG6EI8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG7EI8_V;
class MipsInst_VSOXSEG7EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG7EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG7EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG7EI8_V : MipsInst_VSOXSEG7EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG7EI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG7EI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG7EI8_V ;
class ST_DESC_BASE_VSOXSEG7EI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg7ei8.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSOXSEG7EI8_V : MSA_MI10_FMT_VSOXSEG7EI8_V <0b00, 0b1001>;
class ST_B_DESC_VSOXSEG7EI8_V : ST_DESC_BASE_VSOXSEG7EI8_V <"st.b", null_frag, ?, ?, ?>;
def VSOXSEG7EI8_V : ST_B_ENC_VSOXSEG7EI8_V , ST_B_DESC_VSOXSEG7EI8_V , VSOXSEG7EI8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG8EI8_V;
class MipsInst_VSOXSEG8EI8_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG8EI8_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG8EI8_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG8EI8_V : MipsInst_VSOXSEG8EI8_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG8EI8_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG8EI8_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG8EI8_V ;
class ST_DESC_BASE_VSOXSEG8EI8_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg8ei8.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VSOXSEG8EI8_V : MSA_MI10_FMT_VSOXSEG8EI8_V <0b00, 0b1001>;
class ST_B_DESC_VSOXSEG8EI8_V : ST_DESC_BASE_VSOXSEG8EI8_V <"st.b", null_frag, ?, ?, ?>;
def VSOXSEG8EI8_V : ST_B_ENC_VSOXSEG8EI8_V , ST_B_DESC_VSOXSEG8EI8_V , VSOXSEG8EI8_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VS1R_V;
class MipsInst_VS1R_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VS1R_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VS1R_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VS1R_V : MipsInst_VS1R_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VS1R_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VS1R_V<bits<2>  df, bits<4>  minor> : MSAInst_VS1R_V ;
class ST_DESC_BASE_VS1R_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1);
	string  AsmString="vs1r.v	$vs3, (${rs1})";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_B_ENC_VS1R_V : MSA_MI10_FMT_VS1R_V <0b00, 0b1001>;
class ST_B_DESC_VS1R_V : ST_DESC_BASE_VS1R_V <"st.b", null_frag, ?, ?, ?>;
def VS1R_V : ST_B_ENC_VS1R_V , ST_B_DESC_VS1R_V , VS1R_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSE1_V;
class MipsInst_VSE1_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSE1_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSE1_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSE1_V : MipsInst_VSE1_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSE1_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSE1_V<bits<2>  df, bits<4>  minor> : MSAInst_VSE1_V ;
class ST_DESC_BASE_VSE1_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1);
	string  AsmString="vse1.v	$vs3, (${rs1})";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSE1_V : MSA_MI10_FMT_VSE1_V <0b10, 0b1001>;
class ST_W_DESC_VSE1_V : ST_DESC_BASE_VSE1_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSE1_V : ST_W_ENC_VSE1_V , ST_W_DESC_VSE1_V , VSE1_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSE64_V;
class MipsInst_VSE64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSE64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSE64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSE64_V : MipsInst_VSE64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSE64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSE64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vse64.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSE64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSE64_V ;
class ST_D_DESC_VSE64_V : ST_DESC_BASE_VSE64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSE64_V : MSA_MI10_FMT_VSE64_V <0b11, 0b1001>;
def VSE64_V : ST_D_ENC_VSE64_V , ST_D_DESC_VSE64_V , VSE64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSSE64_V;
class MipsInst_VSSE64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSE64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSE64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSE64_V : MipsInst_VSSE64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSE64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSSE64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vsse64.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSSE64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSE64_V ;
class ST_D_DESC_VSSE64_V : ST_DESC_BASE_VSSE64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSSE64_V : MSA_MI10_FMT_VSSE64_V <0b11, 0b1001>;
def VSSE64_V : ST_D_ENC_VSSE64_V , ST_D_DESC_VSSE64_V , VSSE64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSUXEI64_V;
class MipsInst_VSUXEI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXEI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXEI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXEI64_V : MipsInst_VSUXEI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXEI64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSUXEI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxei64.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSUXEI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXEI64_V ;
class ST_D_DESC_VSUXEI64_V : ST_DESC_BASE_VSUXEI64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSUXEI64_V : MSA_MI10_FMT_VSUXEI64_V <0b11, 0b1001>;
def VSUXEI64_V : ST_D_ENC_VSUXEI64_V , ST_D_DESC_VSUXEI64_V , VSUXEI64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSOXEI64_V;
class MipsInst_VSOXEI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXEI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXEI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXEI64_V : MipsInst_VSOXEI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXEI64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSOXEI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxei64.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSOXEI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXEI64_V ;
class ST_D_DESC_VSOXEI64_V : ST_DESC_BASE_VSOXEI64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSOXEI64_V : MSA_MI10_FMT_VSOXEI64_V <0b11, 0b1001>;
def VSOXEI64_V : ST_D_ENC_VSOXEI64_V , ST_D_DESC_VSOXEI64_V , VSOXEI64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSSEG2E64_V;
class MipsInst_VSSEG2E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG2E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG2E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG2E64_V : MipsInst_VSSEG2E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG2E64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSSEG2E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg2e64.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSSEG2E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG2E64_V ;
class ST_D_DESC_VSSEG2E64_V : ST_DESC_BASE_VSSEG2E64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSSEG2E64_V : MSA_MI10_FMT_VSSEG2E64_V <0b11, 0b1001>;
def VSSEG2E64_V : ST_D_ENC_VSSEG2E64_V , ST_D_DESC_VSSEG2E64_V , VSSEG2E64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG3E64_V;
class MipsInst_VSSEG3E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG3E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG3E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG3E64_V : MipsInst_VSSEG3E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG3E64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSSEG3E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg3e64.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSSEG3E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG3E64_V ;
class ST_D_DESC_VSSEG3E64_V : ST_DESC_BASE_VSSEG3E64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSSEG3E64_V : MSA_MI10_FMT_VSSEG3E64_V <0b11, 0b1001>;
def VSSEG3E64_V : ST_D_ENC_VSSEG3E64_V , ST_D_DESC_VSSEG3E64_V , VSSEG3E64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG4E64_V;
class MipsInst_VSSEG4E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG4E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG4E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG4E64_V : MipsInst_VSSEG4E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG4E64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSSEG4E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg4e64.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSSEG4E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG4E64_V ;
class ST_D_DESC_VSSEG4E64_V : ST_DESC_BASE_VSSEG4E64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSSEG4E64_V : MSA_MI10_FMT_VSSEG4E64_V <0b11, 0b1001>;
def VSSEG4E64_V : ST_D_ENC_VSSEG4E64_V , ST_D_DESC_VSSEG4E64_V , VSSEG4E64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG5E64_V;
class MipsInst_VSSEG5E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG5E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG5E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG5E64_V : MipsInst_VSSEG5E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG5E64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSSEG5E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg5e64.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSSEG5E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG5E64_V ;
class ST_D_DESC_VSSEG5E64_V : ST_DESC_BASE_VSSEG5E64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSSEG5E64_V : MSA_MI10_FMT_VSSEG5E64_V <0b11, 0b1001>;
def VSSEG5E64_V : ST_D_ENC_VSSEG5E64_V , ST_D_DESC_VSSEG5E64_V , VSSEG5E64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG6E64_V;
class MipsInst_VSSEG6E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG6E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG6E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG6E64_V : MipsInst_VSSEG6E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG6E64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSSEG6E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg6e64.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSSEG6E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG6E64_V ;
class ST_D_DESC_VSSEG6E64_V : ST_DESC_BASE_VSSEG6E64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSSEG6E64_V : MSA_MI10_FMT_VSSEG6E64_V <0b11, 0b1001>;
def VSSEG6E64_V : ST_D_ENC_VSSEG6E64_V , ST_D_DESC_VSSEG6E64_V , VSSEG6E64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG7E64_V;
class MipsInst_VSSEG7E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG7E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG7E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG7E64_V : MipsInst_VSSEG7E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG7E64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSSEG7E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg7e64.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSSEG7E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG7E64_V ;
class ST_D_DESC_VSSEG7E64_V : ST_DESC_BASE_VSSEG7E64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSSEG7E64_V : MSA_MI10_FMT_VSSEG7E64_V <0b11, 0b1001>;
def VSSEG7E64_V : ST_D_ENC_VSSEG7E64_V , ST_D_DESC_VSSEG7E64_V , VSSEG7E64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG8E64_V;
class MipsInst_VSSEG8E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG8E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG8E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG8E64_V : MipsInst_VSSEG8E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG8E64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSSEG8E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg8e64.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSSEG8E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG8E64_V ;
class ST_D_DESC_VSSEG8E64_V : ST_DESC_BASE_VSSEG8E64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSSEG8E64_V : MSA_MI10_FMT_VSSEG8E64_V <0b11, 0b1001>;
def VSSEG8E64_V : ST_D_ENC_VSSEG8E64_V , ST_D_DESC_VSSEG8E64_V , VSSEG8E64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG2E64_V;
class MipsInst_VSSSEG2E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG2E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG2E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG2E64_V : MipsInst_VSSSEG2E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG2E64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSSSEG2E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg2e64.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSSSEG2E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG2E64_V ;
class ST_D_DESC_VSSSEG2E64_V : ST_DESC_BASE_VSSSEG2E64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSSSEG2E64_V : MSA_MI10_FMT_VSSSEG2E64_V <0b11, 0b1001>;
def VSSSEG2E64_V : ST_D_ENC_VSSSEG2E64_V , ST_D_DESC_VSSSEG2E64_V , VSSSEG2E64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG3E64_V;
class MipsInst_VSSSEG3E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG3E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG3E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG3E64_V : MipsInst_VSSSEG3E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG3E64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSSSEG3E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg3e64.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSSSEG3E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG3E64_V ;
class ST_D_DESC_VSSSEG3E64_V : ST_DESC_BASE_VSSSEG3E64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSSSEG3E64_V : MSA_MI10_FMT_VSSSEG3E64_V <0b11, 0b1001>;
def VSSSEG3E64_V : ST_D_ENC_VSSSEG3E64_V , ST_D_DESC_VSSSEG3E64_V , VSSSEG3E64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG4E64_V;
class MipsInst_VSSSEG4E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG4E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG4E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG4E64_V : MipsInst_VSSSEG4E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG4E64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSSSEG4E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg4e64.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSSSEG4E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG4E64_V ;
class ST_D_DESC_VSSSEG4E64_V : ST_DESC_BASE_VSSSEG4E64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSSSEG4E64_V : MSA_MI10_FMT_VSSSEG4E64_V <0b11, 0b1001>;
def VSSSEG4E64_V : ST_D_ENC_VSSSEG4E64_V , ST_D_DESC_VSSSEG4E64_V , VSSSEG4E64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG5E64_V;
class MipsInst_VSSSEG5E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG5E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG5E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG5E64_V : MipsInst_VSSSEG5E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG5E64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSSSEG5E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg5e64.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSSSEG5E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG5E64_V ;
class ST_D_DESC_VSSSEG5E64_V : ST_DESC_BASE_VSSSEG5E64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSSSEG5E64_V : MSA_MI10_FMT_VSSSEG5E64_V <0b11, 0b1001>;
def VSSSEG5E64_V : ST_D_ENC_VSSSEG5E64_V , ST_D_DESC_VSSSEG5E64_V , VSSSEG5E64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG6E64_V;
class MipsInst_VSSSEG6E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG6E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG6E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG6E64_V : MipsInst_VSSSEG6E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG6E64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSSSEG6E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg6e64.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSSSEG6E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG6E64_V ;
class ST_D_DESC_VSSSEG6E64_V : ST_DESC_BASE_VSSSEG6E64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSSSEG6E64_V : MSA_MI10_FMT_VSSSEG6E64_V <0b11, 0b1001>;
def VSSSEG6E64_V : ST_D_ENC_VSSSEG6E64_V , ST_D_DESC_VSSSEG6E64_V , VSSSEG6E64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG7E64_V;
class MipsInst_VSSSEG7E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG7E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG7E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG7E64_V : MipsInst_VSSSEG7E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG7E64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSSSEG7E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg7e64.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSSSEG7E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG7E64_V ;
class ST_D_DESC_VSSSEG7E64_V : ST_DESC_BASE_VSSSEG7E64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSSSEG7E64_V : MSA_MI10_FMT_VSSSEG7E64_V <0b11, 0b1001>;
def VSSSEG7E64_V : ST_D_ENC_VSSSEG7E64_V , ST_D_DESC_VSSSEG7E64_V , VSSSEG7E64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG8E64_V;
class MipsInst_VSSSEG8E64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG8E64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG8E64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG8E64_V : MipsInst_VSSSEG8E64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG8E64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSSSEG8E64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg8e64.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSSSEG8E64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG8E64_V ;
class ST_D_DESC_VSSSEG8E64_V : ST_DESC_BASE_VSSSEG8E64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSSSEG8E64_V : MSA_MI10_FMT_VSSSEG8E64_V <0b11, 0b1001>;
def VSSSEG8E64_V : ST_D_ENC_VSSSEG8E64_V , ST_D_DESC_VSSSEG8E64_V , VSSSEG8E64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG2EI64_V;
class MipsInst_VSUXSEG2EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG2EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG2EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG2EI64_V : MipsInst_VSUXSEG2EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG2EI64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSUXSEG2EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg2ei64.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSUXSEG2EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG2EI64_V ;
class ST_D_DESC_VSUXSEG2EI64_V : ST_DESC_BASE_VSUXSEG2EI64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSUXSEG2EI64_V : MSA_MI10_FMT_VSUXSEG2EI64_V <0b11, 0b1001>;
def VSUXSEG2EI64_V : ST_D_ENC_VSUXSEG2EI64_V , ST_D_DESC_VSUXSEG2EI64_V , VSUXSEG2EI64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG3EI64_V;
class MipsInst_VSUXSEG3EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG3EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG3EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG3EI64_V : MipsInst_VSUXSEG3EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG3EI64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSUXSEG3EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg3ei64.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSUXSEG3EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG3EI64_V ;
class ST_D_DESC_VSUXSEG3EI64_V : ST_DESC_BASE_VSUXSEG3EI64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSUXSEG3EI64_V : MSA_MI10_FMT_VSUXSEG3EI64_V <0b11, 0b1001>;
def VSUXSEG3EI64_V : ST_D_ENC_VSUXSEG3EI64_V , ST_D_DESC_VSUXSEG3EI64_V , VSUXSEG3EI64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG4EI64_V;
class MipsInst_VSUXSEG4EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG4EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG4EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG4EI64_V : MipsInst_VSUXSEG4EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG4EI64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSUXSEG4EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg4ei64.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSUXSEG4EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG4EI64_V ;
class ST_D_DESC_VSUXSEG4EI64_V : ST_DESC_BASE_VSUXSEG4EI64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSUXSEG4EI64_V : MSA_MI10_FMT_VSUXSEG4EI64_V <0b11, 0b1001>;
def VSUXSEG4EI64_V : ST_D_ENC_VSUXSEG4EI64_V , ST_D_DESC_VSUXSEG4EI64_V , VSUXSEG4EI64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG5EI64_V;
class MipsInst_VSUXSEG5EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG5EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG5EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG5EI64_V : MipsInst_VSUXSEG5EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG5EI64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSUXSEG5EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg5ei64.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSUXSEG5EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG5EI64_V ;
class ST_D_DESC_VSUXSEG5EI64_V : ST_DESC_BASE_VSUXSEG5EI64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSUXSEG5EI64_V : MSA_MI10_FMT_VSUXSEG5EI64_V <0b11, 0b1001>;
def VSUXSEG5EI64_V : ST_D_ENC_VSUXSEG5EI64_V , ST_D_DESC_VSUXSEG5EI64_V , VSUXSEG5EI64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG6EI64_V;
class MipsInst_VSUXSEG6EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG6EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG6EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG6EI64_V : MipsInst_VSUXSEG6EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG6EI64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSUXSEG6EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg6ei64.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSUXSEG6EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG6EI64_V ;
class ST_D_DESC_VSUXSEG6EI64_V : ST_DESC_BASE_VSUXSEG6EI64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSUXSEG6EI64_V : MSA_MI10_FMT_VSUXSEG6EI64_V <0b11, 0b1001>;
def VSUXSEG6EI64_V : ST_D_ENC_VSUXSEG6EI64_V , ST_D_DESC_VSUXSEG6EI64_V , VSUXSEG6EI64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG7EI64_V;
class MipsInst_VSUXSEG7EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG7EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG7EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG7EI64_V : MipsInst_VSUXSEG7EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG7EI64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSUXSEG7EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg7ei64.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSUXSEG7EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG7EI64_V ;
class ST_D_DESC_VSUXSEG7EI64_V : ST_DESC_BASE_VSUXSEG7EI64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSUXSEG7EI64_V : MSA_MI10_FMT_VSUXSEG7EI64_V <0b11, 0b1001>;
def VSUXSEG7EI64_V : ST_D_ENC_VSUXSEG7EI64_V , ST_D_DESC_VSUXSEG7EI64_V , VSUXSEG7EI64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG8EI64_V;
class MipsInst_VSUXSEG8EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG8EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG8EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG8EI64_V : MipsInst_VSUXSEG8EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG8EI64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSUXSEG8EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg8ei64.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSUXSEG8EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG8EI64_V ;
class ST_D_DESC_VSUXSEG8EI64_V : ST_DESC_BASE_VSUXSEG8EI64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSUXSEG8EI64_V : MSA_MI10_FMT_VSUXSEG8EI64_V <0b11, 0b1001>;
def VSUXSEG8EI64_V : ST_D_ENC_VSUXSEG8EI64_V , ST_D_DESC_VSUXSEG8EI64_V , VSUXSEG8EI64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG2EI64_V;
class MipsInst_VSOXSEG2EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG2EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG2EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG2EI64_V : MipsInst_VSOXSEG2EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG2EI64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSOXSEG2EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg2ei64.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSOXSEG2EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG2EI64_V ;
class ST_D_DESC_VSOXSEG2EI64_V : ST_DESC_BASE_VSOXSEG2EI64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSOXSEG2EI64_V : MSA_MI10_FMT_VSOXSEG2EI64_V <0b11, 0b1001>;
def VSOXSEG2EI64_V : ST_D_ENC_VSOXSEG2EI64_V , ST_D_DESC_VSOXSEG2EI64_V , VSOXSEG2EI64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG3EI64_V;
class MipsInst_VSOXSEG3EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG3EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG3EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG3EI64_V : MipsInst_VSOXSEG3EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG3EI64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSOXSEG3EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg3ei64.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSOXSEG3EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG3EI64_V ;
class ST_D_DESC_VSOXSEG3EI64_V : ST_DESC_BASE_VSOXSEG3EI64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSOXSEG3EI64_V : MSA_MI10_FMT_VSOXSEG3EI64_V <0b11, 0b1001>;
def VSOXSEG3EI64_V : ST_D_ENC_VSOXSEG3EI64_V , ST_D_DESC_VSOXSEG3EI64_V , VSOXSEG3EI64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG4EI64_V;
class MipsInst_VSOXSEG4EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG4EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG4EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG4EI64_V : MipsInst_VSOXSEG4EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG4EI64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSOXSEG4EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg4ei64.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSOXSEG4EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG4EI64_V ;
class ST_D_DESC_VSOXSEG4EI64_V : ST_DESC_BASE_VSOXSEG4EI64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSOXSEG4EI64_V : MSA_MI10_FMT_VSOXSEG4EI64_V <0b11, 0b1001>;
def VSOXSEG4EI64_V : ST_D_ENC_VSOXSEG4EI64_V , ST_D_DESC_VSOXSEG4EI64_V , VSOXSEG4EI64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG5EI64_V;
class MipsInst_VSOXSEG5EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG5EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG5EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG5EI64_V : MipsInst_VSOXSEG5EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG5EI64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSOXSEG5EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg5ei64.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSOXSEG5EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG5EI64_V ;
class ST_D_DESC_VSOXSEG5EI64_V : ST_DESC_BASE_VSOXSEG5EI64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSOXSEG5EI64_V : MSA_MI10_FMT_VSOXSEG5EI64_V <0b11, 0b1001>;
def VSOXSEG5EI64_V : ST_D_ENC_VSOXSEG5EI64_V , ST_D_DESC_VSOXSEG5EI64_V , VSOXSEG5EI64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG6EI64_V;
class MipsInst_VSOXSEG6EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG6EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG6EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG6EI64_V : MipsInst_VSOXSEG6EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG6EI64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSOXSEG6EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg6ei64.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSOXSEG6EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG6EI64_V ;
class ST_D_DESC_VSOXSEG6EI64_V : ST_DESC_BASE_VSOXSEG6EI64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSOXSEG6EI64_V : MSA_MI10_FMT_VSOXSEG6EI64_V <0b11, 0b1001>;
def VSOXSEG6EI64_V : ST_D_ENC_VSOXSEG6EI64_V , ST_D_DESC_VSOXSEG6EI64_V , VSOXSEG6EI64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG7EI64_V;
class MipsInst_VSOXSEG7EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG7EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG7EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG7EI64_V : MipsInst_VSOXSEG7EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG7EI64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSOXSEG7EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg7ei64.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSOXSEG7EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG7EI64_V ;
class ST_D_DESC_VSOXSEG7EI64_V : ST_DESC_BASE_VSOXSEG7EI64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSOXSEG7EI64_V : MSA_MI10_FMT_VSOXSEG7EI64_V <0b11, 0b1001>;
def VSOXSEG7EI64_V : ST_D_ENC_VSOXSEG7EI64_V , ST_D_DESC_VSOXSEG7EI64_V , VSOXSEG7EI64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG8EI64_V;
class MipsInst_VSOXSEG8EI64_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG8EI64_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG8EI64_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG8EI64_V : MipsInst_VSOXSEG8EI64_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG8EI64_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VSOXSEG8EI64_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg8ei64.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VSOXSEG8EI64_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG8EI64_V ;
class ST_D_DESC_VSOXSEG8EI64_V : ST_DESC_BASE_VSOXSEG8EI64_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VSOXSEG8EI64_V : MSA_MI10_FMT_VSOXSEG8EI64_V <0b11, 0b1001>;
def VSOXSEG8EI64_V : ST_D_ENC_VSOXSEG8EI64_V , ST_D_DESC_VSOXSEG8EI64_V , VSOXSEG8EI64_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VS8R_V;
class MipsInst_VS8R_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VS8R_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VS8R_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VS8R_V : MipsInst_VS8R_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VS8R_V {
	let  EncodingPredicates=[];
}
class ST_DESC_BASE_VS8R_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1);
	string  AsmString="vs8r.v	$vs3, (${rs1})";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VS8R_V<bits<2>  df, bits<4>  minor> : MSAInst_VS8R_V ;
class ST_D_DESC_VS8R_V : ST_DESC_BASE_VS8R_V <"st.d", null_frag, ?, ?, ?, addr>;
class ST_D_ENC_VS8R_V : MSA_MI10_FMT_VS8R_V <0b11, 0b1001>;
def VS8R_V : ST_D_ENC_VS8R_V , ST_D_DESC_VS8R_V , VS8R_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSE16_V;
class MipsInst_VSE16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSE16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSE16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSE16_V : MipsInst_VSE16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSE16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSE16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSE16_V ;
class ST_DESC_BASE_VSE16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vse16.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSE16_V : MSA_MI10_FMT_VSE16_V <0b01, 0b1001>;
class ST_H_DESC_VSE16_V : ST_DESC_BASE_VSE16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSE16_V : ST_H_ENC_VSE16_V , ST_H_DESC_VSE16_V , VSE16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSSE16_V;
class MipsInst_VSSE16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSE16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSE16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSE16_V : MipsInst_VSSE16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSE16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSE16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSE16_V ;
class ST_DESC_BASE_VSSE16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vsse16.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSSE16_V : MSA_MI10_FMT_VSSE16_V <0b01, 0b1001>;
class ST_H_DESC_VSSE16_V : ST_DESC_BASE_VSSE16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSSE16_V : ST_H_ENC_VSSE16_V , ST_H_DESC_VSSE16_V , VSSE16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSUXEI16_V;
class MipsInst_VSUXEI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXEI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXEI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXEI16_V : MipsInst_VSUXEI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXEI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXEI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXEI16_V ;
class ST_DESC_BASE_VSUXEI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxei16.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSUXEI16_V : MSA_MI10_FMT_VSUXEI16_V <0b01, 0b1001>;
class ST_H_DESC_VSUXEI16_V : ST_DESC_BASE_VSUXEI16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSUXEI16_V : ST_H_ENC_VSUXEI16_V , ST_H_DESC_VSUXEI16_V , VSUXEI16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSOXEI16_V;
class MipsInst_VSOXEI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXEI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXEI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXEI16_V : MipsInst_VSOXEI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXEI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXEI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXEI16_V ;
class ST_DESC_BASE_VSOXEI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxei16.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSOXEI16_V : MSA_MI10_FMT_VSOXEI16_V <0b01, 0b1001>;
class ST_H_DESC_VSOXEI16_V : ST_DESC_BASE_VSOXEI16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSOXEI16_V : ST_H_ENC_VSOXEI16_V , ST_H_DESC_VSOXEI16_V , VSOXEI16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSSEG2E16_V;
class MipsInst_VSSEG2E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG2E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG2E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG2E16_V : MipsInst_VSSEG2E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG2E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG2E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG2E16_V ;
class ST_DESC_BASE_VSSEG2E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg2e16.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSSEG2E16_V : MSA_MI10_FMT_VSSEG2E16_V <0b01, 0b1001>;
class ST_H_DESC_VSSEG2E16_V : ST_DESC_BASE_VSSEG2E16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSSEG2E16_V : ST_H_ENC_VSSEG2E16_V , ST_H_DESC_VSSEG2E16_V , VSSEG2E16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG3E16_V;
class MipsInst_VSSEG3E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG3E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG3E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG3E16_V : MipsInst_VSSEG3E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG3E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG3E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG3E16_V ;
class ST_DESC_BASE_VSSEG3E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg3e16.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSSEG3E16_V : MSA_MI10_FMT_VSSEG3E16_V <0b01, 0b1001>;
class ST_H_DESC_VSSEG3E16_V : ST_DESC_BASE_VSSEG3E16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSSEG3E16_V : ST_H_ENC_VSSEG3E16_V , ST_H_DESC_VSSEG3E16_V , VSSEG3E16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG4E16_V;
class MipsInst_VSSEG4E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG4E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG4E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG4E16_V : MipsInst_VSSEG4E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG4E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG4E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG4E16_V ;
class ST_DESC_BASE_VSSEG4E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg4e16.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSSEG4E16_V : MSA_MI10_FMT_VSSEG4E16_V <0b01, 0b1001>;
class ST_H_DESC_VSSEG4E16_V : ST_DESC_BASE_VSSEG4E16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSSEG4E16_V : ST_H_ENC_VSSEG4E16_V , ST_H_DESC_VSSEG4E16_V , VSSEG4E16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG5E16_V;
class MipsInst_VSSEG5E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG5E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG5E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG5E16_V : MipsInst_VSSEG5E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG5E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG5E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG5E16_V ;
class ST_DESC_BASE_VSSEG5E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg5e16.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSSEG5E16_V : MSA_MI10_FMT_VSSEG5E16_V <0b01, 0b1001>;
class ST_H_DESC_VSSEG5E16_V : ST_DESC_BASE_VSSEG5E16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSSEG5E16_V : ST_H_ENC_VSSEG5E16_V , ST_H_DESC_VSSEG5E16_V , VSSEG5E16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG6E16_V;
class MipsInst_VSSEG6E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG6E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG6E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG6E16_V : MipsInst_VSSEG6E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG6E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG6E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG6E16_V ;
class ST_DESC_BASE_VSSEG6E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg6e16.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSSEG6E16_V : MSA_MI10_FMT_VSSEG6E16_V <0b01, 0b1001>;
class ST_H_DESC_VSSEG6E16_V : ST_DESC_BASE_VSSEG6E16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSSEG6E16_V : ST_H_ENC_VSSEG6E16_V , ST_H_DESC_VSSEG6E16_V , VSSEG6E16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG7E16_V;
class MipsInst_VSSEG7E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG7E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG7E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG7E16_V : MipsInst_VSSEG7E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG7E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG7E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG7E16_V ;
class ST_DESC_BASE_VSSEG7E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg7e16.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSSEG7E16_V : MSA_MI10_FMT_VSSEG7E16_V <0b01, 0b1001>;
class ST_H_DESC_VSSEG7E16_V : ST_DESC_BASE_VSSEG7E16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSSEG7E16_V : ST_H_ENC_VSSEG7E16_V , ST_H_DESC_VSSEG7E16_V , VSSEG7E16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG8E16_V;
class MipsInst_VSSEG8E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG8E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG8E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG8E16_V : MipsInst_VSSEG8E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG8E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG8E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG8E16_V ;
class ST_DESC_BASE_VSSEG8E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg8e16.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSSEG8E16_V : MSA_MI10_FMT_VSSEG8E16_V <0b01, 0b1001>;
class ST_H_DESC_VSSEG8E16_V : ST_DESC_BASE_VSSEG8E16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSSEG8E16_V : ST_H_ENC_VSSEG8E16_V , ST_H_DESC_VSSEG8E16_V , VSSEG8E16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG2E16_V;
class MipsInst_VSSSEG2E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG2E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG2E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG2E16_V : MipsInst_VSSSEG2E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG2E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG2E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG2E16_V ;
class ST_DESC_BASE_VSSSEG2E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg2e16.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSSSEG2E16_V : MSA_MI10_FMT_VSSSEG2E16_V <0b01, 0b1001>;
class ST_H_DESC_VSSSEG2E16_V : ST_DESC_BASE_VSSSEG2E16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSSSEG2E16_V : ST_H_ENC_VSSSEG2E16_V , ST_H_DESC_VSSSEG2E16_V , VSSSEG2E16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG3E16_V;
class MipsInst_VSSSEG3E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG3E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG3E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG3E16_V : MipsInst_VSSSEG3E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG3E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG3E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG3E16_V ;
class ST_DESC_BASE_VSSSEG3E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg3e16.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSSSEG3E16_V : MSA_MI10_FMT_VSSSEG3E16_V <0b01, 0b1001>;
class ST_H_DESC_VSSSEG3E16_V : ST_DESC_BASE_VSSSEG3E16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSSSEG3E16_V : ST_H_ENC_VSSSEG3E16_V , ST_H_DESC_VSSSEG3E16_V , VSSSEG3E16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG4E16_V;
class MipsInst_VSSSEG4E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG4E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG4E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG4E16_V : MipsInst_VSSSEG4E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG4E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG4E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG4E16_V ;
class ST_DESC_BASE_VSSSEG4E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg4e16.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSSSEG4E16_V : MSA_MI10_FMT_VSSSEG4E16_V <0b01, 0b1001>;
class ST_H_DESC_VSSSEG4E16_V : ST_DESC_BASE_VSSSEG4E16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSSSEG4E16_V : ST_H_ENC_VSSSEG4E16_V , ST_H_DESC_VSSSEG4E16_V , VSSSEG4E16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG5E16_V;
class MipsInst_VSSSEG5E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG5E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG5E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG5E16_V : MipsInst_VSSSEG5E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG5E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG5E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG5E16_V ;
class ST_DESC_BASE_VSSSEG5E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg5e16.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSSSEG5E16_V : MSA_MI10_FMT_VSSSEG5E16_V <0b01, 0b1001>;
class ST_H_DESC_VSSSEG5E16_V : ST_DESC_BASE_VSSSEG5E16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSSSEG5E16_V : ST_H_ENC_VSSSEG5E16_V , ST_H_DESC_VSSSEG5E16_V , VSSSEG5E16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG6E16_V;
class MipsInst_VSSSEG6E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG6E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG6E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG6E16_V : MipsInst_VSSSEG6E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG6E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG6E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG6E16_V ;
class ST_DESC_BASE_VSSSEG6E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg6e16.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSSSEG6E16_V : MSA_MI10_FMT_VSSSEG6E16_V <0b01, 0b1001>;
class ST_H_DESC_VSSSEG6E16_V : ST_DESC_BASE_VSSSEG6E16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSSSEG6E16_V : ST_H_ENC_VSSSEG6E16_V , ST_H_DESC_VSSSEG6E16_V , VSSSEG6E16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG7E16_V;
class MipsInst_VSSSEG7E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG7E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG7E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG7E16_V : MipsInst_VSSSEG7E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG7E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG7E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG7E16_V ;
class ST_DESC_BASE_VSSSEG7E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg7e16.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSSSEG7E16_V : MSA_MI10_FMT_VSSSEG7E16_V <0b01, 0b1001>;
class ST_H_DESC_VSSSEG7E16_V : ST_DESC_BASE_VSSSEG7E16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSSSEG7E16_V : ST_H_ENC_VSSSEG7E16_V , ST_H_DESC_VSSSEG7E16_V , VSSSEG7E16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG8E16_V;
class MipsInst_VSSSEG8E16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG8E16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG8E16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG8E16_V : MipsInst_VSSSEG8E16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG8E16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG8E16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG8E16_V ;
class ST_DESC_BASE_VSSSEG8E16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg8e16.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSSSEG8E16_V : MSA_MI10_FMT_VSSSEG8E16_V <0b01, 0b1001>;
class ST_H_DESC_VSSSEG8E16_V : ST_DESC_BASE_VSSSEG8E16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSSSEG8E16_V : ST_H_ENC_VSSSEG8E16_V , ST_H_DESC_VSSSEG8E16_V , VSSSEG8E16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG2EI16_V;
class MipsInst_VSUXSEG2EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG2EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG2EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG2EI16_V : MipsInst_VSUXSEG2EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG2EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG2EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG2EI16_V ;
class ST_DESC_BASE_VSUXSEG2EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg2ei16.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSUXSEG2EI16_V : MSA_MI10_FMT_VSUXSEG2EI16_V <0b01, 0b1001>;
class ST_H_DESC_VSUXSEG2EI16_V : ST_DESC_BASE_VSUXSEG2EI16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSUXSEG2EI16_V : ST_H_ENC_VSUXSEG2EI16_V , ST_H_DESC_VSUXSEG2EI16_V , VSUXSEG2EI16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG3EI16_V;
class MipsInst_VSUXSEG3EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG3EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG3EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG3EI16_V : MipsInst_VSUXSEG3EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG3EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG3EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG3EI16_V ;
class ST_DESC_BASE_VSUXSEG3EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg3ei16.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSUXSEG3EI16_V : MSA_MI10_FMT_VSUXSEG3EI16_V <0b01, 0b1001>;
class ST_H_DESC_VSUXSEG3EI16_V : ST_DESC_BASE_VSUXSEG3EI16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSUXSEG3EI16_V : ST_H_ENC_VSUXSEG3EI16_V , ST_H_DESC_VSUXSEG3EI16_V , VSUXSEG3EI16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG4EI16_V;
class MipsInst_VSUXSEG4EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG4EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG4EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG4EI16_V : MipsInst_VSUXSEG4EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG4EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG4EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG4EI16_V ;
class ST_DESC_BASE_VSUXSEG4EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg4ei16.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSUXSEG4EI16_V : MSA_MI10_FMT_VSUXSEG4EI16_V <0b01, 0b1001>;
class ST_H_DESC_VSUXSEG4EI16_V : ST_DESC_BASE_VSUXSEG4EI16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSUXSEG4EI16_V : ST_H_ENC_VSUXSEG4EI16_V , ST_H_DESC_VSUXSEG4EI16_V , VSUXSEG4EI16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG5EI16_V;
class MipsInst_VSUXSEG5EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG5EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG5EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG5EI16_V : MipsInst_VSUXSEG5EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG5EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG5EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG5EI16_V ;
class ST_DESC_BASE_VSUXSEG5EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg5ei16.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSUXSEG5EI16_V : MSA_MI10_FMT_VSUXSEG5EI16_V <0b01, 0b1001>;
class ST_H_DESC_VSUXSEG5EI16_V : ST_DESC_BASE_VSUXSEG5EI16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSUXSEG5EI16_V : ST_H_ENC_VSUXSEG5EI16_V , ST_H_DESC_VSUXSEG5EI16_V , VSUXSEG5EI16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG6EI16_V;
class MipsInst_VSUXSEG6EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG6EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG6EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG6EI16_V : MipsInst_VSUXSEG6EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG6EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG6EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG6EI16_V ;
class ST_DESC_BASE_VSUXSEG6EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg6ei16.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSUXSEG6EI16_V : MSA_MI10_FMT_VSUXSEG6EI16_V <0b01, 0b1001>;
class ST_H_DESC_VSUXSEG6EI16_V : ST_DESC_BASE_VSUXSEG6EI16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSUXSEG6EI16_V : ST_H_ENC_VSUXSEG6EI16_V , ST_H_DESC_VSUXSEG6EI16_V , VSUXSEG6EI16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG7EI16_V;
class MipsInst_VSUXSEG7EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG7EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG7EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG7EI16_V : MipsInst_VSUXSEG7EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG7EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG7EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG7EI16_V ;
class ST_DESC_BASE_VSUXSEG7EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg7ei16.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSUXSEG7EI16_V : MSA_MI10_FMT_VSUXSEG7EI16_V <0b01, 0b1001>;
class ST_H_DESC_VSUXSEG7EI16_V : ST_DESC_BASE_VSUXSEG7EI16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSUXSEG7EI16_V : ST_H_ENC_VSUXSEG7EI16_V , ST_H_DESC_VSUXSEG7EI16_V , VSUXSEG7EI16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG8EI16_V;
class MipsInst_VSUXSEG8EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG8EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG8EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG8EI16_V : MipsInst_VSUXSEG8EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG8EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG8EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG8EI16_V ;
class ST_DESC_BASE_VSUXSEG8EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg8ei16.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSUXSEG8EI16_V : MSA_MI10_FMT_VSUXSEG8EI16_V <0b01, 0b1001>;
class ST_H_DESC_VSUXSEG8EI16_V : ST_DESC_BASE_VSUXSEG8EI16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSUXSEG8EI16_V : ST_H_ENC_VSUXSEG8EI16_V , ST_H_DESC_VSUXSEG8EI16_V , VSUXSEG8EI16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG2EI16_V;
class MipsInst_VSOXSEG2EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG2EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG2EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG2EI16_V : MipsInst_VSOXSEG2EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG2EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG2EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG2EI16_V ;
class ST_DESC_BASE_VSOXSEG2EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg2ei16.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSOXSEG2EI16_V : MSA_MI10_FMT_VSOXSEG2EI16_V <0b01, 0b1001>;
class ST_H_DESC_VSOXSEG2EI16_V : ST_DESC_BASE_VSOXSEG2EI16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSOXSEG2EI16_V : ST_H_ENC_VSOXSEG2EI16_V , ST_H_DESC_VSOXSEG2EI16_V , VSOXSEG2EI16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG3EI16_V;
class MipsInst_VSOXSEG3EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG3EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG3EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG3EI16_V : MipsInst_VSOXSEG3EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG3EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG3EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG3EI16_V ;
class ST_DESC_BASE_VSOXSEG3EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg3ei16.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSOXSEG3EI16_V : MSA_MI10_FMT_VSOXSEG3EI16_V <0b01, 0b1001>;
class ST_H_DESC_VSOXSEG3EI16_V : ST_DESC_BASE_VSOXSEG3EI16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSOXSEG3EI16_V : ST_H_ENC_VSOXSEG3EI16_V , ST_H_DESC_VSOXSEG3EI16_V , VSOXSEG3EI16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG4EI16_V;
class MipsInst_VSOXSEG4EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG4EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG4EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG4EI16_V : MipsInst_VSOXSEG4EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG4EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG4EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG4EI16_V ;
class ST_DESC_BASE_VSOXSEG4EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg4ei16.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSOXSEG4EI16_V : MSA_MI10_FMT_VSOXSEG4EI16_V <0b01, 0b1001>;
class ST_H_DESC_VSOXSEG4EI16_V : ST_DESC_BASE_VSOXSEG4EI16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSOXSEG4EI16_V : ST_H_ENC_VSOXSEG4EI16_V , ST_H_DESC_VSOXSEG4EI16_V , VSOXSEG4EI16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG5EI16_V;
class MipsInst_VSOXSEG5EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG5EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG5EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG5EI16_V : MipsInst_VSOXSEG5EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG5EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG5EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG5EI16_V ;
class ST_DESC_BASE_VSOXSEG5EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg5ei16.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSOXSEG5EI16_V : MSA_MI10_FMT_VSOXSEG5EI16_V <0b01, 0b1001>;
class ST_H_DESC_VSOXSEG5EI16_V : ST_DESC_BASE_VSOXSEG5EI16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSOXSEG5EI16_V : ST_H_ENC_VSOXSEG5EI16_V , ST_H_DESC_VSOXSEG5EI16_V , VSOXSEG5EI16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG6EI16_V;
class MipsInst_VSOXSEG6EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG6EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG6EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG6EI16_V : MipsInst_VSOXSEG6EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG6EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG6EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG6EI16_V ;
class ST_DESC_BASE_VSOXSEG6EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg6ei16.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSOXSEG6EI16_V : MSA_MI10_FMT_VSOXSEG6EI16_V <0b01, 0b1001>;
class ST_H_DESC_VSOXSEG6EI16_V : ST_DESC_BASE_VSOXSEG6EI16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSOXSEG6EI16_V : ST_H_ENC_VSOXSEG6EI16_V , ST_H_DESC_VSOXSEG6EI16_V , VSOXSEG6EI16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG7EI16_V;
class MipsInst_VSOXSEG7EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG7EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG7EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG7EI16_V : MipsInst_VSOXSEG7EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG7EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG7EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG7EI16_V ;
class ST_DESC_BASE_VSOXSEG7EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg7ei16.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSOXSEG7EI16_V : MSA_MI10_FMT_VSOXSEG7EI16_V <0b01, 0b1001>;
class ST_H_DESC_VSOXSEG7EI16_V : ST_DESC_BASE_VSOXSEG7EI16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSOXSEG7EI16_V : ST_H_ENC_VSOXSEG7EI16_V , ST_H_DESC_VSOXSEG7EI16_V , VSOXSEG7EI16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG8EI16_V;
class MipsInst_VSOXSEG8EI16_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG8EI16_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG8EI16_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG8EI16_V : MipsInst_VSOXSEG8EI16_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG8EI16_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG8EI16_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG8EI16_V ;
class ST_DESC_BASE_VSOXSEG8EI16_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg8ei16.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VSOXSEG8EI16_V : MSA_MI10_FMT_VSOXSEG8EI16_V <0b01, 0b1001>;
class ST_H_DESC_VSOXSEG8EI16_V : ST_DESC_BASE_VSOXSEG8EI16_V <"st.h", null_frag, ?, ?, ?, addr>;
def VSOXSEG8EI16_V : ST_H_ENC_VSOXSEG8EI16_V , ST_H_DESC_VSOXSEG8EI16_V , VSOXSEG8EI16_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VS2R_V;
class MipsInst_VS2R_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VS2R_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VS2R_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VS2R_V : MipsInst_VS2R_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VS2R_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VS2R_V<bits<2>  df, bits<4>  minor> : MSAInst_VS2R_V ;
class ST_DESC_BASE_VS2R_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1);
	string  AsmString="vs2r.v	$vs3, (${rs1})";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_H_ENC_VS2R_V : MSA_MI10_FMT_VS2R_V <0b01, 0b1001>;
class ST_H_DESC_VS2R_V : ST_DESC_BASE_VS2R_V <"st.h", null_frag, ?, ?, ?, addr>;
def VS2R_V : ST_H_ENC_VS2R_V , ST_H_DESC_VS2R_V , VS2R_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSE32_V;
class MipsInst_VSE32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSE32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSE32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSE32_V : MipsInst_VSE32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSE32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSE32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSE32_V ;
class ST_DESC_BASE_VSE32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vse32.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSE32_V : MSA_MI10_FMT_VSE32_V <0b10, 0b1001>;
class ST_W_DESC_VSE32_V : ST_DESC_BASE_VSE32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSE32_V : ST_W_ENC_VSE32_V , ST_W_DESC_VSE32_V , VSE32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSSE32_V;
class MipsInst_VSSE32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSE32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSE32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSE32_V : MipsInst_VSSE32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSE32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSE32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSE32_V ;
class ST_DESC_BASE_VSSE32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vsse32.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSSE32_V : MSA_MI10_FMT_VSSE32_V <0b10, 0b1001>;
class ST_W_DESC_VSSE32_V : ST_DESC_BASE_VSSE32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSSE32_V : ST_W_ENC_VSSE32_V , ST_W_DESC_VSSE32_V , VSSE32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSUXEI32_V;
class MipsInst_VSUXEI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXEI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXEI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXEI32_V : MipsInst_VSUXEI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXEI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXEI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXEI32_V ;
class ST_DESC_BASE_VSUXEI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxei32.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSUXEI32_V : MSA_MI10_FMT_VSUXEI32_V <0b10, 0b1001>;
class ST_W_DESC_VSUXEI32_V : ST_DESC_BASE_VSUXEI32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSUXEI32_V : ST_W_ENC_VSUXEI32_V , ST_W_DESC_VSUXEI32_V , VSUXEI32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSOXEI32_V;
class MipsInst_VSOXEI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXEI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXEI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXEI32_V : MipsInst_VSOXEI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXEI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXEI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXEI32_V ;
class ST_DESC_BASE_VSOXEI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxei32.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSOXEI32_V : MSA_MI10_FMT_VSOXEI32_V <0b10, 0b1001>;
class ST_W_DESC_VSOXEI32_V : ST_DESC_BASE_VSOXEI32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSOXEI32_V : ST_W_ENC_VSOXEI32_V , ST_W_DESC_VSOXEI32_V , VSOXEI32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSSEG2E32_V;
class MipsInst_VSSEG2E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG2E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG2E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG2E32_V : MipsInst_VSSEG2E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG2E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG2E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG2E32_V ;
class ST_DESC_BASE_VSSEG2E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg2e32.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSSEG2E32_V : MSA_MI10_FMT_VSSEG2E32_V <0b10, 0b1001>;
class ST_W_DESC_VSSEG2E32_V : ST_DESC_BASE_VSSEG2E32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSSEG2E32_V : ST_W_ENC_VSSEG2E32_V , ST_W_DESC_VSSEG2E32_V , VSSEG2E32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG3E32_V;
class MipsInst_VSSEG3E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG3E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG3E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG3E32_V : MipsInst_VSSEG3E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG3E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG3E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG3E32_V ;
class ST_DESC_BASE_VSSEG3E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg3e32.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSSEG3E32_V : MSA_MI10_FMT_VSSEG3E32_V <0b10, 0b1001>;
class ST_W_DESC_VSSEG3E32_V : ST_DESC_BASE_VSSEG3E32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSSEG3E32_V : ST_W_ENC_VSSEG3E32_V , ST_W_DESC_VSSEG3E32_V , VSSEG3E32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG4E32_V;
class MipsInst_VSSEG4E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG4E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG4E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG4E32_V : MipsInst_VSSEG4E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG4E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG4E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG4E32_V ;
class ST_DESC_BASE_VSSEG4E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg4e32.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSSEG4E32_V : MSA_MI10_FMT_VSSEG4E32_V <0b10, 0b1001>;
class ST_W_DESC_VSSEG4E32_V : ST_DESC_BASE_VSSEG4E32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSSEG4E32_V : ST_W_ENC_VSSEG4E32_V , ST_W_DESC_VSSEG4E32_V , VSSEG4E32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG5E32_V;
class MipsInst_VSSEG5E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG5E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG5E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG5E32_V : MipsInst_VSSEG5E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG5E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG5E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG5E32_V ;
class ST_DESC_BASE_VSSEG5E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg5e32.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSSEG5E32_V : MSA_MI10_FMT_VSSEG5E32_V <0b10, 0b1001>;
class ST_W_DESC_VSSEG5E32_V : ST_DESC_BASE_VSSEG5E32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSSEG5E32_V : ST_W_ENC_VSSEG5E32_V , ST_W_DESC_VSSEG5E32_V , VSSEG5E32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG6E32_V;
class MipsInst_VSSEG6E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG6E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG6E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG6E32_V : MipsInst_VSSEG6E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG6E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG6E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG6E32_V ;
class ST_DESC_BASE_VSSEG6E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg6e32.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSSEG6E32_V : MSA_MI10_FMT_VSSEG6E32_V <0b10, 0b1001>;
class ST_W_DESC_VSSEG6E32_V : ST_DESC_BASE_VSSEG6E32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSSEG6E32_V : ST_W_ENC_VSSEG6E32_V , ST_W_DESC_VSSEG6E32_V , VSSEG6E32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG7E32_V;
class MipsInst_VSSEG7E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG7E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG7E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG7E32_V : MipsInst_VSSEG7E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG7E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG7E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG7E32_V ;
class ST_DESC_BASE_VSSEG7E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg7e32.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSSEG7E32_V : MSA_MI10_FMT_VSSEG7E32_V <0b10, 0b1001>;
class ST_W_DESC_VSSEG7E32_V : ST_DESC_BASE_VSSEG7E32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSSEG7E32_V : ST_W_ENC_VSSEG7E32_V , ST_W_DESC_VSSEG7E32_V , VSSEG7E32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSEG8E32_V;
class MipsInst_VSSEG8E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSEG8E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSEG8E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSEG8E32_V : MipsInst_VSSEG8E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSEG8E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSEG8E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSEG8E32_V ;
class ST_DESC_BASE_VSSEG8E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsseg8e32.v	$vs3, (${rs1})$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSSEG8E32_V : MSA_MI10_FMT_VSSEG8E32_V <0b10, 0b1001>;
class ST_W_DESC_VSSEG8E32_V : ST_DESC_BASE_VSSEG8E32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSSEG8E32_V : ST_W_ENC_VSSEG8E32_V , ST_W_DESC_VSSEG8E32_V , VSSEG8E32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG2E32_V;
class MipsInst_VSSSEG2E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG2E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG2E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG2E32_V : MipsInst_VSSSEG2E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG2E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG2E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG2E32_V ;
class ST_DESC_BASE_VSSSEG2E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg2e32.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSSSEG2E32_V : MSA_MI10_FMT_VSSSEG2E32_V <0b10, 0b1001>;
class ST_W_DESC_VSSSEG2E32_V : ST_DESC_BASE_VSSSEG2E32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSSSEG2E32_V : ST_W_ENC_VSSSEG2E32_V , ST_W_DESC_VSSSEG2E32_V , VSSSEG2E32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG3E32_V;
class MipsInst_VSSSEG3E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG3E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG3E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG3E32_V : MipsInst_VSSSEG3E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG3E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG3E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG3E32_V ;
class ST_DESC_BASE_VSSSEG3E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg3e32.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSSSEG3E32_V : MSA_MI10_FMT_VSSSEG3E32_V <0b10, 0b1001>;
class ST_W_DESC_VSSSEG3E32_V : ST_DESC_BASE_VSSSEG3E32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSSSEG3E32_V : ST_W_ENC_VSSSEG3E32_V , ST_W_DESC_VSSSEG3E32_V , VSSSEG3E32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG4E32_V;
class MipsInst_VSSSEG4E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG4E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG4E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG4E32_V : MipsInst_VSSSEG4E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG4E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG4E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG4E32_V ;
class ST_DESC_BASE_VSSSEG4E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg4e32.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSSSEG4E32_V : MSA_MI10_FMT_VSSSEG4E32_V <0b10, 0b1001>;
class ST_W_DESC_VSSSEG4E32_V : ST_DESC_BASE_VSSSEG4E32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSSSEG4E32_V : ST_W_ENC_VSSSEG4E32_V , ST_W_DESC_VSSSEG4E32_V , VSSSEG4E32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG5E32_V;
class MipsInst_VSSSEG5E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG5E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG5E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG5E32_V : MipsInst_VSSSEG5E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG5E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG5E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG5E32_V ;
class ST_DESC_BASE_VSSSEG5E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg5e32.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSSSEG5E32_V : MSA_MI10_FMT_VSSSEG5E32_V <0b10, 0b1001>;
class ST_W_DESC_VSSSEG5E32_V : ST_DESC_BASE_VSSSEG5E32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSSSEG5E32_V : ST_W_ENC_VSSSEG5E32_V , ST_W_DESC_VSSSEG5E32_V , VSSSEG5E32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG6E32_V;
class MipsInst_VSSSEG6E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG6E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG6E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG6E32_V : MipsInst_VSSSEG6E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG6E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG6E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG6E32_V ;
class ST_DESC_BASE_VSSSEG6E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg6e32.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSSSEG6E32_V : MSA_MI10_FMT_VSSSEG6E32_V <0b10, 0b1001>;
class ST_W_DESC_VSSSEG6E32_V : ST_DESC_BASE_VSSSEG6E32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSSSEG6E32_V : ST_W_ENC_VSSSEG6E32_V , ST_W_DESC_VSSSEG6E32_V , VSSSEG6E32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG7E32_V;
class MipsInst_VSSSEG7E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG7E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG7E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG7E32_V : MipsInst_VSSSEG7E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG7E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG7E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG7E32_V ;
class ST_DESC_BASE_VSSSEG7E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg7e32.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSSSEG7E32_V : MSA_MI10_FMT_VSSSEG7E32_V <0b10, 0b1001>;
class ST_W_DESC_VSSSEG7E32_V : ST_DESC_BASE_VSSSEG7E32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSSSEG7E32_V : ST_W_ENC_VSSSEG7E32_V , ST_W_DESC_VSSSEG7E32_V , VSSSEG7E32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSSSEG8E32_V;
class MipsInst_VSSSEG8E32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSSEG8E32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSSEG8E32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSSEG8E32_V : MipsInst_VSSSEG8E32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSSEG8E32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSSSEG8E32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSSSEG8E32_V ;
class ST_DESC_BASE_VSSSEG8E32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, GPR:$rs2, VMaskOp:$vm);
	string  AsmString="vssseg8e32.v	$vs3, (${rs1}), $rs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSSSEG8E32_V : MSA_MI10_FMT_VSSSEG8E32_V <0b10, 0b1001>;
class ST_W_DESC_VSSSEG8E32_V : ST_DESC_BASE_VSSSEG8E32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSSSEG8E32_V : ST_W_ENC_VSSSEG8E32_V , ST_W_DESC_VSSSEG8E32_V , VSSSEG8E32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG2EI32_V;
class MipsInst_VSUXSEG2EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG2EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG2EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG2EI32_V : MipsInst_VSUXSEG2EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG2EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG2EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG2EI32_V ;
class ST_DESC_BASE_VSUXSEG2EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg2ei32.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSUXSEG2EI32_V : MSA_MI10_FMT_VSUXSEG2EI32_V <0b10, 0b1001>;
class ST_W_DESC_VSUXSEG2EI32_V : ST_DESC_BASE_VSUXSEG2EI32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSUXSEG2EI32_V : ST_W_ENC_VSUXSEG2EI32_V , ST_W_DESC_VSUXSEG2EI32_V , VSUXSEG2EI32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG3EI32_V;
class MipsInst_VSUXSEG3EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG3EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG3EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG3EI32_V : MipsInst_VSUXSEG3EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG3EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG3EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG3EI32_V ;
class ST_DESC_BASE_VSUXSEG3EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg3ei32.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSUXSEG3EI32_V : MSA_MI10_FMT_VSUXSEG3EI32_V <0b10, 0b1001>;
class ST_W_DESC_VSUXSEG3EI32_V : ST_DESC_BASE_VSUXSEG3EI32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSUXSEG3EI32_V : ST_W_ENC_VSUXSEG3EI32_V , ST_W_DESC_VSUXSEG3EI32_V , VSUXSEG3EI32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG4EI32_V;
class MipsInst_VSUXSEG4EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG4EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG4EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG4EI32_V : MipsInst_VSUXSEG4EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG4EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG4EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG4EI32_V ;
class ST_DESC_BASE_VSUXSEG4EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg4ei32.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSUXSEG4EI32_V : MSA_MI10_FMT_VSUXSEG4EI32_V <0b10, 0b1001>;
class ST_W_DESC_VSUXSEG4EI32_V : ST_DESC_BASE_VSUXSEG4EI32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSUXSEG4EI32_V : ST_W_ENC_VSUXSEG4EI32_V , ST_W_DESC_VSUXSEG4EI32_V , VSUXSEG4EI32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG5EI32_V;
class MipsInst_VSUXSEG5EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG5EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG5EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG5EI32_V : MipsInst_VSUXSEG5EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG5EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG5EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG5EI32_V ;
class ST_DESC_BASE_VSUXSEG5EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg5ei32.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSUXSEG5EI32_V : MSA_MI10_FMT_VSUXSEG5EI32_V <0b10, 0b1001>;
class ST_W_DESC_VSUXSEG5EI32_V : ST_DESC_BASE_VSUXSEG5EI32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSUXSEG5EI32_V : ST_W_ENC_VSUXSEG5EI32_V , ST_W_DESC_VSUXSEG5EI32_V , VSUXSEG5EI32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG6EI32_V;
class MipsInst_VSUXSEG6EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG6EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG6EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG6EI32_V : MipsInst_VSUXSEG6EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG6EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG6EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG6EI32_V ;
class ST_DESC_BASE_VSUXSEG6EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg6ei32.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSUXSEG6EI32_V : MSA_MI10_FMT_VSUXSEG6EI32_V <0b10, 0b1001>;
class ST_W_DESC_VSUXSEG6EI32_V : ST_DESC_BASE_VSUXSEG6EI32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSUXSEG6EI32_V : ST_W_ENC_VSUXSEG6EI32_V , ST_W_DESC_VSUXSEG6EI32_V , VSUXSEG6EI32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG7EI32_V;
class MipsInst_VSUXSEG7EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG7EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG7EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG7EI32_V : MipsInst_VSUXSEG7EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG7EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG7EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG7EI32_V ;
class ST_DESC_BASE_VSUXSEG7EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg7ei32.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSUXSEG7EI32_V : MSA_MI10_FMT_VSUXSEG7EI32_V <0b10, 0b1001>;
class ST_W_DESC_VSUXSEG7EI32_V : ST_DESC_BASE_VSUXSEG7EI32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSUXSEG7EI32_V : ST_W_ENC_VSUXSEG7EI32_V , ST_W_DESC_VSUXSEG7EI32_V , VSUXSEG7EI32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSUXSEG8EI32_V;
class MipsInst_VSUXSEG8EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUXSEG8EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUXSEG8EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUXSEG8EI32_V : MipsInst_VSUXSEG8EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUXSEG8EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSUXSEG8EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSUXSEG8EI32_V ;
class ST_DESC_BASE_VSUXSEG8EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsuxseg8ei32.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSUXSEG8EI32_V : MSA_MI10_FMT_VSUXSEG8EI32_V <0b10, 0b1001>;
class ST_W_DESC_VSUXSEG8EI32_V : ST_DESC_BASE_VSUXSEG8EI32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSUXSEG8EI32_V : ST_W_ENC_VSUXSEG8EI32_V , ST_W_DESC_VSUXSEG8EI32_V , VSUXSEG8EI32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG2EI32_V;
class MipsInst_VSOXSEG2EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG2EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG2EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG2EI32_V : MipsInst_VSOXSEG2EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG2EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG2EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG2EI32_V ;
class ST_DESC_BASE_VSOXSEG2EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg2ei32.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSOXSEG2EI32_V : MSA_MI10_FMT_VSOXSEG2EI32_V <0b10, 0b1001>;
class ST_W_DESC_VSOXSEG2EI32_V : ST_DESC_BASE_VSOXSEG2EI32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSOXSEG2EI32_V : ST_W_ENC_VSOXSEG2EI32_V , ST_W_DESC_VSOXSEG2EI32_V , VSOXSEG2EI32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG3EI32_V;
class MipsInst_VSOXSEG3EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG3EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG3EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG3EI32_V : MipsInst_VSOXSEG3EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG3EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG3EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG3EI32_V ;
class ST_DESC_BASE_VSOXSEG3EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg3ei32.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSOXSEG3EI32_V : MSA_MI10_FMT_VSOXSEG3EI32_V <0b10, 0b1001>;
class ST_W_DESC_VSOXSEG3EI32_V : ST_DESC_BASE_VSOXSEG3EI32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSOXSEG3EI32_V : ST_W_ENC_VSOXSEG3EI32_V , ST_W_DESC_VSOXSEG3EI32_V , VSOXSEG3EI32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG4EI32_V;
class MipsInst_VSOXSEG4EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG4EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG4EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG4EI32_V : MipsInst_VSOXSEG4EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG4EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG4EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG4EI32_V ;
class ST_DESC_BASE_VSOXSEG4EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg4ei32.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSOXSEG4EI32_V : MSA_MI10_FMT_VSOXSEG4EI32_V <0b10, 0b1001>;
class ST_W_DESC_VSOXSEG4EI32_V : ST_DESC_BASE_VSOXSEG4EI32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSOXSEG4EI32_V : ST_W_ENC_VSOXSEG4EI32_V , ST_W_DESC_VSOXSEG4EI32_V , VSOXSEG4EI32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG5EI32_V;
class MipsInst_VSOXSEG5EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG5EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG5EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG5EI32_V : MipsInst_VSOXSEG5EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG5EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG5EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG5EI32_V ;
class ST_DESC_BASE_VSOXSEG5EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg5ei32.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSOXSEG5EI32_V : MSA_MI10_FMT_VSOXSEG5EI32_V <0b10, 0b1001>;
class ST_W_DESC_VSOXSEG5EI32_V : ST_DESC_BASE_VSOXSEG5EI32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSOXSEG5EI32_V : ST_W_ENC_VSOXSEG5EI32_V , ST_W_DESC_VSOXSEG5EI32_V , VSOXSEG5EI32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG6EI32_V;
class MipsInst_VSOXSEG6EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG6EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG6EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG6EI32_V : MipsInst_VSOXSEG6EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG6EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG6EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG6EI32_V ;
class ST_DESC_BASE_VSOXSEG6EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg6ei32.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSOXSEG6EI32_V : MSA_MI10_FMT_VSOXSEG6EI32_V <0b10, 0b1001>;
class ST_W_DESC_VSOXSEG6EI32_V : ST_DESC_BASE_VSOXSEG6EI32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSOXSEG6EI32_V : ST_W_ENC_VSOXSEG6EI32_V , ST_W_DESC_VSOXSEG6EI32_V , VSOXSEG6EI32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG7EI32_V;
class MipsInst_VSOXSEG7EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG7EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG7EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG7EI32_V : MipsInst_VSOXSEG7EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG7EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG7EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG7EI32_V ;
class ST_DESC_BASE_VSOXSEG7EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg7ei32.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSOXSEG7EI32_V : MSA_MI10_FMT_VSOXSEG7EI32_V <0b10, 0b1001>;
class ST_W_DESC_VSOXSEG7EI32_V : ST_DESC_BASE_VSOXSEG7EI32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSOXSEG7EI32_V : ST_W_ENC_VSOXSEG7EI32_V , ST_W_DESC_VSOXSEG7EI32_V , VSOXSEG7EI32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VSOXSEG8EI32_V;
class MipsInst_VSOXSEG8EI32_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSOXSEG8EI32_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSOXSEG8EI32_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSOXSEG8EI32_V : MipsInst_VSOXSEG8EI32_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSOXSEG8EI32_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VSOXSEG8EI32_V<bits<2>  df, bits<4>  minor> : MSAInst_VSOXSEG8EI32_V ;
class ST_DESC_BASE_VSOXSEG8EI32_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1, VR:$vs2, VMaskOp:$vm);
	string  AsmString="vsoxseg8ei32.v	$vs3, (${rs1}), $vs2$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VSOXSEG8EI32_V : MSA_MI10_FMT_VSOXSEG8EI32_V <0b10, 0b1001>;
class ST_W_DESC_VSOXSEG8EI32_V : ST_DESC_BASE_VSOXSEG8EI32_V <"st.w", null_frag, ?, ?, ?, addr>;
def VSOXSEG8EI32_V : ST_W_ENC_VSOXSEG8EI32_V , ST_W_DESC_VSOXSEG8EI32_V , VSOXSEG8EI32_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtZvlsseg];
}
class PredicateControl_VS4R_V;
class MipsInst_VS4R_V<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VS4R_V {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VS4R_V{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VS4R_V : MipsInst_VS4R_V <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VS4R_V {
	let  EncodingPredicates=[];
}
class MSA_MI10_FMT_VS4R_V<bits<2>  df, bits<4>  minor> : MSAInst_VS4R_V ;
class ST_DESC_BASE_VS4R_V<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs);
	dag  InOperandList=(ins VR:$vs3, GPR:$rs1);
	string  AsmString="vs4r.v	$vs3, (${rs1})";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class ST_W_ENC_VS4R_V : MSA_MI10_FMT_VS4R_V <0b10, 0b1001>;
class ST_W_DESC_VS4R_V : ST_DESC_BASE_VS4R_V <"st.w", null_frag, ?, ?, ?, addr>;
def VS4R_V : ST_W_ENC_VS4R_V , ST_W_DESC_VS4R_V , VS4R_V_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 1;
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSSUBU_VV;
class MipsInst_VSSUBU_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSUBU_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSUBU_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSUBU_VV : MipsInst_VSSUBU_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSUBU_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VSSUBU_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vssubu.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VSSUBU_VV{
	bit  isCommutable=false;
}
class MSA_3R_FMT_VSSUBU_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSSUBU_VV ;
class AVER_S_W_DESC_VSSUBU_VV : MSA_3R_DESC_BASE_VSSUBU_VV <"aver_s.w", null_frag, ?>, IsCommutable_VSSUBU_VV ;
class AVER_S_W_ENC_VSSUBU_VV : MSA_3R_FMT_VSSUBU_VV <0b110, 0b10, 0b010000>;
def VSSUBU_VV : AVER_S_W_ENC_VSSUBU_VV , AVER_S_W_DESC_VSSUBU_VV , VSSUBU_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSSUBU_VX;
class MipsInst_VSSUBU_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSUBU_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSUBU_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSUBU_VX : MipsInst_VSSUBU_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSUBU_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VSSUBU_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSSUBU_VX ;
class MSA_3R_DESC_BASE_VSSUBU_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vssubu.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VSSUBU_VX{
	bit  isCommutable=false;
}
class AVE_S_W_ENC_VSSUBU_VX : MSA_3R_FMT_VSSUBU_VX <0b100, 0b10, 0b010000>;
class AVE_S_W_DESC_VSSUBU_VX : MSA_3R_DESC_BASE_VSSUBU_VX <"ave_s.w", null_frag, ?>, IsCommutable_VSSUBU_VX ;
def VSSUBU_VX : AVE_S_W_ENC_VSSUBU_VX , AVE_S_W_DESC_VSSUBU_VX , VSSUBU_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSUB_VV;
class MipsInst_VSUB_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUB_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUB_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUB_VV : MipsInst_VSUB_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUB_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VSUB_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSUB_VV ;
class MSA_3R_DESC_BASE_VSUB_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vsub.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VSUB_VV{
	bit  isCommutable=false;
}
class AVE_S_W_ENC_VSUB_VV : MSA_3R_FMT_VSUB_VV <0b100, 0b10, 0b010000>;
class AVE_S_W_DESC_VSUB_VV : MSA_3R_DESC_BASE_VSUB_VV <"ave_s.w", null_frag, ?>, IsCommutable_VSUB_VV ;
def VSUB_VV : AVE_S_W_ENC_VSUB_VV , AVE_S_W_DESC_VSUB_VV , VSUB_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWSUB_WV;
class MipsInst_VWSUB_WV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWSUB_WV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWSUB_WV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWSUB_WV : MipsInst_VWSUB_WV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWSUB_WV {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VWSUB_WV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vwsub.wv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VWSUB_WV{
	bit  isCommutable=false;
}
class MSA_3R_FMT_VWSUB_WV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWSUB_WV ;
class AVE_S_D_DESC_VWSUB_WV : MSA_3R_DESC_BASE_VWSUB_WV <"ave_s.d", null_frag, ?>, IsCommutable_VWSUB_WV ;
class AVE_S_D_ENC_VWSUB_WV : MSA_3R_FMT_VWSUB_WV <0b100, 0b11, 0b010000>;
def VWSUB_WV : AVE_S_D_ENC_VWSUB_WV , AVE_S_D_DESC_VWSUB_WV , VWSUB_WV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWSUB_WX;
class MipsInst_VWSUB_WX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWSUB_WX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWSUB_WX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWSUB_WX : MipsInst_VWSUB_WX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWSUB_WX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VWSUB_WX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWSUB_WX ;
class MSA_3R_DESC_BASE_VWSUB_WX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vwsub.wx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VWSUB_WX{
	bit  isCommutable=false;
}
class AVER_S_D_ENC_VWSUB_WX : MSA_3R_FMT_VWSUB_WX <0b110, 0b11, 0b010000>;
class AVER_S_D_DESC_VWSUB_WX : MSA_3R_DESC_BASE_VWSUB_WX <"aver_s.d", null_frag, ?>, IsCommutable_VWSUB_WX ;
def VWSUB_WX : AVER_S_D_ENC_VWSUB_WX , AVER_S_D_DESC_VWSUB_WX , VWSUB_WX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWSUB_VV;
class MipsInst_VWSUB_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWSUB_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWSUB_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWSUB_VV : MipsInst_VWSUB_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWSUB_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VWSUB_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWSUB_VV ;
class MSA_3R_4R_DESC_BASE_VWSUB_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vwsub.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="@earlyclobber $vd";
}
class DPSUB_U_D_ENC_VWSUB_VV : MSA_3R_FMT_VWSUB_VV <0b101, 0b11, 0b010011>;
class DPSUB_U_D_DESC_VWSUB_VV : MSA_3R_4R_DESC_BASE_VWSUB_VV <"dpsub_u.d", null_frag, ?, ?, ?>;
def VWSUB_VV : DPSUB_U_D_ENC_VWSUB_VV , DPSUB_U_D_DESC_VWSUB_VV , VWSUB_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSUB_VX;
class MipsInst_VSUB_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSUB_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSUB_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSUB_VX : MipsInst_VSUB_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSUB_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VSUB_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSUB_VX ;
class MSA_3R_DESC_BASE_VSUB_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vsub.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VSUB_VX{
	bit  isCommutable=false;
}
class ADDV_W_ENC_VSUB_VX : MSA_3R_FMT_VSUB_VX <0b000, 0b10, 0b001110>;
class ADDV_W_DESC_VSUB_VX : MSA_3R_DESC_BASE_VSUB_VX <"addv.w", null_frag, ?>, IsCommutable_VSUB_VX ;
def VSUB_VX : ADDV_W_ENC_VSUB_VX , ADDV_W_DESC_VSUB_VX , VSUB_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWSUB_VX;
class MipsInst_VWSUB_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWSUB_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWSUB_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWSUB_VX : MipsInst_VWSUB_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWSUB_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VWSUB_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VWSUB_VX ;
class MSA_3R_DESC_BASE_VWSUB_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vwsub.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VWSUB_VX{
	bit  isCommutable=false;
}
class ADDS_U_D_ENC_VWSUB_VX : MSA_3R_FMT_VWSUB_VX <0b011, 0b11, 0b010000>;
class ADDS_U_D_DESC_VWSUB_VX : MSA_3R_DESC_BASE_VWSUB_VX <"adds_u.d", null_frag, ?>, IsCommutable_VWSUB_VX ;
def VWSUB_VX : ADDS_U_D_ENC_VWSUB_VX , ADDS_U_D_DESC_VWSUB_VX , VWSUB_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSSUB_VV;
class MipsInst_VSSUB_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSUB_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSUB_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSUB_VV : MipsInst_VSSUB_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSUB_VV {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VSSUB_VV<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSSUB_VV ;
class MSA_3R_DESC_BASE_VSSUB_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vssub.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class HADD_U_W_ENC_VSSUB_VV : MSA_3R_FMT_VSSUB_VV <0b101, 0b10, 0b010101>;
class HADD_U_W_DESC_VSSUB_VV : MSA_3R_DESC_BASE_VSSUB_VV <"hadd_u.w", null_frag, ?, ?, ?>;
def VSSUB_VV : HADD_U_W_ENC_VSSUB_VV , HADD_U_W_DESC_VSSUB_VV , VSSUB_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VSSUB_VX;
class MipsInst_VSSUB_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VSSUB_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VSSUB_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VSSUB_VX : MipsInst_VSSUB_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VSSUB_VX {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VSSUB_VX<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VSSUB_VX ;
class MSA_3R_DESC_BASE_VSSUB_VX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vssub.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VSSUB_VX{
	bit  isCommutable=false;
}
class ADDS_S_W_ENC_VSSUB_VX : MSA_3R_FMT_VSSUB_VX <0b010, 0b10, 0b010000>;
class ADDS_S_W_DESC_VSSUB_VX : MSA_3R_DESC_BASE_VSSUB_VX <"adds_s.w", null_frag, ?>, IsCommutable_VSSUB_VX ;
def VSSUB_VX : ADDS_S_W_ENC_VSSUB_VX , ADDS_S_W_DESC_VSSUB_VX , VSSUB_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VRSUB_VI;
class MipsInst_VRSUB_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VRSUB_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VRSUB_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VRSUB_VI : MipsInst_VRSUB_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VRSUB_VI {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VRSUB_VI<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VRSUB_VI ;
class MSA_3R_DESC_BASE_VRSUB_VI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, simm5:$imm, VMaskOp:$vm);
	string  AsmString="vrsub.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VRSUB_VI{
	bit  isCommutable=false;
}
class ADDS_U_W_ENC_VRSUB_VI : MSA_3R_FMT_VRSUB_VI <0b011, 0b10, 0b010000>;
class ADDS_U_W_DESC_VRSUB_VI : MSA_3R_DESC_BASE_VRSUB_VI <"adds_u.w", null_frag, ?>, IsCommutable_VRSUB_VI ;
def VRSUB_VI : ADDS_U_W_ENC_VRSUB_VI , ADDS_U_W_DESC_VRSUB_VI , VRSUB_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VXOR_VV;
class MipsInst_VXOR_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VXOR_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VXOR_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VXOR_VV : MipsInst_VXOR_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VXOR_VV {
	let  EncodingPredicates=[];
}
class MSA_VEC_DESC_BASE_VXOR_VV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vxor.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_VEC_FMT_VXOR_VV<bits<5>  major, bits<6>  minor> : MSAInst_VXOR_VV ;
class XOR_V_DESC_VXOR_VV : MSA_VEC_DESC_BASE_VXOR_VV <"xor.v", null_frag, ?>;
class XOR_V_ENC_VXOR_VV : MSA_VEC_FMT_VXOR_VV <0b00011, 0b011110>;
def VXOR_VV : XOR_V_ENC_VXOR_VV , XOR_V_DESC_VXOR_VV , VXOR_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VXOR_VX;
class MipsInst_VXOR_VX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VXOR_VX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VXOR_VX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VXOR_VX : MipsInst_VXOR_VX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VXOR_VX {
	let  EncodingPredicates=[];
}
class MSA_VEC_FMT_VXOR_VX<bits<5>  major, bits<6>  minor> : MSAInst_VXOR_VX ;
class BMNZ_V_DESC_VXOR_VX{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vxor.vx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=NoItinerary;
	string  Constraints="";
}
class BMNZ_V_ENC_VXOR_VX : MSA_VEC_FMT_VXOR_VX <0b00100, 0b011110>;
def VXOR_VX : BMNZ_V_ENC_VXOR_VX , BMNZ_V_DESC_VXOR_VX , VXOR_VX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VREDXOR_VS;
class MipsInst_VREDXOR_VS<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VREDXOR_VS {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VREDXOR_VS{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VREDXOR_VS : MipsInst_VREDXOR_VS <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VREDXOR_VS {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VREDXOR_VS<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vredxor.vs	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VREDXOR_VS<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VREDXOR_VS ;
class LDI_W_DESC_VREDXOR_VS : MSA_I10_LDI_DESC_BASE_VREDXOR_VS <"ldi.w", ?>;
class LDI_W_ENC_VREDXOR_VS : MSA_I10_FMT_VREDXOR_VS <0b110, 0b10, 0b000111>;
def VREDXOR_VS : LDI_W_ENC_VREDXOR_VS , LDI_W_DESC_VREDXOR_VS , VREDXOR_VS_AUX {
	  	let mayLoad = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMXOR_MM;
class MipsInst_VMXOR_MM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMXOR_MM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMXOR_MM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMXOR_MM : MipsInst_VMXOR_MM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMXOR_MM {
	let  EncodingPredicates=[];
}
class MSA_BIT_W_FMT_VMXOR_MM<bits<3>  major, bits<6>  minor> : MSAInst_VMXOR_MM ;
class MSA_BIT_W_DESC_BASE_VMXOR_MM<string  instr_asm, SDPatternOperator  OpNode, ComplexPattern  Imm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1);
	string  AsmString="vmxor.mm	$vd, $vs2, $vs1";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class BNEGI_W_ENC_VMXOR_MM : MSA_BIT_W_FMT_VMXOR_MM <0b101, 0b001001>;
class BNEGI_W_DESC_VMXOR_MM : MSA_BIT_W_DESC_BASE_VMXOR_MM <"bnegi.w", null_frag, addr, ?>;
def VMXOR_MM : BNEGI_W_ENC_VMXOR_MM , BNEGI_W_DESC_VMXOR_MM , VMXOR_MM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMXNOR_MM;
class MipsInst_VMXNOR_MM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMXNOR_MM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMXNOR_MM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMXNOR_MM : MipsInst_VMXNOR_MM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMXNOR_MM {
	let  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VMXNOR_MM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1);
	string  AsmString="vmxnor.mm	$vd, $vs2, $vs1";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_FMT_VMXNOR_MM<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMXNOR_MM ;
class BSET_W_DESC_VMXNOR_MM : MSA_3R_DESC_BASE_VMXNOR_MM <"bset.w", null_frag, ?>;
class BSET_W_ENC_VMXNOR_MM : MSA_3R_FMT_VMXNOR_MM <0b100, 0b10, 0b001101>;
def VMXNOR_MM : BSET_W_ENC_VMXNOR_MM , BSET_W_DESC_VMXNOR_MM , VMXNOR_MM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VXOR_VI;
class MipsInst_VXOR_VI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VXOR_VI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VXOR_VI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VXOR_VI : MipsInst_VXOR_VI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VXOR_VI {
	let  EncodingPredicates=[];
}
class MSA_BIT_W_FMT_VXOR_VI<bits<3>  major, bits<6>  minor> : MSAInst_VXOR_VI ;
class MSA_BIT_W_DESC_BASE_VXOR_VI<string  instr_asm, SDPatternOperator  OpNode, ComplexPattern  Imm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, simm5:$imm, VMaskOp:$vm);
	string  AsmString="vxor.vi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class BCLRI_W_ENC_VXOR_VI : MSA_BIT_W_FMT_VXOR_VI <0b011, 0b001001>;
class BCLRI_W_DESC_VXOR_VI : MSA_BIT_W_DESC_BASE_VXOR_VI <"bclri.w", null_frag, addr, ?>;
def VXOR_VI : BCLRI_W_ENC_VXOR_VI , BCLRI_W_DESC_VXOR_VI , VXOR_VI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMERGE_VVM;
class MipsInst_VMERGE_VVM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMERGE_VVM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMERGE_VVM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMERGE_VVM : MipsInst_VMERGE_VVM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMERGE_VVM {
	let  EncodingPredicates=[];
}
class MSA_3R_SPLAT_DESC_BASE_VMERGE_VVM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMV0:$v0);
	string  AsmString="vmerge.vvm	$vd, $vs2, $vs1, v0";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_INDEX_FMT_VMERGE_VVM<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMERGE_VVM ;
class SPLAT_W_DESC_VMERGE_VVM : MSA_3R_SPLAT_DESC_BASE_VMERGE_VVM <"splat.w", null_frag, ?>;
class SPLAT_W_ENC_VMERGE_VVM : MSA_3R_INDEX_FMT_VMERGE_VVM <0b001, 0b10, 0b010100>;
def VMERGE_VVM : SPLAT_W_ENC_VMERGE_VVM , SPLAT_W_DESC_VMERGE_VVM , VMERGE_VVM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMERGE_VXM;
class MipsInst_VMERGE_VXM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMERGE_VXM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMERGE_VXM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMERGE_VXM : MipsInst_VMERGE_VXM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMERGE_VXM {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VMERGE_VXM<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VMERGE_VXM ;
class MSA_2RF_DESC_BASE_VMERGE_VXM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMV0:$v0);
	string  AsmString="vmerge.vxm	$vd, $vs2, $rs1, v0";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FTRUNC_S_W_ENC_VMERGE_VXM : MSA_2RF_FMT_VMERGE_VXM <0b110010001, 0b0, 0b011110>;
class FTRUNC_S_W_DESC_VMERGE_VXM : MSA_2RF_DESC_BASE_VMERGE_VXM <"ftrunc_s.w", null_frag, ?>;
def VMERGE_VXM : FTRUNC_S_W_ENC_VMERGE_VXM , FTRUNC_S_W_DESC_VMERGE_VXM , VMERGE_VXM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VMERGE_VIM;
class MipsInst_VMERGE_VIM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VMERGE_VIM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VMERGE_VIM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VMERGE_VIM : MipsInst_VMERGE_VIM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VMERGE_VIM {
	let  EncodingPredicates=[];
}
class MSA_3R_SPLAT_DESC_BASE_VMERGE_VIM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, simm5:$imm, VMV0:$v0);
	string  AsmString="vmerge.vim	$vd, $vs2, $imm, v0";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_3R_INDEX_FMT_VMERGE_VIM<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VMERGE_VIM ;
class SPLAT_W_DESC_VMERGE_VIM : MSA_3R_SPLAT_DESC_BASE_VMERGE_VIM <"splat.w", null_frag, ?>;
class SPLAT_W_ENC_VMERGE_VIM : MSA_3R_INDEX_FMT_VMERGE_VIM <0b001, 0b10, 0b010100>;
def VMERGE_VIM : SPLAT_W_ENC_VMERGE_VIM , SPLAT_W_DESC_VMERGE_VIM , VMERGE_VIM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VNCLIPU_WV;
class MipsInst_VNCLIPU_WV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VNCLIPU_WV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VNCLIPU_WV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VNCLIPU_WV : MipsInst_VNCLIPU_WV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VNCLIPU_WV {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VNCLIPU_WV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vnclipu.wv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VNCLIPU_WV<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VNCLIPU_WV ;
class FFINT_S_D_DESC_VNCLIPU_WV : MSA_2RF_DESC_BASE_VNCLIPU_WV <"ffint_s.d", null_frag, ?>;
class FFINT_S_D_ENC_VNCLIPU_WV : MSA_2RF_FMT_VNCLIPU_WV <0b110011110, 0b1, 0b011110>;
def VNCLIPU_WV : FFINT_S_D_ENC_VNCLIPU_WV , FFINT_S_D_DESC_VNCLIPU_WV , VNCLIPU_WV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VNCLIPU_WX;
class MipsInst_VNCLIPU_WX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VNCLIPU_WX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VNCLIPU_WX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VNCLIPU_WX : MipsInst_VNCLIPU_WX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VNCLIPU_WX {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VNCLIPU_WX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vnclipu.wx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VNCLIPU_WX<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VNCLIPU_WX ;
class FFINT_S_D_DESC_VNCLIPU_WX : MSA_2RF_DESC_BASE_VNCLIPU_WX <"ffint_s.d", null_frag, ?>;
class FFINT_S_D_ENC_VNCLIPU_WX : MSA_2RF_FMT_VNCLIPU_WX <0b110011110, 0b1, 0b011110>;
def VNCLIPU_WX : FFINT_S_D_ENC_VNCLIPU_WX , FFINT_S_D_DESC_VNCLIPU_WX , VNCLIPU_WX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VNCLIPU_WI;
class MipsInst_VNCLIPU_WI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VNCLIPU_WI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VNCLIPU_WI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSA_3R_DESC_BASE_VNCLIPU_WI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, uimm5:$imm, VMaskOp:$vm);
	string  AsmString="vnclipu.wi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSAInst_VNCLIPU_WI : MipsInst_VNCLIPU_WI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VNCLIPU_WI {
	let  EncodingPredicates=[];
}
class MSA_3RF_DESC_BASE_VNCLIPU_WI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary> : MSA_3R_DESC_BASE_VNCLIPU_WI <instr_asm, OpNode, ROWD, ROWS, ROWT, itin>;
class MSA_3RF_FMT_VNCLIPU_WI<bits<4>  major, bits<1>  df, bits<6>  minor> : MSAInst_VNCLIPU_WI ;
class FEXDO_W_DESC_VNCLIPU_WI : MSA_3RF_DESC_BASE_VNCLIPU_WI <"fexdo.w", null_frag, ?, ?, ?>;
class FEXDO_W_ENC_VNCLIPU_WI : MSA_3RF_FMT_VNCLIPU_WI <0b1000, 0b1, 0b011011>;
def VNCLIPU_WI : FEXDO_W_ENC_VNCLIPU_WI , FEXDO_W_DESC_VNCLIPU_WI , VNCLIPU_WI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VNCLIP_WV;
class MipsInst_VNCLIP_WV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VNCLIP_WV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VNCLIP_WV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VNCLIP_WV : MipsInst_VNCLIP_WV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VNCLIP_WV {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VNCLIP_WV<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VNCLIP_WV ;
class MSA_2RF_DESC_BASE_VNCLIP_WV<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vnclip.wv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FFQL_D_ENC_VNCLIP_WV : MSA_2RF_FMT_VNCLIP_WV <0b110011010, 0b1, 0b011110>;
class FFQL_D_DESC_VNCLIP_WV : MSA_2RF_DESC_BASE_VNCLIP_WV <"ffql.d", null_frag, ?, ?>;
def VNCLIP_WV : FFQL_D_ENC_VNCLIP_WV , FFQL_D_DESC_VNCLIP_WV , VNCLIP_WV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VNCLIP_WX;
class MipsInst_VNCLIP_WX<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VNCLIP_WX {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VNCLIP_WX{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VNCLIP_WX : MipsInst_VNCLIP_WX <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VNCLIP_WX {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VNCLIP_WX<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, GPR:$rs1, VMaskOp:$vm);
	string  AsmString="vnclip.wx	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VNCLIP_WX<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VNCLIP_WX ;
class FFINT_S_D_DESC_VNCLIP_WX : MSA_2RF_DESC_BASE_VNCLIP_WX <"ffint_s.d", null_frag, ?>;
class FFINT_S_D_ENC_VNCLIP_WX : MSA_2RF_FMT_VNCLIP_WX <0b110011110, 0b1, 0b011110>;
def VNCLIP_WX : FFINT_S_D_ENC_VNCLIP_WX , FFINT_S_D_DESC_VNCLIP_WX , VNCLIP_WX_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VNCLIP_WI;
class MipsInst_VNCLIP_WI<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VNCLIP_WI {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VNCLIP_WI{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VNCLIP_WI : MipsInst_VNCLIP_WI <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VNCLIP_WI {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VNCLIP_WI<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, uimm5:$imm, VMaskOp:$vm);
	string  AsmString="vnclip.wi	$vd, $vs2, $imm$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VNCLIP_WI<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VNCLIP_WI ;
class FFQR_D_DESC_VNCLIP_WI : MSA_2RF_DESC_BASE_VNCLIP_WI <"ffqr.d", null_frag, ?, ?>;
class FFQR_D_ENC_VNCLIP_WI : MSA_2RF_FMT_VNCLIP_WI <0b110011011, 0b1, 0b011110>;
def VNCLIP_WI : FFQR_D_ENC_VNCLIP_WI , FFQR_D_DESC_VNCLIP_WI , VNCLIP_WI_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VFSGNJ_VV;
class MipsInst_VFSGNJ_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFSGNJ_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFSGNJ_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFSGNJ_VV : MipsInst_VFSGNJ_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFSGNJ_VV {
	let  EncodingPredicates=[];
}
class MSA_ELM_INSERT_W_FMT_VFSGNJ_VV<bits<4>  major, bits<6>  minor> : MSAInst_VFSGNJ_VV ;
class MSA_INSERT_DESC_BASE_VFSGNJ_VV<string  instr_asm, SDPatternOperator  OpNode, Operand  ImmOp, ImmLeaf  Imm, RegisterOperand  ROWD, RegisterOperand  ROS, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vfsgnj.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="";
}
class INSERT_W_ENC_VFSGNJ_VV : MSA_ELM_INSERT_W_FMT_VFSGNJ_VV <0b0100, 0b011001>;
class INSERT_W_DESC_VFSGNJ_VV : MSA_INSERT_DESC_BASE_VFSGNJ_VV <"insert.w", null_frag, ?, ?, ?, ?>;
def VFSGNJ_VV : INSERT_W_ENC_VFSGNJ_VV , INSERT_W_DESC_VFSGNJ_VV , VFSGNJ_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFSGNJ_VF;
class MipsInst_VFSGNJ_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFSGNJ_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFSGNJ_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFSGNJ_VF : MipsInst_VFSGNJ_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFSGNJ_VF {
	let  EncodingPredicates=[];
}
class MSA_ELM_W_FMT_VFSGNJ_VF<bits<4>  major, bits<6>  minor> : MSAInst_VFSGNJ_VF ;
class MSA_ELM_SPLAT_DESC_BASE_VFSGNJ_VF<string  instr_asm, ComplexPattern  SplatImm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vfsgnj.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class SPLATI_W_ENC_VFSGNJ_VF : MSA_ELM_W_FMT_VFSGNJ_VF <0b0001, 0b011001>;
class SPLATI_W_DESC_VFSGNJ_VF : MSA_ELM_SPLAT_DESC_BASE_VFSGNJ_VF <"splati.w", ?, ?>;
def VFSGNJ_VF : SPLATI_W_ENC_VFSGNJ_VF , SPLATI_W_DESC_VFSGNJ_VF , VFSGNJ_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFSGNJN_VV;
class MipsInst_VFSGNJN_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFSGNJN_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFSGNJN_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFSGNJN_VV : MipsInst_VFSGNJN_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFSGNJN_VV {
	let  EncodingPredicates=[];
}
class MSA_ELM_INSERT_W_FMT_VFSGNJN_VV<bits<4>  major, bits<6>  minor> : MSAInst_VFSGNJN_VV ;
class MSA_INSERT_DESC_BASE_VFSGNJN_VV<string  instr_asm, SDPatternOperator  OpNode, Operand  ImmOp, ImmLeaf  Imm, RegisterOperand  ROWD, RegisterOperand  ROS, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vfsgnjn.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="";
}
class INSERT_W_ENC_VFSGNJN_VV : MSA_ELM_INSERT_W_FMT_VFSGNJN_VV <0b0100, 0b011001>;
class INSERT_W_DESC_VFSGNJN_VV : MSA_INSERT_DESC_BASE_VFSGNJN_VV <"insert.w", null_frag, ?, ?, ?, ?>;
def VFSGNJN_VV : INSERT_W_ENC_VFSGNJN_VV , INSERT_W_DESC_VFSGNJN_VV , VFSGNJN_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFSGNJN_VF;
class MipsInst_VFSGNJN_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFSGNJN_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFSGNJN_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFSGNJN_VF : MipsInst_VFSGNJN_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFSGNJN_VF {
	let  EncodingPredicates=[];
}
class MSA_ELM_INSERT_W_FMT_VFSGNJN_VF<bits<4>  major, bits<6>  minor> : MSAInst_VFSGNJN_VF ;
class MSA_INSERT_DESC_BASE_VFSGNJN_VF<string  instr_asm, SDPatternOperator  OpNode, Operand  ImmOp, ImmLeaf  Imm, RegisterOperand  ROWD, RegisterOperand  ROS, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vfsgnjn.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="";
}
class INSERT_W_ENC_VFSGNJN_VF : MSA_ELM_INSERT_W_FMT_VFSGNJN_VF <0b0100, 0b011001>;
class INSERT_W_DESC_VFSGNJN_VF : MSA_INSERT_DESC_BASE_VFSGNJN_VF <"insert.w", null_frag, ?, ?, ?, ?>;
def VFSGNJN_VF : INSERT_W_ENC_VFSGNJN_VF , INSERT_W_DESC_VFSGNJN_VF , VFSGNJN_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFSGNJX_VV;
class MipsInst_VFSGNJX_VV<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFSGNJX_VV {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFSGNJX_VV{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFSGNJX_VV : MipsInst_VFSGNJX_VV <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFSGNJX_VV {
	let  EncodingPredicates=[];
}
class MSA_ELM_W_FMT_VFSGNJX_VV<bits<4>  major, bits<6>  minor> : MSAInst_VFSGNJX_VV ;
class MSA_ELM_SPLAT_DESC_BASE_VFSGNJX_VV<string  instr_asm, ComplexPattern  SplatImm, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vfsgnjx.vv	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class SPLATI_W_ENC_VFSGNJX_VV : MSA_ELM_W_FMT_VFSGNJX_VV <0b0001, 0b011001>;
class SPLATI_W_DESC_VFSGNJX_VV : MSA_ELM_SPLAT_DESC_BASE_VFSGNJX_VV <"splati.w", ?, ?>;
def VFSGNJX_VV : SPLATI_W_ENC_VFSGNJX_VV , SPLATI_W_DESC_VFSGNJX_VV , VFSGNJX_VV_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFSGNJX_VF;
class MipsInst_VFSGNJX_VF<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFSGNJX_VF {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFSGNJX_VF{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFSGNJX_VF : MipsInst_VFSGNJX_VF <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFSGNJX_VF {
	let  EncodingPredicates=[];
}
class MSA_ELM_INSERT_W_FMT_VFSGNJX_VF<bits<4>  major, bits<6>  minor> : MSAInst_VFSGNJX_VF ;
class MSA_INSERT_DESC_BASE_VFSGNJX_VF<string  instr_asm, SDPatternOperator  OpNode, Operand  ImmOp, ImmLeaf  Imm, RegisterOperand  ROWD, RegisterOperand  ROS, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMaskOp:$vm);
	string  AsmString="vfsgnjx.vf	$vd, $vs2, $rs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  Constraints="";
}
class INSERT_W_ENC_VFSGNJX_VF : MSA_ELM_INSERT_W_FMT_VFSGNJX_VF <0b0100, 0b011001>;
class INSERT_W_DESC_VFSGNJX_VF : MSA_INSERT_DESC_BASE_VFSGNJX_VF <"insert.w", null_frag, ?, ?, ?, ?>;
def VFSGNJX_VF : INSERT_W_ENC_VFSGNJX_VF , INSERT_W_DESC_VFSGNJX_VF , VFSGNJX_VF_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFMERGE_VFM;
class MipsInst_VFMERGE_VFM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFMERGE_VFM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFMERGE_VFM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFMERGE_VFM : MipsInst_VFMERGE_VFM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFMERGE_VFM {
	let  EncodingPredicates=[];
}
class MSA_2RF_FMT_VFMERGE_VFM<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VFMERGE_VFM ;
class MSA_2RF_DESC_BASE_VFMERGE_VFM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, FPR32:$rs1, VMV0:$v0);
	string  AsmString="vfmerge.vfm	$vd, $vs2, $rs1, v0";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class FTRUNC_S_W_ENC_VFMERGE_VFM : MSA_2RF_FMT_VFMERGE_VFM <0b110010001, 0b0, 0b011110>;
class FTRUNC_S_W_DESC_VFMERGE_VFM : MSA_2RF_DESC_BASE_VFMERGE_VFM <"ftrunc_s.w", null_frag, ?>;
def VFMERGE_VFM : FTRUNC_S_W_ENC_VFMERGE_VFM , FTRUNC_S_W_DESC_VFMERGE_VFM , VFMERGE_VFM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VREDSUM_VS;
class MipsInst_VREDSUM_VS<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VREDSUM_VS {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VREDSUM_VS{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VREDSUM_VS : MipsInst_VREDSUM_VS <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VREDSUM_VS {
	let  EncodingPredicates=[];
}
class MSA_I10_LDI_DESC_BASE_VREDSUM_VS<string  instr_asm, RegisterOperand  ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vredsum.vs	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	bit  hasSideEffects=0;
	InstrItinClass  Itinerary=itin;
}
class MSA_I10_FMT_VREDSUM_VS<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VREDSUM_VS ;
class LDI_W_DESC_VREDSUM_VS : MSA_I10_LDI_DESC_BASE_VREDSUM_VS <"ldi.w", ?>;
class LDI_W_ENC_VREDSUM_VS : MSA_I10_FMT_VREDSUM_VS <0b110, 0b10, 0b000111>;
def VREDSUM_VS : LDI_W_ENC_VREDSUM_VS , LDI_W_DESC_VREDSUM_VS , VREDSUM_VS_AUX {
	  	let mayLoad = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWREDSUMU_VS;
class MipsInst_VWREDSUMU_VS<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWREDSUMU_VS {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWREDSUMU_VS{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWREDSUMU_VS : MipsInst_VWREDSUMU_VS <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWREDSUMU_VS {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VWREDSUMU_VS<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vwredsumu.vs	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VWREDSUMU_VS<bits<2>  df, bits<4>  minor> : MSAInst_VWREDSUMU_VS ;
class LD_D_DESC_VWREDSUMU_VS : LD_DESC_BASE_VWREDSUMU_VS <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VWREDSUMU_VS : MSA_MI10_FMT_VWREDSUMU_VS <0b11, 0b1000>;
def VWREDSUMU_VS : LD_D_ENC_VWREDSUMU_VS , LD_D_DESC_VWREDSUMU_VS , VWREDSUMU_VS_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VWREDSUM_VS;
class MipsInst_VWREDSUM_VS<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VWREDSUM_VS {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VWREDSUM_VS{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VWREDSUM_VS : MipsInst_VWREDSUM_VS <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VWREDSUM_VS {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VWREDSUM_VS<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vwredsum.vs	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VWREDSUM_VS<bits<2>  df, bits<4>  minor> : MSAInst_VWREDSUM_VS ;
class LD_D_DESC_VWREDSUM_VS : LD_DESC_BASE_VWREDSUM_VS <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VWREDSUM_VS : MSA_MI10_FMT_VWREDSUM_VS <0b11, 0b1000>;
def VWREDSUM_VS : LD_D_ENC_VWREDSUM_VS , LD_D_DESC_VWREDSUM_VS , VWREDSUM_VS_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
class PredicateControl_VFREDSUM_VS;
class MipsInst_VFREDSUM_VS<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFREDSUM_VS {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFREDSUM_VS{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFREDSUM_VS : MipsInst_VFREDSUM_VS <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFREDSUM_VS {
	let  EncodingPredicates=[];
}
class MSA_3R_FMT_VFREDSUM_VS<bits<3>  major, bits<2>  df, bits<6>  minor> : MSAInst_VFREDSUM_VS ;
class MSA_3R_DESC_BASE_VFREDSUM_VS<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, RegisterOperand  ROWT=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vfredsum.vs	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class IsCommutable_VFREDSUM_VS{
	bit  isCommutable=false;
}
class AVE_U_W_ENC_VFREDSUM_VS : MSA_3R_FMT_VFREDSUM_VS <0b101, 0b10, 0b010000>;
class AVE_U_W_DESC_VFREDSUM_VS : MSA_3R_DESC_BASE_VFREDSUM_VS <"ave_u.w", null_frag, ?>, IsCommutable_VFREDSUM_VS ;
def VFREDSUM_VS : AVE_U_W_ENC_VFREDSUM_VS , AVE_U_W_DESC_VFREDSUM_VS , VFREDSUM_VS_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VFWREDSUM_VS;
class MipsInst_VFWREDSUM_VS<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VFWREDSUM_VS {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VFWREDSUM_VS{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VFWREDSUM_VS : MipsInst_VFWREDSUM_VS <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VFWREDSUM_VS {
	let  EncodingPredicates=[];
}
class LD_DESC_BASE_VFWREDSUM_VS<string  instr_asm, SDPatternOperator  OpNode, ValueType  TyNode, RegisterOperand  ROWD, Operand  MemOpnd, ComplexPattern  Addr=addr, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1, VMaskOp:$vm);
	string  AsmString="vfwredsum.vs	$vd, $vs2, $vs1$vm";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
	string  DecoderMethod="";
}
class MSA_MI10_FMT_VFWREDSUM_VS<bits<2>  df, bits<4>  minor> : MSAInst_VFWREDSUM_VS ;
class LD_D_DESC_VFWREDSUM_VS : LD_DESC_BASE_VFWREDSUM_VS <"ld.d", null_frag, ?, ?, ?, addr>;
class LD_D_ENC_VFWREDSUM_VS : MSA_MI10_FMT_VFWREDSUM_VS <0b11, 0b1000>;
def VFWREDSUM_VS : LD_D_ENC_VFWREDSUM_VS , LD_D_DESC_VFWREDSUM_VS , VFWREDSUM_VS_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV, HasStdExtF];
}
class PredicateControl_VCOMPRESS_VM;
class MipsInst_VCOMPRESS_VM<dag  outs, dag  ins, string  asmstr, list<dag>  pattern, InstrItinClass  itin, InstFormat  f> : Instruction , PredicateControl_VCOMPRESS_VM {
	InstFormat  Form=f;
	let  Namespace="RISCV";
	let  Size=4;
	let  OutOperandList=outs;
	let  InOperandList=ins;
	let  AsmString=asmstr;
	let  Pattern=pattern;
	let  Itinerary=itin;
	bit  isCTI=0;
	bit  hasForbiddenSlot=0;
	bit  IsPCRelativeLoad=0;
	bit  hasFCCRegOperand=0;
	let  DecoderNamespace="";
}
class ASE_MSA_VCOMPRESS_VM{
	list<Predicate>  ASEPredicate=[];
	list<Predicate>  EncodingPredicates=[];
}
class MSAInst_VCOMPRESS_VM : MipsInst_VCOMPRESS_VM <(outs), (ins), "", [], NoItinerary, InstFormatR>, ASE_MSA_VCOMPRESS_VM {
	let  EncodingPredicates=[];
}
class MSA_2RF_DESC_BASE_VCOMPRESS_VM<string  instr_asm, SDPatternOperator  OpNode, RegisterOperand  ROWD, RegisterOperand  ROWS=ROWD, InstrItinClass  itin=NoItinerary>{
	dag  OutOperandList=(outs VR:$vd);
	dag  InOperandList=(ins VR:$vs2, VR:$vs1);
	string  AsmString="vcompress.vm	$vd, $vs2, $vs1";
	list<dag>  Pattern=[];
	InstrItinClass  Itinerary=itin;
}
class MSA_2RF_FMT_VCOMPRESS_VM<bits<9>  major, bits<1>  df, bits<6>  minor> : MSAInst_VCOMPRESS_VM ;
class FEXUPR_W_DESC_VCOMPRESS_VM : MSA_2RF_DESC_BASE_VCOMPRESS_VM <"fexupr.w", null_frag, ?, ?>;
class FEXUPR_W_ENC_VCOMPRESS_VM : MSA_2RF_FMT_VCOMPRESS_VM <0b110011001, 0b0, 0b011110>;
def VCOMPRESS_VM : FEXUPR_W_ENC_VCOMPRESS_VM , FEXUPR_W_DESC_VCOMPRESS_VM , VCOMPRESS_VM_AUX {
	  	let mayLoad = 0;
	let hasSideEffects = 0;
	let mayStore = 0;
	let Constraints = "@earlyclobber $vd";
	let Uses = [VTYPE, VL];
	let Predicates = [HasStdExtV];
}
